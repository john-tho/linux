/*
 * Copyright 2019, Amazon.com, Inc. or its affiliates. All Rights Reserved
 */

/**
 *  @{
 * @file   al_hal_udma_m2s_regs.h
 *
 * @brief udma_m2s registers
 *
 * This file was auto-generated by RegGen v1.3.14
 *
 * Hash Key is: 47adb575154dbc0ce349a94c3c7b5801
 *
 * JSON: al_udma_m2s_regs.json
 *
 */

#ifndef __AL_HAL_UDMA_M2S_REGS_H__
#define __AL_HAL_UDMA_M2S_REGS_H__

#include "al_hal_common.h"

#ifdef __cplusplus
extern "C" {
#endif

/**************************************************************************************************
 * udma_axi_m2s
 *
 * AXI M2S configuration
 **************************************************************************************************/
struct udma_axi_m2s {
	/* [0x0] Completion write master configuration */
	uint32_t comp_wr_cfg_1;
	/* [0x4] Completion write master configuration */
	uint32_t comp_wr_cfg_2;
	/* [0x8] Data read master configuration */
	uint32_t data_rd_cfg_1;
	/* [0xc] Data read master configuration */
	uint32_t data_rd_cfg_2;
	/* [0x10] Descriptor read master configuration */
	uint32_t desc_rd_cfg_1;
	/* [0x14] Descriptor read master configuration */
	uint32_t desc_rd_cfg_2;
	/* [0x18] Data read master configuration */
	uint32_t data_rd_cfg;
	/* [0x1c] Descriptors read master configuration */
	uint32_t desc_rd_cfg_3;
	/* [0x20] Descriptors write master configuration (completion) */
	uint32_t desc_wr_cfg_1;
	/* [0x24] AXI outstanding  configuration */
	uint32_t ostand_cfg;
	/* [0x28] AXI outstanding indication status */
	uint32_t data_rd_cfg3;
	/* [0x2c] AXI outstanding indication status */
	uint32_t desc_rd_cfg4;
	/* [0x30] AXI outstanding indication status */
	uint32_t desc_wr_cfg2;
	/* [0x34] */
	uint32_t rsrvd_0[51];
};

/**** comp_wr_cfg_1 register ****/
/*
 * AXI write  ID (AWID)
 * Reset: 0x0         Access: RW
 */
#define UDMA_AXI_M2S_COMP_WR_CFG_1_AWID_MASK 0x000000FF
#define UDMA_AXI_M2S_COMP_WR_CFG_1_AWID_SHIFT 0
/*
 * Cache Type serving MSIX engine (re-allocated as unused for completions). Completions use a
 * separate AWCache per queue and are at the Per-Queue registers section.
 * Reset: 0x7         Access: RW
 */
#define UDMA_AXI_M2S_COMP_WR_CFG_1_AWCACHE_MASK 0x000F0000
#define UDMA_AXI_M2S_COMP_WR_CFG_1_AWCACHE_SHIFT 16
/*
 * Burst type
 * Reset: 0x1         Access: RW
 */
#define UDMA_AXI_M2S_COMP_WR_CFG_1_AWBURST_MASK 0x03000000
#define UDMA_AXI_M2S_COMP_WR_CFG_1_AWBURST_SHIFT 24

/**** comp_wr_cfg_2 register ****/
/*
 * User extension
 * Reset: 0x0         Access: RW
 */
#define UDMA_AXI_M2S_COMP_WR_CFG_2_AWUSER_MASK 0x000FFFFF
#define UDMA_AXI_M2S_COMP_WR_CFG_2_AWUSER_SHIFT 0
/*
 * Bus size, 256-bit
 * Reset: 0x5         Access: RW
 */
#define UDMA_AXI_M2S_COMP_WR_CFG_2_AWSIZE_MASK 0x00700000
#define UDMA_AXI_M2S_COMP_WR_CFG_2_AWSIZE_SHIFT 20
/*
 * AXI Master QoS.
 * Used for arbitration between AXI masters
 * Reset: 0x0         Access: RW
 */
#define UDMA_AXI_M2S_COMP_WR_CFG_2_AWQOS_MASK 0x07000000
#define UDMA_AXI_M2S_COMP_WR_CFG_2_AWQOS_SHIFT 24
/*
 * Protection Type
 * Reset: 0x3         Access: RW
 */
#define UDMA_AXI_M2S_COMP_WR_CFG_2_AWPROT_MASK 0x70000000
#define UDMA_AXI_M2S_COMP_WR_CFG_2_AWPROT_SHIFT 28

/**** data_rd_cfg_1 register ****/
/*
 * AXI read  ID (ARID)
 * Reset: 0x1         Access: RW
 */
#define UDMA_AXI_M2S_DATA_RD_CFG_1_ARID_MASK 0x000000FF
#define UDMA_AXI_M2S_DATA_RD_CFG_1_ARID_SHIFT 0
/*
 * Cache Type
 * Reset: 0xb         Access: RW
 */
#define UDMA_AXI_M2S_DATA_RD_CFG_1_ARCACHE_MASK 0x000F0000
#define UDMA_AXI_M2S_DATA_RD_CFG_1_ARCACHE_SHIFT 16
/*
 * Burst type
 * Reset: 0x1         Access: RW
 */
#define UDMA_AXI_M2S_DATA_RD_CFG_1_ARBURST_MASK 0x03000000
#define UDMA_AXI_M2S_DATA_RD_CFG_1_ARBURST_SHIFT 24

/**** data_rd_cfg_2 register ****/
/*
 * User extension
 * Reset: 0x0         Access: RW
 */
#define UDMA_AXI_M2S_DATA_RD_CFG_2_ARUSER_MASK 0x000FFFFF
#define UDMA_AXI_M2S_DATA_RD_CFG_2_ARUSER_SHIFT 0
/*
 * Bus size, 256-bit
 * Reset: 0x5         Access: RW
 */
#define UDMA_AXI_M2S_DATA_RD_CFG_2_ARSIZE_MASK 0x00700000
#define UDMA_AXI_M2S_DATA_RD_CFG_2_ARSIZE_SHIFT 20
/*
 * AXI Master QoS.
 * Used for arbitration between AXI masters
 * Reset: 0x2         Access: RW
 */
#define UDMA_AXI_M2S_DATA_RD_CFG_2_ARQOS_MASK 0x07000000
#define UDMA_AXI_M2S_DATA_RD_CFG_2_ARQOS_SHIFT 24
/*
 * Protection Type
 * Reset: 0x3         Access: RW
 */
#define UDMA_AXI_M2S_DATA_RD_CFG_2_ARPROT_MASK 0x70000000
#define UDMA_AXI_M2S_DATA_RD_CFG_2_ARPROT_SHIFT 28

/**** desc_rd_cfg_1 register ****/
/*
 * AXI read  ID (ARID)
 * Reset: 0x0         Access: RW
 */
#define UDMA_AXI_M2S_DESC_RD_CFG_1_ARID_MASK 0x000000FF
#define UDMA_AXI_M2S_DESC_RD_CFG_1_ARID_SHIFT 0
/*
 * Cache Type
 * Reset: 0xb         Access: RW
 */
#define UDMA_AXI_M2S_DESC_RD_CFG_1_ARCACHE_MASK 0x000F0000
#define UDMA_AXI_M2S_DESC_RD_CFG_1_ARCACHE_SHIFT 16
/*
 * Burst type
 * Reset: 0x1         Access: RW
 */
#define UDMA_AXI_M2S_DESC_RD_CFG_1_ARBURST_MASK 0x03000000
#define UDMA_AXI_M2S_DESC_RD_CFG_1_ARBURST_SHIFT 24

/**** desc_rd_cfg_2 register ****/
/*
 * User extension
 * Reset: 0x0         Access: RW
 */
#define UDMA_AXI_M2S_DESC_RD_CFG_2_ARUSER_MASK 0x000FFFFF
#define UDMA_AXI_M2S_DESC_RD_CFG_2_ARUSER_SHIFT 0
/*
 * Bus size, 256-bit
 * Reset: 0x5         Access: RW
 */
#define UDMA_AXI_M2S_DESC_RD_CFG_2_ARSIZE_MASK 0x00700000
#define UDMA_AXI_M2S_DESC_RD_CFG_2_ARSIZE_SHIFT 20
/*
 * AXI Master QoS
 * Used for arbitration between AXI masters
 * Reset: 0x2         Access: RW
 */
#define UDMA_AXI_M2S_DESC_RD_CFG_2_ARQOS_MASK 0x07000000
#define UDMA_AXI_M2S_DESC_RD_CFG_2_ARQOS_SHIFT 24
/*
 * Protection Type
 * Reset: 0x3         Access: RW
 */
#define UDMA_AXI_M2S_DESC_RD_CFG_2_ARPROT_MASK 0x70000000
#define UDMA_AXI_M2S_DESC_RD_CFG_2_ARPROT_SHIFT 28

/**** data_rd_cfg register ****/
/*
 * Defines the maximum number of AXI beats for a single AXI burst.
 * This value is used for a burst split decision.
 * Reset: 0x8         Access: RW
 */
#define UDMA_AXI_M2S_DATA_RD_CFG_MAX_AXI_BEATS_MASK 0x000000FF
#define UDMA_AXI_M2S_DATA_RD_CFG_MAX_AXI_BEATS_SHIFT 0
/*
 * Enable breaking data read request.
 * Aligned to max_AXI_beats when the total read size is less than max_AXI_beats
 * Reset: 0x0         Access: RW
 */
#define UDMA_AXI_M2S_DATA_RD_CFG_ALWAYS_BREAK_ON_MAX_BOUDRY (1 << 16)
#define UDMA_AXI_M2S_DATA_RD_CFG_ALWAYS_BREAK_ON_MAX_BOUDRY_MASK 0x00010000
#define UDMA_AXI_M2S_DATA_RD_CFG_ALWAYS_BREAK_ON_MAX_BOUDRY_SHIFT 16

/**** desc_rd_cfg_3 register ****/
/*
 * Defines the maximum number of AXI beats for a single AXI burst.
 * This value is used for a burst split decision.
 * Maximum burst size for reading data( in AXI beats, 256-bits)
 * (default - 16 beats, 512 bytes)
 * Reset: 0x8         Access: RW
 */
#define UDMA_AXI_M2S_DESC_RD_CFG_3_MAX_AXI_BEATS_MASK 0x000000FF
#define UDMA_AXI_M2S_DESC_RD_CFG_3_MAX_AXI_BEATS_SHIFT 0
/*
 * Enable breaking descriptor read request.
 * Aligned to max_AXI_beats when the total read size is less than max_AXI_beats.
 * Reset: 0x1         Access: RW
 */
#define UDMA_AXI_M2S_DESC_RD_CFG_3_ALWAYS_BREAK_ON_MAX_BOUDRY (1 << 16)
#define UDMA_AXI_M2S_DESC_RD_CFG_3_ALWAYS_BREAK_ON_MAX_BOUDRY_MASK 0x00010000
#define UDMA_AXI_M2S_DESC_RD_CFG_3_ALWAYS_BREAK_ON_MAX_BOUDRY_SHIFT 16

/**** desc_wr_cfg_1 register ****/
/*
 * Defines the maximum number of AXI beats for a single AXI burst.
 * This value is used for a burst split decision.
 * Reset: 0x8         Access: RW
 */
#define UDMA_AXI_M2S_DESC_WR_CFG_1_MAX_AXI_BEATS_MASK 0x000000FF
#define UDMA_AXI_M2S_DESC_WR_CFG_1_MAX_AXI_BEATS_SHIFT 0
/*
 * Minimum burst for writing completion descriptors.
 * Defined in AXI beats
 * 8 Descriptors per beat.
 * Value must be aligned to cache lines (64 bytes).
 * Default value is 2 cache lines, 32 descriptors, 4 beats.
 * Reset: 0x4         Access: RW
 */
#define UDMA_AXI_M2S_DESC_WR_CFG_1_MIN_AXI_BEATS_MASK 0x00FF0000
#define UDMA_AXI_M2S_DESC_WR_CFG_1_MIN_AXI_BEATS_SHIFT 16

/**** ostand_cfg register ****/
/*
 * Maximum number of outstanding data reads to the AXI (AXI transactions) - up to 128
 * Reset: 0x40        Access: RW
 */
#define UDMA_AXI_M2S_OSTAND_CFG_MAX_DATA_RD_MASK 0x000000FF
#define UDMA_AXI_M2S_OSTAND_CFG_MAX_DATA_RD_SHIFT 0
/*
 * Maximum number of outstanding descriptor reads to the AXI (AXI transactions) - up to 128
 * Reset: 0x20        Access: RW
 */
#define UDMA_AXI_M2S_OSTAND_CFG_MAX_DESC_RD_MASK 0x0000FF00
#define UDMA_AXI_M2S_OSTAND_CFG_MAX_DESC_RD_SHIFT 8
/*
 * Maximum number of outstanding descriptor writes to the AXI (AXI transactions) - up to 128
 * Reset: 0x20        Access: RW
 */
#define UDMA_AXI_M2S_OSTAND_CFG_MAX_COMP_REQ_MASK 0x00FF0000
#define UDMA_AXI_M2S_OSTAND_CFG_MAX_COMP_REQ_SHIFT 16
/*
 * Maximum number of outstanding data beats for descriptor write to AXI (AXI beats) - up to 32
 * Reset: 0x20        Access: RW
 */
#define UDMA_AXI_M2S_OSTAND_CFG_MAX_COMP_DATA_WR_MASK 0xFF000000
#define UDMA_AXI_M2S_OSTAND_CFG_MAX_COMP_DATA_WR_SHIFT 24

/**** data_rd_cfg3 register ****/
/*
 * Number of current outstanding transaction
 * Reset: 0x0         Access: RO
 */
#define UDMA_AXI_M2S_DATA_RD_CFG3_FIFO_INUSE_MASK 0x000000FF
#define UDMA_AXI_M2S_DATA_RD_CFG3_FIFO_INUSE_SHIFT 0
/*
 * Indication if fifo is full
 * Reset: 0x0         Access: RO
 */
#define UDMA_AXI_M2S_DATA_RD_CFG3_FIFO_FULL (1 << 8)
#define UDMA_AXI_M2S_DATA_RD_CFG3_FIFO_FULL_MASK 0x00000100
#define UDMA_AXI_M2S_DATA_RD_CFG3_FIFO_FULL_SHIFT 8
/*
 * Indication if empty  is full
 * Reset: 0x0         Access: RO
 */
#define UDMA_AXI_M2S_DATA_RD_CFG3_FIFO_EMPTY (1 << 9)
#define UDMA_AXI_M2S_DATA_RD_CFG3_FIFO_EMPTY_MASK 0x00000200
#define UDMA_AXI_M2S_DATA_RD_CFG3_FIFO_EMPTY_SHIFT 9

/**** desc_rd_cfg4 register ****/
/*
 * Number of current outstanding transaction
 * Reset: 0x0         Access: RO
 */
#define UDMA_AXI_M2S_DESC_RD_CFG4_FIFO_INUSE_MASK 0x000000FF
#define UDMA_AXI_M2S_DESC_RD_CFG4_FIFO_INUSE_SHIFT 0
/*
 * Indication if fifo is full
 * Reset: 0x0         Access: RO
 */
#define UDMA_AXI_M2S_DESC_RD_CFG4_FIFO_FULL (1 << 8)
#define UDMA_AXI_M2S_DESC_RD_CFG4_FIFO_FULL_MASK 0x00000100
#define UDMA_AXI_M2S_DESC_RD_CFG4_FIFO_FULL_SHIFT 8
/*
 * Indication if empty  is full
 * Reset: 0x0         Access: RO
 */
#define UDMA_AXI_M2S_DESC_RD_CFG4_FIFO_EMPTY (1 << 9)
#define UDMA_AXI_M2S_DESC_RD_CFG4_FIFO_EMPTY_MASK 0x00000200
#define UDMA_AXI_M2S_DESC_RD_CFG4_FIFO_EMPTY_SHIFT 9

/**** desc_wr_cfg2 register ****/
/*
 * Number of current outstanding transaction
 * Reset: 0x0         Access: RO
 */
#define UDMA_AXI_M2S_DESC_WR_CFG2_FIFO_INUSE_MASK 0x000000FF
#define UDMA_AXI_M2S_DESC_WR_CFG2_FIFO_INUSE_SHIFT 0
/*
 * Indication if fifo is full
 * Reset: 0x0         Access: RO
 */
#define UDMA_AXI_M2S_DESC_WR_CFG2_FIFO_FULL (1 << 8)
#define UDMA_AXI_M2S_DESC_WR_CFG2_FIFO_FULL_MASK 0x00000100
#define UDMA_AXI_M2S_DESC_WR_CFG2_FIFO_FULL_SHIFT 8
/*
 * Indication if empty  is full
 * Reset: 0x0         Access: RO
 */
#define UDMA_AXI_M2S_DESC_WR_CFG2_FIFO_EMPTY (1 << 9)
#define UDMA_AXI_M2S_DESC_WR_CFG2_FIFO_EMPTY_MASK 0x00000200
#define UDMA_AXI_M2S_DESC_WR_CFG2_FIFO_EMPTY_SHIFT 9

/**************************************************************************************************
 * udma_m2s
 *
 * M2S general configuration
 **************************************************************************************************/
struct udma_m2s {
	/*
	 * [0x0] DMA state.
	 * 00  - No pending tasks
	 * 01 - Normal (active)
	 * 10 - Abort (error condition)
	 * 11 - Reserved
	 */
	uint32_t state;
	/* [0x4] CPU request to change DMA state */
	uint32_t change_state;
	/* [0x8] */
	uint32_t rsrvd_0;
	/*
	 * [0xc] M2S DMA error log mask.
	 * Each error has an interrupt controller cause bit.
	 * This register determines if these errors cause the M2S DMA to log the error condition.
	 * 0 - Log is enabled.
	 * 1 - Log is masked.
	 */
	uint32_t err_log_mask;
	/* [0x10] */
	uint32_t rsrvd_1;
	/*
	 * [0x14] DMA header log.
	 * Sample the packet header that caused the error.
	 */
	uint32_t log_0;
	/*
	 * [0x18] DMA header log.
	 * Sample the packet header that caused the error.
	 */
	uint32_t log_1;
	/*
	 * [0x1c] DMA header log.
	 * Sample the packet header that caused the error.
	 */
	uint32_t log_2;
	/*
	 * [0x20] DMA header log.
	 * Sample the packet header that caused the error.
	 */
	uint32_t log_3;
	/* [0x24] DMA clear error log */
	uint32_t clear_err_log;
	/* [0x28] M2S data FIFO status */
	uint32_t data_fifo_status;
	/* [0x2c] M2S header FIFO status */
	uint32_t header_fifo_status;
	/* [0x30] M2S unack FIFO status */
	uint32_t unack_fifo_status;
	/* [0x34] Select queue for debug */
	uint32_t indirect_ctrl;
	/*
	 * [0x38] M2S prefetch FIFO status.
	 * Status of the selected queue in M2S_indirect_ctrl
	 */
	uint32_t sel_pref_fifo_status;
	/*
	 * [0x3c] M2S completion FIFO status.
	 * Status of the selected queue in M2S_indirect_ctrl
	 */
	uint32_t sel_comp_fifo_status;
	/*
	 * [0x40] M2S rate limit status.
	 * Status of the selected queue in M2S_indirect_ctrl
	 */
	uint32_t sel_rate_limit_status;
	/*
	 * [0x44] M2S DWRR scheduler status.
	 * Status of the selected queue in M2S_indirect_ctrl
	 */
	uint32_t sel_dwrr_status;
	/* [0x48] M2S state machine and FIFO clear control */
	uint32_t clear_ctrl;
	/* [0x4c] Misc Check enable */
	uint32_t check_en;
	/* [0x50] M2S FIFO enable control, internal */
	uint32_t fifo_en;
	/* [0x54] M2S packet length configuration */
	uint32_t cfg_len;
	/* [0x58] Stream interface configuration */
	uint32_t stream_cfg;
	/* [0x5c] M2S FIFO enable control, internal */
	uint32_t pref_queue_en;
	/* [0x60] */
	uint32_t stream_cfg2;
	/* [0x64] */
	uint32_t rsrvd_2[39];
};

/**** state register ****/
/*
 * Completion control
 * Reset: 0x0         Access: RO
 */
#define UDMA_M2S_STATE_COMP_CTRL_MASK 0x00000003
#define UDMA_M2S_STATE_COMP_CTRL_SHIFT 0
/*
 * Stream interface
 * Reset: 0x0         Access: RO
 */
#define UDMA_M2S_STATE_STREAM_IF_MASK 0x00000030
#define UDMA_M2S_STATE_STREAM_IF_SHIFT 4
/*
 * Data read control
 * Reset: 0x0         Access: RO
 */
#define UDMA_M2S_STATE_DATA_RD_CTRL_MASK 0x00000300
#define UDMA_M2S_STATE_DATA_RD_CTRL_SHIFT 8
/*
 * Descriptor prefetch
 * Reset: 0x0         Access: RO
 */
#define UDMA_M2S_STATE_DESC_PREF_MASK 0x00003000
#define UDMA_M2S_STATE_DESC_PREF_SHIFT 12

/**** change_state register ****/
/*
 * Start normal operation
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_CHANGE_STATE_NORMAL (1 << 0)
#define UDMA_M2S_CHANGE_STATE_NORMAL_MASK 0x00000001
#define UDMA_M2S_CHANGE_STATE_NORMAL_SHIFT 0
/*
 * Stop normal operation
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_CHANGE_STATE_DIS    (1 << 1)
#define UDMA_M2S_CHANGE_STATE_DIS_MASK 0x00000002
#define UDMA_M2S_CHANGE_STATE_DIS_SHIFT 1
/*
 * Stop all machines.
 * (Prefetch, scheduling, completion and stream interface)
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_CHANGE_STATE_ABORT  (1 << 2)
#define UDMA_M2S_CHANGE_STATE_ABORT_MASK 0x00000004
#define UDMA_M2S_CHANGE_STATE_ABORT_SHIFT 2

/**** err_log_mask register ****/
/*
 * Mismatch of packet serial number.
 * (between first packet in the unacknowledged FIFO and received ack from the stream)
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_ERR_LOG_MASK_COMP_PKT_MISMATCH (1 << 0)
#define UDMA_M2S_ERR_LOG_MASK_COMP_PKT_MISMATCH_MASK 0x00000001
#define UDMA_M2S_ERR_LOG_MASK_COMP_PKT_MISMATCH_SHIFT 0
/*
 * Parity error
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_ERR_LOG_MASK_STREAM_AXI_PARITY (1 << 1)
#define UDMA_M2S_ERR_LOG_MASK_STREAM_AXI_PARITY_MASK 0x00000002
#define UDMA_M2S_ERR_LOG_MASK_STREAM_AXI_PARITY_SHIFT 1
/*
 * AXI response error
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_ERR_LOG_MASK_STREAM_AXI_RESPONSE (1 << 2)
#define UDMA_M2S_ERR_LOG_MASK_STREAM_AXI_RESPONSE_MASK 0x00000004
#define UDMA_M2S_ERR_LOG_MASK_STREAM_AXI_RESPONSE_SHIFT 2
/*
 * AXI timeout (ack not received)
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_ERR_LOG_MASK_STREAM_AXI_TOUT (1 << 3)
#define UDMA_M2S_ERR_LOG_MASK_STREAM_AXI_TOUT_MASK 0x00000008
#define UDMA_M2S_ERR_LOG_MASK_STREAM_AXI_TOUT_SHIFT 3
/*
 * Parity error
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_ERR_LOG_MASK_COMP_AXI_PARITY (1 << 4)
#define UDMA_M2S_ERR_LOG_MASK_COMP_AXI_PARITY_MASK 0x00000010
#define UDMA_M2S_ERR_LOG_MASK_COMP_AXI_PARITY_SHIFT 4
/*
 * AXI response error
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_ERR_LOG_MASK_COMP_AXI_RESPONSE (1 << 5)
#define UDMA_M2S_ERR_LOG_MASK_COMP_AXI_RESPONSE_MASK 0x00000020
#define UDMA_M2S_ERR_LOG_MASK_COMP_AXI_RESPONSE_SHIFT 5
/*
 * AXI timeout
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_ERR_LOG_MASK_COMP_AXI_TOUT (1 << 6)
#define UDMA_M2S_ERR_LOG_MASK_COMP_AXI_TOUT_MASK 0x00000040
#define UDMA_M2S_ERR_LOG_MASK_COMP_AXI_TOUT_SHIFT 6
/*
 * Parity error
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_ERR_LOG_MASK_DATA_AXI_PARITY (1 << 7)
#define UDMA_M2S_ERR_LOG_MASK_DATA_AXI_PARITY_MASK 0x00000080
#define UDMA_M2S_ERR_LOG_MASK_DATA_AXI_PARITY_SHIFT 7
/*
 * AXI response error
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_ERR_LOG_MASK_DATA_AXI_RESPONSE (1 << 8)
#define UDMA_M2S_ERR_LOG_MASK_DATA_AXI_RESPONSE_MASK 0x00000100
#define UDMA_M2S_ERR_LOG_MASK_DATA_AXI_RESPONSE_SHIFT 8
/*
 * AXI timeout
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_ERR_LOG_MASK_DATA_AXI_TOUT (1 << 9)
#define UDMA_M2S_ERR_LOG_MASK_DATA_AXI_TOUT_MASK 0x00000200
#define UDMA_M2S_ERR_LOG_MASK_DATA_AXI_TOUT_SHIFT 9
/*
 * Parity error
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_ERR_LOG_MASK_PREF_AXI_PARITY (1 << 10)
#define UDMA_M2S_ERR_LOG_MASK_PREF_AXI_PARITY_MASK 0x00000400
#define UDMA_M2S_ERR_LOG_MASK_PREF_AXI_PARITY_SHIFT 10
/*
 * AXI response error
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_ERR_LOG_MASK_PREF_AXI_RESPONSE (1 << 11)
#define UDMA_M2S_ERR_LOG_MASK_PREF_AXI_RESPONSE_MASK 0x00000800
#define UDMA_M2S_ERR_LOG_MASK_PREF_AXI_RESPONSE_SHIFT 11
/*
 * AXI timeout
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_ERR_LOG_MASK_PREF_AXI_TOUT (1 << 12)
#define UDMA_M2S_ERR_LOG_MASK_PREF_AXI_TOUT_MASK 0x00001000
#define UDMA_M2S_ERR_LOG_MASK_PREF_AXI_TOUT_SHIFT 12
/*
 * Packet length error
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_ERR_LOG_MASK_PREF_PKT_LEN_OVERFLOW (1 << 13)
#define UDMA_M2S_ERR_LOG_MASK_PREF_PKT_LEN_OVERFLOW_MASK 0x00002000
#define UDMA_M2S_ERR_LOG_MASK_PREF_PKT_LEN_OVERFLOW_SHIFT 13
/*
 * Maximum number of descriptors per packet error
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_ERR_LOG_MASK_PREF_MAX_DESC_CNT (1 << 14)
#define UDMA_M2S_ERR_LOG_MASK_PREF_MAX_DESC_CNT_MASK 0x00004000
#define UDMA_M2S_ERR_LOG_MASK_PREF_MAX_DESC_CNT_SHIFT 14
/*
 * Error in first bit indication of the descriptor
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_ERR_LOG_MASK_PREF_FIRST (1 << 15)
#define UDMA_M2S_ERR_LOG_MASK_PREF_FIRST_MASK 0x00008000
#define UDMA_M2S_ERR_LOG_MASK_PREF_FIRST_SHIFT 15
/*
 * Error in last bit indication of the descriptor
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_ERR_LOG_MASK_PREF_LAST (1 << 16)
#define UDMA_M2S_ERR_LOG_MASK_PREF_LAST_MASK 0x00010000
#define UDMA_M2S_ERR_LOG_MASK_PREF_LAST_SHIFT 16
/*
 * Ring_ID error
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_ERR_LOG_MASK_PREF_RING_ID (1 << 17)
#define UDMA_M2S_ERR_LOG_MASK_PREF_RING_ID_MASK 0x00020000
#define UDMA_M2S_ERR_LOG_MASK_PREF_RING_ID_SHIFT 17
/*
 * Data buffer parity error
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_ERR_LOG_MASK_DATA_BUFF_PARITY (1 << 18)
#define UDMA_M2S_ERR_LOG_MASK_DATA_BUFF_PARITY_MASK 0x00040000
#define UDMA_M2S_ERR_LOG_MASK_DATA_BUFF_PARITY_SHIFT 18
/*
 * Internal error
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_ERR_LOG_MASK_INTERNAL_MASK 0xFFF80000
#define UDMA_M2S_ERR_LOG_MASK_INTERNAL_SHIFT 19

/**** log_0 register ****/
/*
 * word_0
 * Reset: 0x0         Access: RO
 */
#define UDMA_M2S_LOG_0_HEADER_MASK   0xFFFFFFFF
#define UDMA_M2S_LOG_0_HEADER_SHIFT  0

/**** log_1 register ****/
/*
 * word_1
 * Reset: 0x0         Access: RO
 */
#define UDMA_M2S_LOG_1_HEADER_MASK   0xFFFFFFFF
#define UDMA_M2S_LOG_1_HEADER_SHIFT  0

/**** log_2 register ****/
/*
 * word_2
 * Reset: 0x0         Access: RO
 */
#define UDMA_M2S_LOG_2_HEADER_MASK   0xFFFFFFFF
#define UDMA_M2S_LOG_2_HEADER_SHIFT  0

/**** log_3 register ****/
/*
 * word_3
 * Reset: 0x0         Access: RO
 */
#define UDMA_M2S_LOG_3_HEADER_MASK   0xFFFFFFFF
#define UDMA_M2S_LOG_3_HEADER_SHIFT  0

/**** clear_err_log register ****/
/*
 * Clear error log
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_CLEAR_ERR_LOG_CLEAR (1 << 0)
#define UDMA_M2S_CLEAR_ERR_LOG_CLEAR_MASK 0x00000001
#define UDMA_M2S_CLEAR_ERR_LOG_CLEAR_SHIFT 0

/**** data_fifo_status register ****/
/*
 * FIFO used indication
 * Reset: 0x0         Access: RO
 */
#define UDMA_M2S_DATA_FIFO_STATUS_USED_MASK 0x0000FFFF
#define UDMA_M2S_DATA_FIFO_STATUS_USED_SHIFT 0
/*
 * FIFO empty indication
 * Reset: 0x0         Access: RO
 */
#define UDMA_M2S_DATA_FIFO_STATUS_EMPTY (1 << 24)
#define UDMA_M2S_DATA_FIFO_STATUS_EMPTY_MASK 0x01000000
#define UDMA_M2S_DATA_FIFO_STATUS_EMPTY_SHIFT 24
/*
 * FIFO full indication
 * Reset: 0x0         Access: RO
 */
#define UDMA_M2S_DATA_FIFO_STATUS_FULL (1 << 28)
#define UDMA_M2S_DATA_FIFO_STATUS_FULL_MASK 0x10000000
#define UDMA_M2S_DATA_FIFO_STATUS_FULL_SHIFT 28

/**** header_fifo_status register ****/
/*
 * FIFO used indication
 * Reset: 0x0         Access: RO
 */
#define UDMA_M2S_HEADER_FIFO_STATUS_USED_MASK 0x0000FFFF
#define UDMA_M2S_HEADER_FIFO_STATUS_USED_SHIFT 0
/*
 * FIFO empty indication
 * Reset: 0x0         Access: RO
 */
#define UDMA_M2S_HEADER_FIFO_STATUS_EMPTY (1 << 24)
#define UDMA_M2S_HEADER_FIFO_STATUS_EMPTY_MASK 0x01000000
#define UDMA_M2S_HEADER_FIFO_STATUS_EMPTY_SHIFT 24
/*
 * FIFO full indication
 * Reset: 0x0         Access: RO
 */
#define UDMA_M2S_HEADER_FIFO_STATUS_FULL (1 << 28)
#define UDMA_M2S_HEADER_FIFO_STATUS_FULL_MASK 0x10000000
#define UDMA_M2S_HEADER_FIFO_STATUS_FULL_SHIFT 28

/**** unack_fifo_status register ****/
/*
 * FIFO used indication
 * Reset: 0x0         Access: RO
 */
#define UDMA_M2S_UNACK_FIFO_STATUS_USED_MASK 0x0000FFFF
#define UDMA_M2S_UNACK_FIFO_STATUS_USED_SHIFT 0
/*
 * FIFO empty indication
 * Reset: 0x0         Access: RO
 */
#define UDMA_M2S_UNACK_FIFO_STATUS_EMPTY (1 << 24)
#define UDMA_M2S_UNACK_FIFO_STATUS_EMPTY_MASK 0x01000000
#define UDMA_M2S_UNACK_FIFO_STATUS_EMPTY_SHIFT 24
/*
 * FIFO full indication
 * Reset: 0x0         Access: RO
 */
#define UDMA_M2S_UNACK_FIFO_STATUS_FULL (1 << 28)
#define UDMA_M2S_UNACK_FIFO_STATUS_FULL_MASK 0x10000000
#define UDMA_M2S_UNACK_FIFO_STATUS_FULL_SHIFT 28

/**** indirect_ctrl register ****/
/*
 * Selected queue for status read
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_INDIRECT_CTRL_Q_NUM_MASK 0x00000FFF
#define UDMA_M2S_INDIRECT_CTRL_Q_NUM_SHIFT 0

/**** sel_pref_fifo_status register ****/
/*
 * FIFO used indication
 * Reset: 0x0         Access: RO
 */
#define UDMA_M2S_SEL_PREF_FIFO_STATUS_USED_MASK 0x0000FFFF
#define UDMA_M2S_SEL_PREF_FIFO_STATUS_USED_SHIFT 0
/*
 * FIFO empty indication
 * Reset: 0x0         Access: RO
 */
#define UDMA_M2S_SEL_PREF_FIFO_STATUS_EMPTY (1 << 24)
#define UDMA_M2S_SEL_PREF_FIFO_STATUS_EMPTY_MASK 0x01000000
#define UDMA_M2S_SEL_PREF_FIFO_STATUS_EMPTY_SHIFT 24
/*
 * FIFO full indication
 * Reset: 0x0         Access: RO
 */
#define UDMA_M2S_SEL_PREF_FIFO_STATUS_FULL (1 << 28)
#define UDMA_M2S_SEL_PREF_FIFO_STATUS_FULL_MASK 0x10000000
#define UDMA_M2S_SEL_PREF_FIFO_STATUS_FULL_SHIFT 28

/**** sel_comp_fifo_status register ****/
/*
 * FIFO used indication
 * Reset: 0x0         Access: RO
 */
#define UDMA_M2S_SEL_COMP_FIFO_STATUS_USED_MASK 0x0000FFFF
#define UDMA_M2S_SEL_COMP_FIFO_STATUS_USED_SHIFT 0
/*
 * FIFO empty indication
 * Reset: 0x0         Access: RO
 */
#define UDMA_M2S_SEL_COMP_FIFO_STATUS_EMPTY (1 << 24)
#define UDMA_M2S_SEL_COMP_FIFO_STATUS_EMPTY_MASK 0x01000000
#define UDMA_M2S_SEL_COMP_FIFO_STATUS_EMPTY_SHIFT 24
/*
 * FIFO full indication
 * Reset: 0x0         Access: RO
 */
#define UDMA_M2S_SEL_COMP_FIFO_STATUS_FULL (1 << 28)
#define UDMA_M2S_SEL_COMP_FIFO_STATUS_FULL_MASK 0x10000000
#define UDMA_M2S_SEL_COMP_FIFO_STATUS_FULL_SHIFT 28

/**** sel_rate_limit_status register ****/
/*
 * Token counter
 * Reset: 0x0         Access: RO
 */
#define UDMA_M2S_SEL_RATE_LIMIT_STATUS_TOKEN_CNT_MASK 0x00FFFFFF
#define UDMA_M2S_SEL_RATE_LIMIT_STATUS_TOKEN_CNT_SHIFT 0

/**** sel_dwrr_status register ****/
/*
 * Deficit counter
 * Reset: 0x0         Access: RO
 */
#define UDMA_M2S_SEL_DWRR_STATUS_DEFICIT_CNT_MASK 0x00FFFFFF
#define UDMA_M2S_SEL_DWRR_STATUS_DEFICIT_CNT_SHIFT 0

/**** clear_ctrl register ****/
/*
 * Emergency clear for selected machines.
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_CLEAR_CTRL_RESERVED_31_0_MASK 0xFFFFFFFF
#define UDMA_M2S_CLEAR_CTRL_RESERVED_31_0_SHIFT 0

/**** check_en register ****/
/* Reset: 0x0         Access: RW */
#define UDMA_M2S_CHECK_EN_EN_MASK    0xFFFFFFFF
#define UDMA_M2S_CHECK_EN_EN_SHIFT   0

/**** fifo_en register ****/
/* Reset: 0xffffffff  Access: RW */
#define UDMA_M2S_FIFO_EN_EN_MASK     0xFFFFFFFF
#define UDMA_M2S_FIFO_EN_EN_SHIFT    0

/**** cfg_len register ****/
/*
 * Maximum packet size for the M2S
 * Reset: 0x10000     Access: RW
 */
#define UDMA_M2S_CFG_LEN_MAX_PKT_SIZE_MASK 0x000FFFFF
#define UDMA_M2S_CFG_LEN_MAX_PKT_SIZE_SHIFT 0
/*
 * Length encoding for 64K.
 * 0 - length 0x0000 = 0
 * 1 - length 0x0000 = 64k
 * Reset: 0x1         Access: RW
 */
#define UDMA_M2S_CFG_LEN_ENCODE_64K  (1 << 24)
#define UDMA_M2S_CFG_LEN_ENCODE_64K_MASK 0x01000000
#define UDMA_M2S_CFG_LEN_ENCODE_64K_SHIFT 24

/**** stream_cfg register ****/
/*
 * Disables the stream interface operation.
 * Changing to 1 stops at the end of packet transmission.
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_STREAM_CFG_DISABLE_STREAM (1 << 0)
#define UDMA_M2S_STREAM_CFG_DISABLE_STREAM_MASK 0x00000001
#define UDMA_M2S_STREAM_CFG_DISABLE_STREAM_SHIFT 0
/*
 * Configuration of the stream FIFO read control.
 * 0 - Cut through
 * 1 - Threshold based
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_STREAM_CFG_RD_MODE  (1 << 1)
#define UDMA_M2S_STREAM_CFG_RD_MODE_MASK 0x00000002
#define UDMA_M2S_STREAM_CFG_RD_MODE_SHIFT 1
/*
 * Minimum number of beats to start packet transmission.
 * Reset: 0x1         Access: RW
 */
#define UDMA_M2S_STREAM_CFG_RD_TH_MASK 0x0007FF00
#define UDMA_M2S_STREAM_CFG_RD_TH_SHIFT 8

/**** pref_queue_en register ****/
/*
 * prefetech descriptors and data read
 * Reset: 0xffff      Access: RW
 */
#define UDMA_M2S_PREF_QUEUE_EN_EN_MASK 0x0000FFFF
#define UDMA_M2S_PREF_QUEUE_EN_EN_SHIFT 0

/**** stream_cfg2 register ****/
/*
 * When set UDMA mask data over current stream byte cnt to 0, this means if we would like to send on
 * stream 19 bytes, the rest 13 bytes of data will be zereos
 * Reset: 0x1         Access: RW
 */
#define UDMA_M2S_STREAM_CFG2_MASK_DATA_OVER_BCNT (1 << 0)
#define UDMA_M2S_STREAM_CFG2_MASK_DATA_OVER_BCNT_MASK 0x00000001
#define UDMA_M2S_STREAM_CFG2_MASK_DATA_OVER_BCNT_SHIFT 0
/*
 * A new feature was added that reflect tx axi read response error that occurred to relevant packet.
 * On default this error will propagate thorough axis_err, on relevant packet.
 * This enabled to mask this indication.
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_STREAM_CFG2_MASK_AXI_RESP_ERR (1 << 1)
#define UDMA_M2S_STREAM_CFG2_MASK_AXI_RESP_ERR_MASK 0x00000002
#define UDMA_M2S_STREAM_CFG2_MASK_AXI_RESP_ERR_SHIFT 1

/**************************************************************************************************
 * udma_m2s_rd
 *
 * M2S descriptor and data read  configuration
 **************************************************************************************************/
struct udma_m2s_rd {
	/* [0x0] M2S descriptor prefetch configuration */
	uint32_t desc_pref_cfg_1;
	/* [0x4] M2S descriptor prefetch configuration */
	uint32_t desc_pref_cfg_2;
	/* [0x8] M2S descriptor prefetch configuration */
	uint32_t desc_pref_cfg_3;
	/* [0xc] */
	uint32_t rsrvd_0;
	/* [0x10] Data burst read configuration */
	uint32_t data_cfg;
	/* [0x14] */
	uint32_t rsrvd_1[11];
};

/**** desc_pref_cfg_1 register ****/
/* Reset: 0x0         Access: RW */
#define UDMA_M2S_RD_DESC_PREF_CFG_1_RESERVED_31_0_MASK 0xFFFFFFFF
#define UDMA_M2S_RD_DESC_PREF_CFG_1_RESERVED_31_0_SHIFT 0

/**** desc_pref_cfg_2 register ****/
/*
 * Maximum number of descriptors per packet
 * Reset: 0x40        Access: RW
 */
#define UDMA_M2S_RD_DESC_PREF_CFG_2_MAX_DESC_PER_PKT_MASK 0x00000FFF
#define UDMA_M2S_RD_DESC_PREF_CFG_2_MAX_DESC_PER_PKT_SHIFT 0
/*
 * Force RR arbitration in the prefetch arbiter and packet scheduler(post rate control).
 * 0 -Standard arbitration based on queue QoS
 * 1 - Force Round Robin arbitration
 * Reset: 0x1         Access: RW
 */
#define UDMA_M2S_RD_DESC_PREF_CFG_2_PREF_FORCE_RR (1 << 16)
#define UDMA_M2S_RD_DESC_PREF_CFG_2_PREF_FORCE_RR_MASK 0x00010000
#define UDMA_M2S_RD_DESC_PREF_CFG_2_PREF_FORCE_RR_SHIFT 16

/**** desc_pref_cfg_3 register ****/
/*
 * Minimum descriptor burst size when prefetch FIFO level is below the descriptor prefetch threshold
 * (must be 1)
 * Reset: 0x1         Access: RW
 */
#define UDMA_M2S_RD_DESC_PREF_CFG_3_MIN_BURST_BELOW_THR_MASK 0x0000000F
#define UDMA_M2S_RD_DESC_PREF_CFG_3_MIN_BURST_BELOW_THR_SHIFT 0
/*
 * Minimum descriptor burst size when prefetch FIFO level is above the descriptor prefetch threshold
 * Reset: 0x4         Access: RW
 */
#define UDMA_M2S_RD_DESC_PREF_CFG_3_MIN_BURST_ABOVE_THR_MASK 0x000000F0
#define UDMA_M2S_RD_DESC_PREF_CFG_3_MIN_BURST_ABOVE_THR_SHIFT 4
/*
 * Descriptor fetch threshold.
 * Used as a threshold to determine the allowed minimum descriptor burst size.
 * (Must be at least max_desc_per_pkt)
 * Reset: 0x10        Access: RW
 */
#define UDMA_M2S_RD_DESC_PREF_CFG_3_PREF_THR_MASK 0x0000FF00
#define UDMA_M2S_RD_DESC_PREF_CFG_3_PREF_THR_SHIFT 8

/**** data_cfg register ****/
/*
 * Maximum number of data beats in the data read FIFO.
 * Defined based on data FIFO size
 * (default FIFO size 16KB  512 beats)
 * Reset: 0x200       Access: RW
 */
#define UDMA_M2S_RD_DATA_CFG_DATA_FIFO_DEPTH_MASK 0x00000FFF
#define UDMA_M2S_RD_DATA_CFG_DATA_FIFO_DEPTH_SHIFT 0
/*
 * Maximum number of packets in the data read FIFO.
 * Defined based on header FIFO size
 * Reset: 0x100       Access: RW
 */
#define UDMA_M2S_RD_DATA_CFG_MAX_PKT_LIMIT_MASK 0x0FFF0000
#define UDMA_M2S_RD_DATA_CFG_MAX_PKT_LIMIT_SHIFT 16

/**************************************************************************************************
 * udma_m2s_dwrr
 *
 * M2S DWRR scheduler configuration
 **************************************************************************************************/
struct udma_m2s_dwrr {
	/* [0x0] Tx DMA DWRR scheduler configuration */
	uint32_t cfg_sched;
	/* [0x4] Token bucket rate limit control */
	uint32_t ctrl_deficit_cnt;
	/* [0x8] */
	uint32_t rsrvd_0[14];
};

/**** cfg_sched register ****/
/*
 * Enable the DWRR scheduler.
 * If this bit is 0, queues with same QoS will be served with RR scheduler.
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_DWRR_CFG_SCHED_EN_DWRR (1 << 0)
#define UDMA_M2S_DWRR_CFG_SCHED_EN_DWRR_MASK 0x00000001
#define UDMA_M2S_DWRR_CFG_SCHED_EN_DWRR_SHIFT 0
/*
 * Scheduler operation mode.
 * 0 - Byte mode
 * 1 - Packet mode
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_DWRR_CFG_SCHED_PKT_MODE_EN (1 << 4)
#define UDMA_M2S_DWRR_CFG_SCHED_PKT_MODE_EN_MASK 0x00000010
#define UDMA_M2S_DWRR_CFG_SCHED_PKT_MODE_EN_SHIFT 4
/*
 * Enable incrementing the weight factor between DWRR iterations.
 * 00 - Don't increase the increment factor.
 * 01 - Increment once
 * 10 - Increment exponential
 * 11 - Reserved
 * Reset: 0x2         Access: RW
 */
#define UDMA_M2S_DWRR_CFG_SCHED_WEIGHT_INC_MASK 0x00000300
#define UDMA_M2S_DWRR_CFG_SCHED_WEIGHT_INC_SHIFT 8
/*
 * Increment factor power of 2.
 * 7 --> 128 bytes
 * This is the factor used to multiply the weight.
 * Reset: 0x7         Access: RW
 */
#define UDMA_M2S_DWRR_CFG_SCHED_INC_FACTOR_MASK 0x000F0000
#define UDMA_M2S_DWRR_CFG_SCHED_INC_FACTOR_SHIFT 16

/**** ctrl_deficit_cnt register ****/
/*
 * Init value for the deficit counter.
 * Initializes the deficit counters of all queues to this value any time this register is written.
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_DWRR_CTRL_DEFICIT_CNT_INIT_MASK 0x00FFFFFF
#define UDMA_M2S_DWRR_CTRL_DEFICIT_CNT_INIT_SHIFT 0

/**************************************************************************************************
 * udma_m2s_rate_limiter
 *
 * M2S rate limiter configuration
 **************************************************************************************************/
struct udma_m2s_rate_limiter {
	/* [0x0] Token bucket rate limit configuration */
	uint32_t gen_cfg;
	/*
	 * [0x4] Token bucket rate limit control.
	 * Controls the cycle counters.
	 */
	uint32_t ctrl_cycle_cnt;
	/*
	 * [0x8] Token bucket rate limit control.
	 * Controls the token bucket counter.
	 */
	uint32_t ctrl_token;
	/* [0xc] */
	uint32_t rsrvd_0[13];
};

/**** gen_cfg register ****/
/*
 * Size of the basic token fill cycle, system clock cycles
 * Reset: 0xfa        Access: RW
 */
#define UDMA_M2S_RATE_LIMITER_GEN_CFG_SHORT_CYCLE_SIZE_MASK 0x0000FFFF
#define UDMA_M2S_RATE_LIMITER_GEN_CFG_SHORT_CYCLE_SIZE_SHIFT 0
/*
 * Rate limiter operation mode.
 * 0 - Byte mode
 * 1 - Packet mode
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_RATE_LIMITER_GEN_CFG_PKT_MODE_EN (1 << 24)
#define UDMA_M2S_RATE_LIMITER_GEN_CFG_PKT_MODE_EN_MASK 0x01000000
#define UDMA_M2S_RATE_LIMITER_GEN_CFG_PKT_MODE_EN_SHIFT 24

/**** ctrl_cycle_cnt register ****/
/*
 * Reset the short and long cycle counters.
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_RATE_LIMITER_CTRL_CYCLE_CNT_RST (1 << 0)
#define UDMA_M2S_RATE_LIMITER_CTRL_CYCLE_CNT_RST_MASK 0x00000001
#define UDMA_M2S_RATE_LIMITER_CTRL_CYCLE_CNT_RST_SHIFT 0

/**** ctrl_token register ****/
/*
 * Init value for the token counter.
 * Initializes the token counters of all queues to this value any time this register is written.
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_RATE_LIMITER_CTRL_TOKEN_RST_MASK 0x00FFFFFF
#define UDMA_M2S_RATE_LIMITER_CTRL_TOKEN_RST_SHIFT 0

/**************************************************************************************************
 * udma_m2s_stream_rate_limiter
 *
 * M2S rate limiter configuration
 **************************************************************************************************/
struct udma_m2s_stream_rate_limiter {
	/* [0x0] Token bucket configuration */
	uint32_t cfg_1s;
	/* [0x4] Token bucket rate limit configuration */
	uint32_t cfg_cycle;
	/* [0x8] Token bucket rate limit configuration */
	uint32_t cfg_token_size_1;
	/* [0xc] Token bucket rate limit configuration */
	uint32_t cfg_token_size_2;
	/* [0x10] Token bucket rate limit configuration */
	uint32_t sw_ctrl;
	/*
	 * [0x14] Mask the different types of rate limiter.
	 * 0 - Rate limit is active.
	 * 1 - Rate limit is masked.
	 */
	uint32_t mask;
	/* [0x18] */
	uint32_t rsrvd_0[10];
};

/**** cfg_1s register ****/
/*
 * Maximum number of accumulated bytes in the token counter
 * Reset: 0xffffff    Access: RW
 */
#define UDMA_M2S_STREAM_RATE_LIMITER_CFG_1S_MAX_BURST_SIZE_MASK 0x00FFFFFF
#define UDMA_M2S_STREAM_RATE_LIMITER_CFG_1S_MAX_BURST_SIZE_SHIFT 0
/*
 * Enable the rate limiter.
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_STREAM_RATE_LIMITER_CFG_1S_EN (1 << 24)
#define UDMA_M2S_STREAM_RATE_LIMITER_CFG_1S_EN_MASK 0x01000000
#define UDMA_M2S_STREAM_RATE_LIMITER_CFG_1S_EN_SHIFT 24
/*
 * Stop token fill.
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_STREAM_RATE_LIMITER_CFG_1S_PAUSE (1 << 25)
#define UDMA_M2S_STREAM_RATE_LIMITER_CFG_1S_PAUSE_MASK 0x02000000
#define UDMA_M2S_STREAM_RATE_LIMITER_CFG_1S_PAUSE_SHIFT 25

/**** cfg_cycle register ****/
/*
 * Number of short cycles between token fills
 * Reset: 0x1         Access: RW
 */
#define UDMA_M2S_STREAM_RATE_LIMITER_CFG_CYCLE_LONG_CYCLE_SIZE_MASK 0x0000FFFF
#define UDMA_M2S_STREAM_RATE_LIMITER_CFG_CYCLE_LONG_CYCLE_SIZE_SHIFT 0

/**** cfg_token_size_1 register ****/
/*
 * Number of bits to add in each long cycle
 * Reset: 0xffff      Access: RW
 */
#define UDMA_M2S_STREAM_RATE_LIMITER_CFG_TOKEN_SIZE_1_LONG_CYCLE_MASK 0x0007FFFF
#define UDMA_M2S_STREAM_RATE_LIMITER_CFG_TOKEN_SIZE_1_LONG_CYCLE_SHIFT 0

/**** cfg_token_size_2 register ****/
/*
 * Number of bits to add in each short cycle
 * Reset: 0xffff      Access: RW
 */
#define UDMA_M2S_STREAM_RATE_LIMITER_CFG_TOKEN_SIZE_2_SHORT_CYCLE_MASK 0x0007FFFF
#define UDMA_M2S_STREAM_RATE_LIMITER_CFG_TOKEN_SIZE_2_SHORT_CYCLE_SHIFT 0

/**** sw_ctrl register ****/
/*
 * Reset the token bucket counter.
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_STREAM_RATE_LIMITER_SW_CTRL_RST_TOKEN_CNT (1 << 0)
#define UDMA_M2S_STREAM_RATE_LIMITER_SW_CTRL_RST_TOKEN_CNT_MASK 0x00000001
#define UDMA_M2S_STREAM_RATE_LIMITER_SW_CTRL_RST_TOKEN_CNT_SHIFT 0

/**** mask register ****/
/*
 * Mask the external rate limiter.
 * Reset: 0x1         Access: RW
 */
#define UDMA_M2S_STREAM_RATE_LIMITER_MASK_EXTERNAL_RATE_LIMITER (1 << 0)
#define UDMA_M2S_STREAM_RATE_LIMITER_MASK_EXTERNAL_RATE_LIMITER_MASK 0x00000001
#define UDMA_M2S_STREAM_RATE_LIMITER_MASK_EXTERNAL_RATE_LIMITER_SHIFT 0
/*
 * Mask the internal rate limiter.
 * Reset: 0x1         Access: RW
 */
#define UDMA_M2S_STREAM_RATE_LIMITER_MASK_INTERNAL_RATE_LIMITER (1 << 1)
#define UDMA_M2S_STREAM_RATE_LIMITER_MASK_INTERNAL_RATE_LIMITER_MASK 0x00000002
#define UDMA_M2S_STREAM_RATE_LIMITER_MASK_INTERNAL_RATE_LIMITER_SHIFT 1
/*
 * Mask the external application pause interface.
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_STREAM_RATE_LIMITER_MASK_EXTERNAL_PAUSE (1 << 3)
#define UDMA_M2S_STREAM_RATE_LIMITER_MASK_EXTERNAL_PAUSE_MASK 0x00000008
#define UDMA_M2S_STREAM_RATE_LIMITER_MASK_EXTERNAL_PAUSE_SHIFT 3

/**************************************************************************************************
 * udma_m2s_comp
 *
 * M2S completion control configuration
 **************************************************************************************************/
struct udma_m2s_comp {
	/* [0x0] Completion controller configuration */
	uint32_t cfg_1c;
	/* [0x4] Completion controller coalescing configuration */
	uint32_t cfg_coal;
	/* [0x8] Completion controller application acknowledge configuration */
	uint32_t cfg_application_ack;
	/* [0xc] */
	uint32_t cfg_application_ack2;
	/* [0x10] */
	uint32_t rsrvd_0[60];
};

/**** cfg_1c register ****/
/*
 * Completion FIFO size
 *  (descriptors per queue)
 * Reset: 0x40        Access: RW
 */
#define UDMA_M2S_COMP_CFG_1C_COMP_FIFO_DEPTH_MASK 0x000000FF
#define UDMA_M2S_COMP_CFG_1C_COMP_FIFO_DEPTH_SHIFT 0
/*
 * Unacknowledged FIFO size.
 * (descriptors)
 * Reset: 0x100       Access: RW
 */
#define UDMA_M2S_COMP_CFG_1C_UNACK_FIFO_DEPTH_MASK 0x000FFF00
#define UDMA_M2S_COMP_CFG_1C_UNACK_FIFO_DEPTH_SHIFT 8
/*
 * Enable promotion.
 * Enable the promotion of the current queue in progress for the completion write scheduler.
 * Reset: 0x1         Access: RW
 */
#define UDMA_M2S_COMP_CFG_1C_Q_PROMOTION (1 << 24)
#define UDMA_M2S_COMP_CFG_1C_Q_PROMOTION_MASK 0x01000000
#define UDMA_M2S_COMP_CFG_1C_Q_PROMOTION_SHIFT 24
/*
 * Force RR arbitration in the completion arbiter
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_COMP_CFG_1C_FORCE_RR (1 << 25)
#define UDMA_M2S_COMP_CFG_1C_FORCE_RR_MASK 0x02000000
#define UDMA_M2S_COMP_CFG_1C_FORCE_RR_SHIFT 25
/*
 * Minimum number of free completion entries to qualify for promotion
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_COMP_CFG_1C_Q_FREE_MIN_MASK 0xF0000000
#define UDMA_M2S_COMP_CFG_1C_Q_FREE_MIN_SHIFT 28

/**** cfg_coal register ****/
/*
 * Completion coalescing timer.
 * Same timer value for all queues. Each queue has its own timer.
 * Reset: 0x186a0     Access: RW
 */
#define UDMA_M2S_COMP_CFG_COAL_TIMER_MASK 0xFFFFFFFF
#define UDMA_M2S_COMP_CFG_COAL_TIMER_SHIFT 0

/**** cfg_application_ack register ****/
/*
 * Acknowledge timeout timer.
 * ACK from the application through the stream interface)
 * Reset: 0x186a0     Access: RW
 */
#define UDMA_M2S_COMP_CFG_APPLICATION_ACK_TOUT_MASK 0x00FFFFFF
#define UDMA_M2S_COMP_CFG_APPLICATION_ACK_TOUT_SHIFT 0

/**** cfg_application_ack2 register ****/
/*
 * When set this mask the ERR bit indication from APP (Tdata) that goes o M2S CMPL (V3 mode) The is
 * new for Toprock to be Backward Compatiable this bit should be set to 1
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_COMP_CFG_APPLICATION_ACK2_MASK_ERR_INDICATION_DATA (1 << 0)
#define UDMA_M2S_COMP_CFG_APPLICATION_ACK2_MASK_ERR_INDICATION_DATA_MASK 0x00000001
#define UDMA_M2S_COMP_CFG_APPLICATION_ACK2_MASK_ERR_INDICATION_DATA_SHIFT 0
/*
 * When set this mask the ERR bit indication from APP (Tuser) that goes o M2S CMPL (V3 mode) The is
 * new for Toprock to be Backward Compatiable this bit should be set to 1
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_COMP_CFG_APPLICATION_ACK2_MASK_ERR_INDICATION_TUSER (1 << 1)
#define UDMA_M2S_COMP_CFG_APPLICATION_ACK2_MASK_ERR_INDICATION_TUSER_MASK 0x00000002
#define UDMA_M2S_COMP_CFG_APPLICATION_ACK2_MASK_ERR_INDICATION_TUSER_SHIFT 1
/*
 * This filed tells the UDMA where to look for the error bit from application inside the ACK
 * receivng from Application
 * Reset: 0x1e        Access: RW
 */
#define UDMA_M2S_COMP_CFG_APPLICATION_ACK2_ERR_INDICATION_DATA_OFFSET_MASK 0x0000007C
#define UDMA_M2S_COMP_CFG_APPLICATION_ACK2_ERR_INDICATION_DATA_OFFSET_SHIFT 2

/**************************************************************************************************
 * udma_m2s_stat
 *
 * M2S statistics
 **************************************************************************************************/
struct udma_m2s_stat {
	/* [0x0] Statistics counters configuration */
	uint32_t cfg_st;
	/* [0x4] Counting number of descriptors with First-bit set. */
	uint32_t tx_pkt;
	/*
	 * [0x8] Counting the net length of the data buffers [64-bit]
	 * Should be read before tx_bytes_high
	 */
	uint32_t tx_bytes_low;
	/*
	 * [0xc] Counting the net length of the data buffers [64-bit],
	 * Should be read after  tx_bytes_low (value is sampled when reading Should be read before
	 * tx_bytes_low
	 */
	uint32_t tx_bytes_high;
	/* [0x10] Total number of descriptors read from the host memory */
	uint32_t prefed_desc;
	/* [0x14] Number of packets read from the unack FIFO */
	uint32_t comp_pkt;
	/* [0x18] Number of descriptors written into the completion ring */
	uint32_t comp_desc;
	/*
	 * [0x1c] Number of acknowledged packets.
	 * (acknowledge received from the stream interface)
	 */
	uint32_t ack_pkts;
	/* [0x20] */
	uint32_t rsrvd_0[56];
};

/**** cfg_st register ****/
/*
 * Use additional length value for all statistics counters.
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_STAT_CFG_ST_USE_EXTRA_LEN (1 << 0)
#define UDMA_M2S_STAT_CFG_ST_USE_EXTRA_LEN_MASK 0x00000001
#define UDMA_M2S_STAT_CFG_ST_USE_EXTRA_LEN_SHIFT 0

/**** tx_pkt register ****/
/*
 * Counting number of descriptors with First-bit set.
 * Reset: 0x0         Access: RO, RtoClr
 */
#define UDMA_M2S_STAT_TX_PKT_CNT_MASK 0xFFFFFFFF
#define UDMA_M2S_STAT_TX_PKT_CNT_SHIFT 0

/**** tx_bytes_low register ****/
/*
 * Counter bits [31:0]
 * Reset: 0x0         Access: RO, RtoClr
 */
#define UDMA_M2S_STAT_TX_BYTES_LOW_CNT_MASK 0xFFFFFFFF
#define UDMA_M2S_STAT_TX_BYTES_LOW_CNT_SHIFT 0

/**** tx_bytes_high register ****/
/*
 * Counter bits [63:32]
 * Reset: 0x0         Access: RO, RtoClr
 */
#define UDMA_M2S_STAT_TX_BYTES_HIGH_CNT_MASK 0xFFFFFFFF
#define UDMA_M2S_STAT_TX_BYTES_HIGH_CNT_SHIFT 0

/**** prefed_desc register ****/
/*
 * Total number of descriptors read from the host memory
 * Reset: 0x0         Access: RO, RtoClr
 */
#define UDMA_M2S_STAT_PREFED_DESC_CNT_MASK 0xFFFFFFFF
#define UDMA_M2S_STAT_PREFED_DESC_CNT_SHIFT 0

/**** comp_pkt register ****/
/*
 * Number of packets read from the unack FIFO
 * Reset: 0x0         Access: RO, RtoClr
 */
#define UDMA_M2S_STAT_COMP_PKT_CNT_MASK 0xFFFFFFFF
#define UDMA_M2S_STAT_COMP_PKT_CNT_SHIFT 0

/**** comp_desc register ****/
/*
 * Number of descriptors written into the completion ring
 * Reset: 0x0         Access: RO, RtoClr
 */
#define UDMA_M2S_STAT_COMP_DESC_CNT_MASK 0xFFFFFFFF
#define UDMA_M2S_STAT_COMP_DESC_CNT_SHIFT 0

/**** ack_pkts register ****/
/*
 * Number of acknowledged packets.
 * (acknowledge received from the stream interface)
 * Reset: 0x0         Access: RO, RtoClr
 */
#define UDMA_M2S_STAT_ACK_PKTS_CNT_MASK 0xFFFFFFFF
#define UDMA_M2S_STAT_ACK_PKTS_CNT_SHIFT 0

/**************************************************************************************************
 * udma_m2s_feature
 *
 * M2S Feature registers
 **************************************************************************************************/
struct udma_m2s_feature {
	/*
	 * [0x0] M2S Feature register.
	 * M2S instantiation parameters
	 */
	uint32_t reg_1;
	/*
	 * [0x4] DMA version -
	 * Value 0 - rev A0/Slickrock/Peakrock
	 * Value 4 - Toprock
	 * Value 5 - Alpha (Include all Torpock changes)
	 * Value 6 - Skyrock (Included all Toprrock and Alpha changes)
	 * Value 7 - Batcave (will be later on AL9/10)
	 */
	uint32_t dma_version;
	/*
	 * [0x8] M2S Feature register.
	 * M2S instantiation parameters
	 */
	uint32_t reg_3;
	/*
	 * [0xc] M2S Feature register.
	 * M2S instantiation parameters
	 */
	uint32_t reg_4;
	/*
	 * [0x10] M2S Feature register.
	 * M2S instantiation parameters
	 */
	uint32_t reg_5;
	/* [0x14] Reserved M2S feature register */
	uint32_t reg_6;
	/* [0x18] */
	uint32_t rsrvd_0[58];
};

/**** reg_1 register ****/
/*
 * Read the size of the descriptor prefetch FIFO
 * (descriptors).
 * Reset: 0x400       Access: RW, WInit
 */
#define UDMA_M2S_FEATURE_REG_1_DESC_PREFERCH_FIFO_DEPTH_MASK 0x00000FFF
#define UDMA_M2S_FEATURE_REG_1_DESC_PREFERCH_FIFO_DEPTH_SHIFT 0

/**** dma_version register ****/
/* Reset: 0x7         Access: RW */
#define UDMA_M2S_FEATURE_DMA_VERSION_VERSION_MASK 0xFFFFFFFF
#define UDMA_M2S_FEATURE_DMA_VERSION_VERSION_SHIFT 0

/**** reg_3 register ****/
/*
 * Maximum number of data beats in the data read FIFO.
 * Defined based on data FIFO size
 * (default FIFO size 16KB  512 beats)
 * Reset: 0x200       Access: RW, WInit
 */
#define UDMA_M2S_FEATURE_REG_3_DATA_FIFO_DEPTH_MASK 0x00000FFF
#define UDMA_M2S_FEATURE_REG_3_DATA_FIFO_DEPTH_SHIFT 0
/*
 * Maximum number of packets in the data read FIFO.
 * Defined based on header FIFO size
 * Reset: 0x100       Access: RW, WInit
 */
#define UDMA_M2S_FEATURE_REG_3_DATA_RD_MAX_PKT_LIMIT_MASK 0x0FFF0000
#define UDMA_M2S_FEATURE_REG_3_DATA_RD_MAX_PKT_LIMIT_SHIFT 16

/**** reg_4 register ****/
/*
 * Size of the completion FIFO of each queue
 * (words)
 * Reset: 0x40        Access: RW, WInit
 */
#define UDMA_M2S_FEATURE_REG_4_COMP_FIFO_DEPTH_MASK 0x000000FF
#define UDMA_M2S_FEATURE_REG_4_COMP_FIFO_DEPTH_SHIFT 0
/*
 * Size of the unacknowledged FIFO (descriptors)
 * Reset: 0x100       Access: RW, WInit
 */
#define UDMA_M2S_FEATURE_REG_4_COMP_UNACK_FIFO_DEPTH_MASK 0x000FFF00
#define UDMA_M2S_FEATURE_REG_4_COMP_UNACK_FIFO_DEPTH_SHIFT 8

/**** reg_5 register ****/
/*
 * Maximum number of outstanding data reads to AXI
 * Reset: 0x40        Access: RW, WInit
 */
#define UDMA_M2S_FEATURE_REG_5_MAX_DATA_RD_OSTAND_MASK 0x000000FF
#define UDMA_M2S_FEATURE_REG_5_MAX_DATA_RD_OSTAND_SHIFT 0
/*
 * Maximum number of outstanding descriptor reads to AXI
 * Reset: 0x20        Access: RW, WInit
 */
#define UDMA_M2S_FEATURE_REG_5_MAX_DESC_RD_OSTAND_MASK 0x0000FF00
#define UDMA_M2S_FEATURE_REG_5_MAX_DESC_RD_OSTAND_SHIFT 8
/*
 * Maximum number of outstanding descriptor writes to AXI.
 * (AXI transactions)
 * Reset: 0x20        Access: RW, WInit
 */
#define UDMA_M2S_FEATURE_REG_5_MAX_COMP_REQ_MASK 0x00FF0000
#define UDMA_M2S_FEATURE_REG_5_MAX_COMP_REQ_SHIFT 16
/*
 * Maximum number of outstanding data beats for descriptor write to AXI.
 * (AXI beats)
 * Reset: 0x20        Access: RW, WInit
 */
#define UDMA_M2S_FEATURE_REG_5_MAX_COMP_DATA_WR_OSTAND_MASK 0xFF000000
#define UDMA_M2S_FEATURE_REG_5_MAX_COMP_DATA_WR_OSTAND_SHIFT 24

/**** reg_6 register ****/
/* Reset: 0x0         Access: RW */
#define UDMA_M2S_FEATURE_REG_6_RESERVED_31_0_MASK 0xFFFFFFFF
#define UDMA_M2S_FEATURE_REG_6_RESERVED_31_0_SHIFT 0

/**************************************************************************************************
 * udma_m2s_shadow_access_shadow_index
 **************************************************************************************************/
struct udma_m2s_shadow_access_shadow_index {
	/* [0x0] */
	uint32_t rd_permission;
	/* [0x4] */
	uint32_t wr_permission;
};

/**** rd_permission register ****/
/* Reset: 0x0         Access: RW */
#define UDMA_M2S_SHADOW_ACCESS_SHADOW_INDEX_RD_PERMISSION_DATA_MASK 0xFFFFFFFF
#define UDMA_M2S_SHADOW_ACCESS_SHADOW_INDEX_RD_PERMISSION_DATA_SHIFT 0

/**** wr_permission register ****/
/* Reset: 0x0         Access: RW */
#define UDMA_M2S_SHADOW_ACCESS_SHADOW_INDEX_WR_PERMISSION_DATA_MASK 0xFFFFFFFF
#define UDMA_M2S_SHADOW_ACCESS_SHADOW_INDEX_WR_PERMISSION_DATA_SHIFT 0

/**************************************************************************************************
 * udma_m2s_shadow_access
 **************************************************************************************************/
struct udma_m2s_shadow_access {
	/* [0x0] */
	struct udma_m2s_shadow_access_shadow_index shadow_index[32];
};

/**************************************************************************************************
 * udma_m2s_q_reflect
 *
 * Reflect status ctrl
 **************************************************************************************************/
struct udma_m2s_q_reflect {
	/* [0x0] Reflect Head value to dram Pointer [63:32] */
	uint32_t addr_high;
	/* [0x4] Reflect Head value to dram Pointer [31:0] */
	uint32_t addr_low;
	/* [0x8] General ctrl */
	uint32_t ctrl;
	/* [0xc] Per Q mask for app status */
	uint32_t app_status_mask;
};

/**** addr_high register ****/
/* Reset: 0x0         Access: RW */
#define UDMA_M2S_Q_REFLECT_ADDR_HIGH_VAL_MASK 0xFFFFFFFF
#define UDMA_M2S_Q_REFLECT_ADDR_HIGH_VAL_SHIFT 0

/**** addr_low register ****/
/* Reset: 0x0         Access: RW */
#define UDMA_M2S_Q_REFLECT_ADDR_LOW_VAL_MASK 0xFFFFFFFF
#define UDMA_M2S_Q_REFLECT_ADDR_LOW_VAL_SHIFT 0

/**** ctrl register ****/
/*
 * Reflect enable
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_Q_REFLECT_CTRL_EN   (1 << 0)
#define UDMA_M2S_Q_REFLECT_CTRL_EN_MASK 0x00000001
#define UDMA_M2S_Q_REFLECT_CTRL_EN_SHIFT 0
/*
 * First update promotion enable
 * Reset: 0x1         Access: RW
 */
#define UDMA_M2S_Q_REFLECT_CTRL_PROMO_EN (1 << 1)
#define UDMA_M2S_Q_REFLECT_CTRL_PROMO_EN_MASK 0x00000002
#define UDMA_M2S_Q_REFLECT_CTRL_PROMO_EN_SHIFT 1
/*
 * When current head ptr bigger then last update ptr with the rx_max_th  a cache update will be
 * issued even if didn't arrive to timeout (th allow by passing timer - depend if priority is enabled
 * )
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_Q_REFLECT_CTRL_RX_MAX_TH_MASK 0x0000FF00
#define UDMA_M2S_Q_REFLECT_CTRL_RX_MAX_TH_SHIFT 8
/*
 * When current head ptr bigger then last update ptr with the tx_max_th  a cache update will be
 * issued even if didn't arrive to timeout (th allow by passing timer)
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_Q_REFLECT_CTRL_TX_MAX_TH_MASK 0x00FF0000
#define UDMA_M2S_Q_REFLECT_CTRL_TX_MAX_TH_SHIFT 16

/**** app_status_mask register ****/
/* Reset: 0x0         Access: RW */
#define UDMA_M2S_Q_REFLECT_APP_STATUS_MASK_VAL_MASK 0xFFFFFFFF
#define UDMA_M2S_Q_REFLECT_APP_STATUS_MASK_VAL_SHIFT 0

/**************************************************************************************************
 * udma_m2s_q
 **************************************************************************************************/
struct udma_m2s_q {
	/* [0x0] M2S descriptor prefetch configuration */
	uint32_t desc_pref_cfg;
	/* [0x4] M2S descriptor prefetch configuration 2 */
	uint32_t desc_pref_cfg2;
	/* [0x8] */
	uint32_t rsrvd_0[6];
	/* [0x20] M2S descriptor ring configuration */
	uint32_t cfg;
	/* [0x24] M2S descriptor ring status and information */
	uint32_t status;
	/* [0x28] TX Descriptor Ring Base Pointer [31:6] */
	uint32_t tdrbp_low;
	/* [0x2c] TX Descriptor Ring Base Pointer [63:32] */
	uint32_t tdrbp_high;
	/* [0x30] TX Descriptor Ring Length[23:2] */
	uint32_t tdrl;
	/* [0x34] TX Descriptor Ring Head Pointer */
	uint32_t tdrhp;
	/* [0x38] Tx Descriptor Tail Pointer increment */
	uint32_t tdrtp_inc;
	/* [0x3c] Tx Descriptor Tail Pointer */
	uint32_t tdrtp;
	/* [0x40] TX Descriptor Current Pointer */
	uint32_t tdcp;
	/* [0x44] Tx Completion Ring Base Pointer [31:6] */
	uint32_t tcrbp_low;
	/* [0x48] TX Completion Ring Base Pointer [63:32] */
	uint32_t tcrbp_high;
	/* [0x4c] TX Completion Ring Head Pointer */
	uint32_t tcrhp;
	/* [0x50] Tx Completion Ring Head Pointer internal (Before the coalescing FIFO) */
	uint32_t tcrhp_internal;
	/* [0x54] */
	uint32_t rsrvd_1[3];
	/* [0x60] Token bucket rate limit configuration */
	uint32_t rate_limit_cfg_1;
	/* [0x64] Token bucket rate limit configuration */
	uint32_t rate_limit_cfg_cycle;
	/* [0x68] Token bucket rate limit configuration */
	uint32_t rate_limit_cfg_token_size_1;
	/* [0x6c] Token bucket rate limit configuration */
	uint32_t rate_limit_cfg_token_size_2;
	/* [0x70] Rate limiter software control */
	uint32_t rate_limit_sw_ctrl;
	/*
	 * [0x74] Mask the different types of rate limiters for this queue.
	 * 0 - Rate limit is active.
	 * 1 - Rate limit is masked.
	 */
	uint32_t rate_limit_mask;
	/* [0x78] */
	uint32_t rsrvd_2[2];
	/* [0x80] DWRR scheduler configuration */
	uint32_t dwrr_cfg_1;
	/* [0x84] DWRR scheduler configuration */
	uint32_t dwrr_cfg_2;
	/* [0x88] DWRR scheduler configuration */
	uint32_t dwrr_cfg_3;
	/* [0x8c] DWRR scheduler software control */
	uint32_t dwrr_sw_ctrl;
	/* [0x90] */
	uint32_t rsrvd_3[4];
	/* [0xa0] Completion controller configuration */
	uint32_t comp_cfg;
	/* [0xa4] */
	uint32_t rsrvd_4[3];
	/* [0xb0] SW control */
	uint32_t q_sw_ctrl;
	/* [0xb4] */
	uint32_t rsrvd_5[3];
	/* [0xc0] Number of M2S Tx packets after the scheduler */
	uint32_t q_tx_pkt;
	/* [0xc4] */
	uint32_t rsrvd_6[3];
	/*
	 * [0xd0] This register can override the snop indication when fetching data (APP will use
	 * snoop bit from desc, so this is the way to control it per queue)
	 */
	uint32_t read_data_snp;
	/*
	 * [0xd4] Set Transmit descriptor ring tail pointer to certain value instead of '0' on reset
	 */
	uint32_t tdrtp_set;
	/*
	 * [0xd8] Set Transmit descriptor ring head pointer to certain value instead of '0' on reset
	 */
	uint32_t tdrhp_set;
	/* [0xdc] Reflect status ctrl */
	struct udma_m2s_q_reflect reflect;
	/* [0xec] */
	uint32_t rsrvd_7[965];
};

/**** desc_pref_cfg register ****/
/*
 * Size of the descriptor prefetch FIFO (in descriptors)
 * Reset: 0x200       Access: RW
 */
#define UDMA_M2S_Q_DESC_PREF_CFG_FIFO_DEPTH_MASK 0x00003FFF
#define UDMA_M2S_Q_DESC_PREF_CFG_FIFO_DEPTH_SHIFT 0
/*
 * Size of the descriptor prefetch FIFO (in descriptors)
 * Reset: Variable    Access: RW
 *  Index    ResetValue
 *  0        0x0
 *  1        0x200
 *  2        0x400
 *  3        0x600
 *  4        0x800
 *  5        0xa00
 *  6        0xc00
 *  7        0xe00
 *  8        0x1000
 *  9        0x1200
 *  10       0x1400
 *  11       0x1600
 *  12       0x1800
 *  13       0x1a00
 *  14       0x1c00
 *  15       0x1e00
 */
#define UDMA_M2S_Q_DESC_PREF_CFG_FIFO_START_ADDR_MASK 0x1FFF0000
#define UDMA_M2S_Q_DESC_PREF_CFG_FIFO_START_ADDR_SHIFT 16

/**** desc_pref_cfg2 register ****/
/*
 * Size of the descriptor prefetch FIFO (in descriptors)
 * Reset: Variable    Access: RW
 *  Index    ResetValue
 *  0        0x1ff
 *  1        0x3ff
 *  2        0x5ff
 *  3        0x7ff
 *  4        0x9ff
 *  5        0xbff
 *  6        0xdff
 *  7        0xfff
 *  8        0x11ff
 *  9        0x13ff
 *  10       0x15ff
 *  11       0x17ff
 *  12       0x19ff
 *  13       0x1bff
 *  14       0x1dff
 *  15       0x1fff
 */
#define UDMA_M2S_Q_DESC_PREF_CFG2_FIFO_END_ADDR_MASK 0x00001FFF
#define UDMA_M2S_Q_DESC_PREF_CFG2_FIFO_END_ADDR_SHIFT 0

/**** cfg register ****/
/*
 * Length offset to be used for each packet from this queue.
 * (length offset is used for the scheduler and rate limiter).
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_Q_CFG_PKT_LEN_OFFSET_MASK 0x0000FFFF
#define UDMA_M2S_Q_CFG_PKT_LEN_OFFSET_SHIFT 0
/*
 * Enable operation of this queue.
 * Start prefetch.
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_Q_CFG_EN_PREF       (1 << 16)
#define UDMA_M2S_Q_CFG_EN_PREF_MASK  0x00010000
#define UDMA_M2S_Q_CFG_EN_PREF_SHIFT 16
/*
 * Enable operation of this queue.
 * Start scheduling.
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_Q_CFG_EN_SCHEDULING (1 << 17)
#define UDMA_M2S_Q_CFG_EN_SCHEDULING_MASK 0x00020000
#define UDMA_M2S_Q_CFG_EN_SCHEDULING_SHIFT 17
/*
 * Allow prefetch of less than minimum prefetch burst size.
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_Q_CFG_ALLOW_LT_MIN_PREF (1 << 20)
#define UDMA_M2S_Q_CFG_ALLOW_LT_MIN_PREF_MASK 0x00100000
#define UDMA_M2S_Q_CFG_ALLOW_LT_MIN_PREF_SHIFT 20
/*
 * Configure the AXI AWCACHE for completion write.
 * Reset: 0x3         Access: RW
 */
#define UDMA_M2S_Q_CFG_AXI_AWCACHE_COMP_MASK 0x0F000000
#define UDMA_M2S_Q_CFG_AXI_AWCACHE_COMP_SHIFT 24
/*
 * AXI QoS for the selected queue.
 * This value is used in AXI transactions associated with this queue and the prefetch and completion
 * arbiters.
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_Q_CFG_AXI_QOS_MASK  0x70000000
#define UDMA_M2S_Q_CFG_AXI_QOS_SHIFT 28
/*
 * Completion write force full line write. If partial, repeat pre-start with the old data and fill
 * post-end with previous ring-id indicator.
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_Q_CFG_FORCE_FULL_LINE (1 << 31)
#define UDMA_M2S_Q_CFG_FORCE_FULL_LINE_MASK 0x80000000
#define UDMA_M2S_Q_CFG_FORCE_FULL_LINE_SHIFT 31

/**** status register ****/
/*
 * Indicates how many entries are used in the queue
 * Reset: 0x0         Access: RO
 */
#define UDMA_M2S_Q_STATUS_Q_USED_MASK 0x01FFFFFF
#define UDMA_M2S_Q_STATUS_Q_USED_SHIFT 0
/*
 * prefetch status
 * 0 - prefetch operation is stopped
 * 1 - prefetch is operational
 * Reset: 0x0         Access: RO
 */
#define UDMA_M2S_Q_STATUS_PREFETCH   (1 << 28)
#define UDMA_M2S_Q_STATUS_PREFETCH_MASK 0x10000000
#define UDMA_M2S_Q_STATUS_PREFETCH_SHIFT 28
/*
 * Queue scheduler status
 * 0 - queue is not active and not participating in scheduling
 * 1 - queue is active and participating in the scheduling process
 * Reset: 0x0         Access: RO
 */
#define UDMA_M2S_Q_STATUS_SCHEDULER  (1 << 29)
#define UDMA_M2S_Q_STATUS_SCHEDULER_MASK 0x20000000
#define UDMA_M2S_Q_STATUS_SCHEDULER_SHIFT 29
/*
 * Queue is suspended due to DMB
 * Reset: 0x0         Access: RO
 */
#define UDMA_M2S_Q_STATUS_Q_DMB      (1 << 30)
#define UDMA_M2S_Q_STATUS_Q_DMB_MASK 0x40000000
#define UDMA_M2S_Q_STATUS_Q_DMB_SHIFT 30
/*
 * Queue full indication.
 * (used by the host when head pointer equals tail pointer).
 * Reset: 0x0         Access: RO
 */
#define UDMA_M2S_Q_STATUS_Q_FULL     (1 << 31)
#define UDMA_M2S_Q_STATUS_Q_FULL_MASK 0x80000000
#define UDMA_M2S_Q_STATUS_Q_FULL_SHIFT 31

/**** tdrbp_low register ****/
/*
 * M2S Descriptor Ring Base address [31:6].
 * Value of the base address of the M2S descriptor ring
 * [5:0] - 0 - 64B alignment is enforced
 * ([11:6] should be 0 for 4KB alignment)
 * Reset: 0x1         Access: RW
 */
#define UDMA_M2S_Q_TDRBP_LOW_ADDR_MASK 0xFFFFFFC0
#define UDMA_M2S_Q_TDRBP_LOW_ADDR_SHIFT 6

/**** tdrbp_high register ****/
/*
 * Value of the base address of the M2S descriptor ring
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_Q_TDRBP_HIGH_ADDR_MASK 0xFFFFFFFF
#define UDMA_M2S_Q_TDRBP_HIGH_ADDR_SHIFT 0

/**** tdrl register ****/
/*
 * Length of the descriptor ring.
 * (descriptors)
 * Associated with the ring base address, ends at maximum burst size alignment.
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_Q_TDRL_OFFSET_MASK  0x00FFFFFF
#define UDMA_M2S_Q_TDRL_OFFSET_SHIFT 0

/**** tdrhp register ****/
/*
 * Relative offset of the next descriptor that needs to be read into the prefetch FIFO.
 * Incremented when the DMA reads valid descriptors from the host memory to the prefetch FIFO.
 * Note that this is the offset in # of descriptors and not in byte address.
 * Reset: 0x0         Access: RO
 */
#define UDMA_M2S_Q_TDRHP_OFFSET_MASK 0x00FFFFFF
#define UDMA_M2S_Q_TDRHP_OFFSET_SHIFT 0
/*
 * Ring ID
 * Reset: 0x1         Access: RO
 */
#define UDMA_M2S_Q_TDRHP_RING_ID_MASK 0xC0000000
#define UDMA_M2S_Q_TDRHP_RING_ID_SHIFT 30

/**** tdrtp_inc register ****/
/*
 * Increments the value in Q_TDRTP (descriptors)
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_Q_TDRTP_INC_VAL_MASK 0x00FFFFFF
#define UDMA_M2S_Q_TDRTP_INC_VAL_SHIFT 0

/**** tdrtp register ****/
/*
 * Relative offset of the next free descriptor in the host memory.
 * Note that this is the offset in # of descriptors and not in byte address.
 * Reset: 0x0         Access: RO
 */
#define UDMA_M2S_Q_TDRTP_OFFSET_MASK 0x00FFFFFF
#define UDMA_M2S_Q_TDRTP_OFFSET_SHIFT 0
/*
 * Ring ID
 * Reset: 0x1         Access: RO
 */
#define UDMA_M2S_Q_TDRTP_RING_ID_MASK 0xC0000000
#define UDMA_M2S_Q_TDRTP_RING_ID_SHIFT 30

/**** tdcp register ****/
/*
 * Relative offset of the first descriptor in the prefetch FIFO.
 * This is the next descriptor that will be read by the scheduler.
 * Reset: 0x0         Access: RO
 */
#define UDMA_M2S_Q_TDCP_OFFSET_MASK  0x00FFFFFF
#define UDMA_M2S_Q_TDCP_OFFSET_SHIFT 0
/*
 * Ring ID
 * Reset: 0x1         Access: RO
 */
#define UDMA_M2S_Q_TDCP_RING_ID_MASK 0xC0000000
#define UDMA_M2S_Q_TDCP_RING_ID_SHIFT 30

/**** tcrbp_low register ****/
/*
 * M2S Descriptor Ring Base address [31:6].
 * Value of the base address of the M2S descriptor ring
 * [5:0] - 0 - 64B alignment is enforced
 * ([11:6] should be 0 for 4KB alignment)
 * NOTE:
 * Length of the descriptor ring (in descriptors) associated with the ring base address. Ends at
 * maximum burst size alignment.
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_Q_TCRBP_LOW_ADDR_MASK 0xFFFFFFC0
#define UDMA_M2S_Q_TCRBP_LOW_ADDR_SHIFT 6

/**** tcrbp_high register ****/
/*
 * Value of the base address of the TX completion ring
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_Q_TCRBP_HIGH_ADDR_MASK 0xFFFFFFFF
#define UDMA_M2S_Q_TCRBP_HIGH_ADDR_SHIFT 0

/**** tcrhp register ****/
/*
 * Relative offset of the next descriptor that needs to be updated by the completion controller.
 * Note: This is in descriptors and not in byte address.
 * Reset: 0x0         Access: RO
 */
#define UDMA_M2S_Q_TCRHP_OFFSET_MASK 0x00FFFFFF
#define UDMA_M2S_Q_TCRHP_OFFSET_SHIFT 0
/*
 * Ring ID
 * Reset: 0x1         Access: RO
 */
#define UDMA_M2S_Q_TCRHP_RING_ID_MASK 0xC0000000
#define UDMA_M2S_Q_TCRHP_RING_ID_SHIFT 30

/**** tcrhp_internal register ****/
/*
 * Relative offset of the next descriptor that needs to be updated by the completion controller.
 * Note: This is in descriptors and not in byte address.
 * Reset: 0x0         Access: RO
 */
#define UDMA_M2S_Q_TCRHP_INTERNAL_OFFSET_MASK 0x00FFFFFF
#define UDMA_M2S_Q_TCRHP_INTERNAL_OFFSET_SHIFT 0
/*
 * Ring ID
 * Reset: 0x1         Access: RO
 */
#define UDMA_M2S_Q_TCRHP_INTERNAL_RING_ID_MASK 0xC0000000
#define UDMA_M2S_Q_TCRHP_INTERNAL_RING_ID_SHIFT 30

/**** rate_limit_cfg_1 register ****/
/*
 * Maximum number of accumulated bytes in the token counter.
 * Reset: 0xffffff    Access: RW
 */
#define UDMA_M2S_Q_RATE_LIMIT_CFG_1_MAX_BURST_SIZE_MASK 0x00FFFFFF
#define UDMA_M2S_Q_RATE_LIMIT_CFG_1_MAX_BURST_SIZE_SHIFT 0
/*
 * Enable the rate limiter.
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_Q_RATE_LIMIT_CFG_1_EN (1 << 24)
#define UDMA_M2S_Q_RATE_LIMIT_CFG_1_EN_MASK 0x01000000
#define UDMA_M2S_Q_RATE_LIMIT_CFG_1_EN_SHIFT 24
/*
 * Stop token fill.
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_Q_RATE_LIMIT_CFG_1_PAUSE (1 << 25)
#define UDMA_M2S_Q_RATE_LIMIT_CFG_1_PAUSE_MASK 0x02000000
#define UDMA_M2S_Q_RATE_LIMIT_CFG_1_PAUSE_SHIFT 25

/**** rate_limit_cfg_cycle register ****/
/*
 * Number of short cycles between token fills
 * Reset: 0x1         Access: RW
 */
#define UDMA_M2S_Q_RATE_LIMIT_CFG_CYCLE_LONG_CYCLE_SIZE_MASK 0x0000FFFF
#define UDMA_M2S_Q_RATE_LIMIT_CFG_CYCLE_LONG_CYCLE_SIZE_SHIFT 0

/**** rate_limit_cfg_token_size_1 register ****/
/*
 * Number of bits to add in each long cycle
 * Reset: 0xffff      Access: RW
 */
#define UDMA_M2S_Q_RATE_LIMIT_CFG_TOKEN_SIZE_1_LONG_CYCLE_MASK 0x0007FFFF
#define UDMA_M2S_Q_RATE_LIMIT_CFG_TOKEN_SIZE_1_LONG_CYCLE_SHIFT 0

/**** rate_limit_cfg_token_size_2 register ****/
/*
 * Number of bits to add in each cycle
 * Reset: 0xffff      Access: RW
 */
#define UDMA_M2S_Q_RATE_LIMIT_CFG_TOKEN_SIZE_2_SHORT_CYCLE_MASK 0x0007FFFF
#define UDMA_M2S_Q_RATE_LIMIT_CFG_TOKEN_SIZE_2_SHORT_CYCLE_SHIFT 0

/**** rate_limit_sw_ctrl register ****/
/*
 * Reset the token bucket counter.
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_Q_RATE_LIMIT_SW_CTRL_RST_TOKEN_CNT (1 << 0)
#define UDMA_M2S_Q_RATE_LIMIT_SW_CTRL_RST_TOKEN_CNT_MASK 0x00000001
#define UDMA_M2S_Q_RATE_LIMIT_SW_CTRL_RST_TOKEN_CNT_SHIFT 0

/**** rate_limit_mask register ****/
/*
 * Mask the external rate limiter.
 * Reset: 0x1         Access: RW
 */
#define UDMA_M2S_Q_RATE_LIMIT_MASK_EXTERNAL_RATE_LIMITER (1 << 0)
#define UDMA_M2S_Q_RATE_LIMIT_MASK_EXTERNAL_RATE_LIMITER_MASK 0x00000001
#define UDMA_M2S_Q_RATE_LIMIT_MASK_EXTERNAL_RATE_LIMITER_SHIFT 0
/*
 * Mask the internal rate limiter.
 * Reset: 0x1         Access: RW
 */
#define UDMA_M2S_Q_RATE_LIMIT_MASK_INTERNAL_RATE_LIMITER (1 << 1)
#define UDMA_M2S_Q_RATE_LIMIT_MASK_INTERNAL_RATE_LIMITER_MASK 0x00000002
#define UDMA_M2S_Q_RATE_LIMIT_MASK_INTERNAL_RATE_LIMITER_SHIFT 1
/*
 * Mask the internal pause mechanism for DMB.
 * (Data Memory Barrier).
 * Reset: 0x1         Access: RW
 */
#define UDMA_M2S_Q_RATE_LIMIT_MASK_INTERNAL_PAUSE_DMB (1 << 2)
#define UDMA_M2S_Q_RATE_LIMIT_MASK_INTERNAL_PAUSE_DMB_MASK 0x00000004
#define UDMA_M2S_Q_RATE_LIMIT_MASK_INTERNAL_PAUSE_DMB_SHIFT 2
/*
 * Mask the external application pause interface.
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_Q_RATE_LIMIT_MASK_EXTERNAL_PAUSE (1 << 3)
#define UDMA_M2S_Q_RATE_LIMIT_MASK_EXTERNAL_PAUSE_MASK 0x00000008
#define UDMA_M2S_Q_RATE_LIMIT_MASK_EXTERNAL_PAUSE_SHIFT 3

/**** dwrr_cfg_1 register ****/
/*
 * Maximum number of accumulated bytes in the deficit counter
 * Reset: 0xffffff    Access: RW
 */
#define UDMA_M2S_Q_DWRR_CFG_1_MAX_DEFICIT_CNT_SIZE_MASK 0x00FFFFFF
#define UDMA_M2S_Q_DWRR_CFG_1_MAX_DEFICIT_CNT_SIZE_SHIFT 0
/*
 * Bypass the DWRR.
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_Q_DWRR_CFG_1_STRICT (1 << 24)
#define UDMA_M2S_Q_DWRR_CFG_1_STRICT_MASK 0x01000000
#define UDMA_M2S_Q_DWRR_CFG_1_STRICT_SHIFT 24
/*
 * Stop deficit counter increment.
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_Q_DWRR_CFG_1_PAUSE  (1 << 25)
#define UDMA_M2S_Q_DWRR_CFG_1_PAUSE_MASK 0x02000000
#define UDMA_M2S_Q_DWRR_CFG_1_PAUSE_SHIFT 25

/**** dwrr_cfg_2 register ****/
/*
 * Value for the queue QoS.
 * Queues with the same QoS value are scheduled with RR/DWRR.
 * Only LOG(number of queues) is used.
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_Q_DWRR_CFG_2_Q_QOS_MASK 0x000000FF
#define UDMA_M2S_Q_DWRR_CFG_2_Q_QOS_SHIFT 0

/**** dwrr_cfg_3 register ****/
/*
 * Queue weight
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_Q_DWRR_CFG_3_WEIGHT_MASK 0x000000FF
#define UDMA_M2S_Q_DWRR_CFG_3_WEIGHT_SHIFT 0

/**** dwrr_sw_ctrl register ****/
/*
 * Reset the DWRR deficit counter.
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_Q_DWRR_SW_CTRL_RST_CNT (1 << 0)
#define UDMA_M2S_Q_DWRR_SW_CTRL_RST_CNT_MASK 0x00000001
#define UDMA_M2S_Q_DWRR_SW_CTRL_RST_CNT_SHIFT 0

/**** comp_cfg register ****/
/*
 * Enable writing to the completion ring
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_Q_COMP_CFG_EN_COMP_RING_UPDATE (1 << 0)
#define UDMA_M2S_Q_COMP_CFG_EN_COMP_RING_UPDATE_MASK 0x00000001
#define UDMA_M2S_Q_COMP_CFG_EN_COMP_RING_UPDATE_SHIFT 0
/*
 * Disable the completion coalescing function.
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_Q_COMP_CFG_DIS_COMP_COAL (1 << 1)
#define UDMA_M2S_Q_COMP_CFG_DIS_COMP_COAL_MASK 0x00000002
#define UDMA_M2S_Q_COMP_CFG_DIS_COMP_COAL_SHIFT 1

/**** q_sw_ctrl register ****/
/*
 * Reset the DMB hardware barrier
 * (enable queue operation).
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_Q_SW_CTRL_RST_DMB (1 << 0)
#define UDMA_M2S_Q_SW_CTRL_RST_DMB_MASK 0x00000001
#define UDMA_M2S_Q_SW_CTRL_RST_DMB_SHIFT 0
/*
 * Reset the tail pointer hardware.
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_Q_SW_CTRL_RST_TAIL_PTR (1 << 1)
#define UDMA_M2S_Q_SW_CTRL_RST_TAIL_PTR_MASK 0x00000002
#define UDMA_M2S_Q_SW_CTRL_RST_TAIL_PTR_SHIFT 1
/*
 * Reset the head pointer hardware.
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_Q_SW_CTRL_RST_HEAD_PTR (1 << 2)
#define UDMA_M2S_Q_SW_CTRL_RST_HEAD_PTR_MASK 0x00000004
#define UDMA_M2S_Q_SW_CTRL_RST_HEAD_PTR_SHIFT 2
/*
 * Reset the current pointer hardware.
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_Q_SW_CTRL_RST_CURRENT_PTR (1 << 3)
#define UDMA_M2S_Q_SW_CTRL_RST_CURRENT_PTR_MASK 0x00000008
#define UDMA_M2S_Q_SW_CTRL_RST_CURRENT_PTR_SHIFT 3
/*
 * Reset the queue
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_Q_SW_CTRL_RST_Q   (1 << 8)
#define UDMA_M2S_Q_SW_CTRL_RST_Q_MASK 0x00000100
#define UDMA_M2S_Q_SW_CTRL_RST_Q_SHIFT 8

/**** q_tx_pkt register ****/
/*
 * Counting the number of packets transmitted per queue
 * Reset: 0x0         Access: RO, RtoClr
 */
#define UDMA_M2S_Q_TX_PKT_CNT_MASK 0xFFFFFFFF
#define UDMA_M2S_Q_TX_PKT_CNT_SHIFT 0

/**** read_data_snp register ****/
/*
 * if set override snoop indication coming from descritpor
 * Reset: 0x0         Access: RW
 */
#define UDMA_M2S_Q_READ_DATA_SNP_OVERRIDE_SNOOP_EN (1 << 0)
#define UDMA_M2S_Q_READ_DATA_SNP_OVERRIDE_SNOOP_EN_MASK 0x00000001
#define UDMA_M2S_Q_READ_DATA_SNP_OVERRIDE_SNOOP_EN_SHIFT 0
/*
 * if override is set this will be the snoop value for AXI
 * Reset: 0x1         Access: RW
 */
#define UDMA_M2S_Q_READ_DATA_SNP_SNOOP_VAL (1 << 1)
#define UDMA_M2S_Q_READ_DATA_SNP_SNOOP_VAL_MASK 0x00000002
#define UDMA_M2S_Q_READ_DATA_SNP_SNOOP_VAL_SHIFT 1

/**** tdrtp_set register ****/
/*
 * this value will go to
 * submission queue tail pointer
 * Reset: 0x0         Access: WO
 */
#define UDMA_M2S_Q_TDRTP_SET_PTR_VAL_MASK 0x00FFFFFF
#define UDMA_M2S_Q_TDRTP_SET_PTR_VAL_SHIFT 0
/*
 * this value will go to sumission queue ring id
 * Reset: 0x0         Access: WO
 */
#define UDMA_M2S_Q_TDRTP_SET_RING_ID_MASK 0x03000000
#define UDMA_M2S_Q_TDRTP_SET_RING_ID_SHIFT 24

/**** tdrhp_set register ****/
/*
 * this value will go to:
 * submission queue head pointer
 * cmpl queue head pointer
 * Reset: 0x0         Access: WO
 */
#define UDMA_M2S_Q_TDRHP_SET_PTR_VALUE_MASK 0x00FFFFFF
#define UDMA_M2S_Q_TDRHP_SET_PTR_VALUE_SHIFT 0
/*
 * this value will go to:
 * submission queue head pointer
 * cmpl queue ring id
 * Reset: 0x0         Access: WO
 */
#define UDMA_M2S_Q_TDRHP_SET_RIND_IG_MASK 0x03000000
#define UDMA_M2S_Q_TDRHP_SET_RIND_IG_SHIFT 24

/**************************************************************************************************
 * udma_regs
 **************************************************************************************************/
struct udma_m2s_regs {
	/* [0x0] */
	uint32_t rsrvd_0[64];
	/* [0x100] AXI M2S configuration */
	struct udma_axi_m2s axi_m2s;
	/* [0x200] M2S general configuration */
	struct udma_m2s m2s;
	/* [0x300] M2S descriptor and data read  configuration */
	struct udma_m2s_rd m2s_rd;
	/* [0x340] M2S DWRR scheduler configuration */
	struct udma_m2s_dwrr m2s_dwrr;
	/* [0x380] M2S rate limiter configuration */
	struct udma_m2s_rate_limiter m2s_rate_limiter;
	/* [0x3c0] M2S rate limiter configuration */
	struct udma_m2s_stream_rate_limiter m2s_stream_rate_limiter;
	/* [0x400] M2S completion control configuration */
	struct udma_m2s_comp m2s_comp;
	/* [0x500] M2S statistics */
	struct udma_m2s_stat m2s_stat;
	/* [0x600] M2S Feature registers */
	struct udma_m2s_feature m2s_feature;
	/* [0x700] */
	struct udma_m2s_shadow_access m2s_shadow_access;
	/* [0x800] */
	uint32_t rsrvd_1[512];
	/* [0x1000] */
	struct udma_m2s_q m2s_q[16];
	/* [0x11000] */
	uint32_t rsrvd_2[6144];
	/* [0x17000] Memory controller mapped regfile */
	uint32_t mem_ctrl[1024];
	/* [0x18000] PMU memory mapped regfile */
	uint32_t pmu[4096];
	/* [0x1c000] */
	uint32_t rsrvd_3[4096];
};

#ifdef __cplusplus
}
#endif

#endif

/** @} */
