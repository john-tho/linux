/*
 * Copyright 2019, Amazon.com, Inc. or its affiliates. All Rights Reserved
 */

/**
 *  @{
 * @file   al_hal_udma_s2m_regs.h
 *
 * @brief udma_s2m registers
 *
 * This file was auto-generated by RegGen v1.3.14
 *
 * Hash Key is: 6df3b8e520bb1669d712bb6a173d58f5
 *
 * JSON: al_udma_s2m_regs.json
 *
 */

#ifndef __AL_HAL_UDMA_S2M_REGS_H__
#define __AL_HAL_UDMA_S2M_REGS_H__

#include "al_hal_common.h"

#include "al_hal_cell_fe_regs.h"

#ifdef __cplusplus
extern "C" {
#endif

/**************************************************************************************************
 * udma_axi_s2m
 *
 * AXI S2M configuration
 **************************************************************************************************/
struct udma_axi_s2m {
	/* [0x0] Data write master configuration */
	uint32_t data_wr_cfg_1;
	/* [0x4] Data write master configuration */
	uint32_t data_wr_cfg_2;
	/* [0x8] Descriptor read master configuration */
	uint32_t desc_rd_cfg_4;
	/* [0xc] Descriptor read master configuration */
	uint32_t desc_rd_cfg_5;
	/* [0x10] Completion  write master configuration */
	uint32_t comp_wr_cfg_1;
	/* [0x14] Completion  write master configuration */
	uint32_t comp_wr_cfg_2;
	/* [0x18] Data write master configuration */
	uint32_t data_wr_cfg;
	/* [0x1c] Descriptors read master configuration */
	uint32_t desc_rd_cfg_3;
	/* [0x20] Completion descriptors write master configuration */
	uint32_t desc_wr_cfg_1;
	/* [0x24] AXI outstanding read configuration */
	uint32_t ostand_cfg_rd;
	/* [0x28] AXI outstanding write configuration */
	uint32_t ostand_cfg_wr;
	/* [0x2c] */
	uint32_t rsrvd_0[4];
	/* [0x3c] AXI outstanding indication status */
	uint32_t desc_rd_cfg_6;
	/* [0x40] AXI outstanding indication status */
	uint32_t data_wr_cfg_3;
	/* [0x44] AXI outstanding indication status */
	uint32_t comp_wr_cfg_3;
	/* [0x48] */
	uint32_t rsrvd_1[46];
};

/**** data_wr_cfg_1 register ****/
/*
 * AXI write  ID (AWID)
 * Reset: 0x3         Access: RW
 */
#define UDMA_AXI_S2M_DATA_WR_CFG_1_AWID_MASK 0x000000FF
#define UDMA_AXI_S2M_DATA_WR_CFG_1_AWID_SHIFT 0
/*
 * Configure the AXI AWCACHE
 * for data write
 * Reset: 0x7         Access: RW
 */
#define UDMA_AXI_S2M_DATA_WR_CFG_1_AWCACHE_MASK 0x000F0000
#define UDMA_AXI_S2M_DATA_WR_CFG_1_AWCACHE_SHIFT 16
/*
 * Burst type
 * Reset: 0x1         Access: RW
 */
#define UDMA_AXI_S2M_DATA_WR_CFG_1_AWBURST_MASK 0x03000000
#define UDMA_AXI_S2M_DATA_WR_CFG_1_AWBURST_SHIFT 24

/**** data_wr_cfg_2 register ****/
/*
 * User extension
 * Reset: 0x0         Access: RW
 */
#define UDMA_AXI_S2M_DATA_WR_CFG_2_AWUSER_MASK 0x000FFFFF
#define UDMA_AXI_S2M_DATA_WR_CFG_2_AWUSER_SHIFT 0
/*
 * Bus size, 256-bit
 * Reset: 0x5         Access: RW
 */
#define UDMA_AXI_S2M_DATA_WR_CFG_2_AWSIZE_MASK 0x00700000
#define UDMA_AXI_S2M_DATA_WR_CFG_2_AWSIZE_SHIFT 20
/*
 * AXI Master QoS.
 * Used for arbitration between AXI masters
 * Reset: 0x0         Access: RW
 */
#define UDMA_AXI_S2M_DATA_WR_CFG_2_AWQOS_MASK 0x07000000
#define UDMA_AXI_S2M_DATA_WR_CFG_2_AWQOS_SHIFT 24
/*
 * Protection Type
 * Reset: 0x3         Access: RW
 */
#define UDMA_AXI_S2M_DATA_WR_CFG_2_AWPROT_MASK 0x70000000
#define UDMA_AXI_S2M_DATA_WR_CFG_2_AWPROT_SHIFT 28

/**** desc_rd_cfg_4 register ****/
/*
 * AXI read  ID (ARID)
 * Reset: 0x2         Access: RW
 */
#define UDMA_AXI_S2M_DESC_RD_CFG_4_ARID_MASK 0x000000FF
#define UDMA_AXI_S2M_DESC_RD_CFG_4_ARID_SHIFT 0
/*
 * Cache Type
 * Reset: 0xb         Access: RW
 */
#define UDMA_AXI_S2M_DESC_RD_CFG_4_ARCACHE_MASK 0x000F0000
#define UDMA_AXI_S2M_DESC_RD_CFG_4_ARCACHE_SHIFT 16
/*
 * Burst type
 * Reset: 0x1         Access: RW
 */
#define UDMA_AXI_S2M_DESC_RD_CFG_4_ARBURST_MASK 0x03000000
#define UDMA_AXI_S2M_DESC_RD_CFG_4_ARBURST_SHIFT 24

/**** desc_rd_cfg_5 register ****/
/*
 * User extension
 * Reset: 0x0         Access: RW
 */
#define UDMA_AXI_S2M_DESC_RD_CFG_5_ARUSER_MASK 0x000FFFFF
#define UDMA_AXI_S2M_DESC_RD_CFG_5_ARUSER_SHIFT 0
/*
 * Bus size, 256-bit
 * Reset: 0x5         Access: RW
 */
#define UDMA_AXI_S2M_DESC_RD_CFG_5_ARSIZE_MASK 0x00700000
#define UDMA_AXI_S2M_DESC_RD_CFG_5_ARSIZE_SHIFT 20
/*
 * AXI Master QoS.
 * Used for arbitration between AXI masters
 * Reset: 0x2         Access: RW
 */
#define UDMA_AXI_S2M_DESC_RD_CFG_5_ARQOS_MASK 0x07000000
#define UDMA_AXI_S2M_DESC_RD_CFG_5_ARQOS_SHIFT 24
/*
 * Protection Type
 * Reset: 0x3         Access: RW
 */
#define UDMA_AXI_S2M_DESC_RD_CFG_5_ARPROT_MASK 0x70000000
#define UDMA_AXI_S2M_DESC_RD_CFG_5_ARPROT_SHIFT 28

/**** comp_wr_cfg_1 register ****/
/*
 * AXI write  ID (AWID)
 * Reset: 0x2         Access: RW
 */
#define UDMA_AXI_S2M_COMP_WR_CFG_1_AWID_MASK 0x000000FF
#define UDMA_AXI_S2M_COMP_WR_CFG_1_AWID_SHIFT 0
/*
 * Configure the AXI AWCACHE
 * for completion write
 * Reset: 0x7         Access: RW
 */
#define UDMA_AXI_S2M_COMP_WR_CFG_1_AWCACHE_MASK 0x000F0000
#define UDMA_AXI_S2M_COMP_WR_CFG_1_AWCACHE_SHIFT 16
/*
 * Burst type
 * Reset: 0x1         Access: RW
 */
#define UDMA_AXI_S2M_COMP_WR_CFG_1_AWBURST_MASK 0x03000000
#define UDMA_AXI_S2M_COMP_WR_CFG_1_AWBURST_SHIFT 24

/**** comp_wr_cfg_2 register ****/
/*
 * User extension
 * Reset: 0x0         Access: RW
 */
#define UDMA_AXI_S2M_COMP_WR_CFG_2_AWUSER_MASK 0x000FFFFF
#define UDMA_AXI_S2M_COMP_WR_CFG_2_AWUSER_SHIFT 0
/*
 * Bus size, 256-bit
 * Reset: 0x5         Access: RW
 */
#define UDMA_AXI_S2M_COMP_WR_CFG_2_AWSIZE_MASK 0x00700000
#define UDMA_AXI_S2M_COMP_WR_CFG_2_AWSIZE_SHIFT 20
/*
 * AXI Master QoS.
 * Used for arbitration between AXI masters
 * Reset: 0x0         Access: RW
 */
#define UDMA_AXI_S2M_COMP_WR_CFG_2_AWQOS_MASK 0x07000000
#define UDMA_AXI_S2M_COMP_WR_CFG_2_AWQOS_SHIFT 24
/*
 * Protection Type
 * Reset: 0x3         Access: RW
 */
#define UDMA_AXI_S2M_COMP_WR_CFG_2_AWPROT_MASK 0x70000000
#define UDMA_AXI_S2M_COMP_WR_CFG_2_AWPROT_SHIFT 28

/**** data_wr_cfg register ****/
/*
 * Defines the maximum number of AXI beats for a single AXI burst. This value is used for the burst
 * split decision.
 * Reset: 0x8         Access: RW
 */
#define UDMA_AXI_S2M_DATA_WR_CFG_MAX_AXI_BEATS_MASK 0x000000FF
#define UDMA_AXI_S2M_DATA_WR_CFG_MAX_AXI_BEATS_SHIFT 0

/**** desc_rd_cfg_3 register ****/
/*
 * Defines the maximum number of AXI beats for a single AXI burst. This value is used for the burst
 * split decision.
 * Reset: 0x8         Access: RW
 */
#define UDMA_AXI_S2M_DESC_RD_CFG_3_MAX_AXI_BEATS_MASK 0x000000FF
#define UDMA_AXI_S2M_DESC_RD_CFG_3_MAX_AXI_BEATS_SHIFT 0
/*
 * Enables breaking descriptor read request.
 * Aligned to max_AXI_beats when the total read size is less than max_AXI_beats.
 * Reset: 0x1         Access: RW
 */
#define UDMA_AXI_S2M_DESC_RD_CFG_3_ALWAYS_BREAK_ON_MAX_BOUDRY (1 << 16)
#define UDMA_AXI_S2M_DESC_RD_CFG_3_ALWAYS_BREAK_ON_MAX_BOUDRY_MASK 0x00010000
#define UDMA_AXI_S2M_DESC_RD_CFG_3_ALWAYS_BREAK_ON_MAX_BOUDRY_SHIFT 16

/**** desc_wr_cfg_1 register ****/
/*
 * Defines the maximum number of AXI beats for a single AXI burst. This value is used for the burst
 * split decision.
 * Reset: 0x8         Access: RW
 */
#define UDMA_AXI_S2M_DESC_WR_CFG_1_MAX_AXI_BEATS_MASK 0x000000FF
#define UDMA_AXI_S2M_DESC_WR_CFG_1_MAX_AXI_BEATS_SHIFT 0
/*
 * Minimum burst for writing completion descriptors.
 * (AXI beats).
 * Value must be aligned to cache lines (64 bytes).
 * Default value is 4 cache lines, 8 beats.
 * Reset: 0x8         Access: RW
 */
#define UDMA_AXI_S2M_DESC_WR_CFG_1_MIN_AXI_BEATS_MASK 0x00FF0000
#define UDMA_AXI_S2M_DESC_WR_CFG_1_MIN_AXI_BEATS_SHIFT 16

/**** ostand_cfg_rd register ****/
/*
 * Maximum number of outstanding descriptor reads to the AXI.
 * (AXI transactions).
 * Reset: 0x20        Access: RW
 */
#define UDMA_AXI_S2M_OSTAND_CFG_RD_MAX_DESC_RD_OSTAND_MASK 0x000000FF
#define UDMA_AXI_S2M_OSTAND_CFG_RD_MAX_DESC_RD_OSTAND_SHIFT 0
/*
 * Maximum number of outstanding stream acknowledges.
 * Reset: 0x40        Access: RW
 */
#define UDMA_AXI_S2M_OSTAND_CFG_RD_MAX_STREAM_ACK_MASK 0x00FF0000
#define UDMA_AXI_S2M_OSTAND_CFG_RD_MAX_STREAM_ACK_SHIFT 16

/**** ostand_cfg_wr register ****/
/*
 * Maximum number of outstanding data writes to the AXI.
 * (AXI transactions).
 * Reset: 0x20        Access: RW
 */
#define UDMA_AXI_S2M_OSTAND_CFG_WR_MAX_DATA_WR_OSTAND_MASK 0x000000FF
#define UDMA_AXI_S2M_OSTAND_CFG_WR_MAX_DATA_WR_OSTAND_SHIFT 0
/*
 * Maximum number of outstanding data beats for data write to AXI.
 * (AXI beats).
 * Reset: 0x40        Access: RW
 */
#define UDMA_AXI_S2M_OSTAND_CFG_WR_MAX_DATA_BEATS_WR_OSTAND_MASK 0x0000FF00
#define UDMA_AXI_S2M_OSTAND_CFG_WR_MAX_DATA_BEATS_WR_OSTAND_SHIFT 8
/*
 * Maximum number of outstanding descriptor writes to the AXI.
 * (AXI transactions).
 * Reset: 0x20        Access: RW
 */
#define UDMA_AXI_S2M_OSTAND_CFG_WR_MAX_COMP_REQ_MASK 0x00FF0000
#define UDMA_AXI_S2M_OSTAND_CFG_WR_MAX_COMP_REQ_SHIFT 16
/*
 * Maximum number of outstanding data beats for descriptor write to AXI.
 * (AXI beats).
 * Reset: 0x40        Access: RW
 */
#define UDMA_AXI_S2M_OSTAND_CFG_WR_MAX_COMP_DATA_WR_OSTAND_MASK 0xFF000000
#define UDMA_AXI_S2M_OSTAND_CFG_WR_MAX_COMP_DATA_WR_OSTAND_SHIFT 24

/**** desc_rd_cfg_6 register ****/
/*
 * Number of current outstanding transaction
 * Reset: 0x0         Access: RO
 */
#define UDMA_AXI_S2M_DESC_RD_CFG_6_FIFO_INUSE_MASK 0x000000FF
#define UDMA_AXI_S2M_DESC_RD_CFG_6_FIFO_INUSE_SHIFT 0
/*
 * Indication if fifo is full
 * Reset: 0x0         Access: RO
 */
#define UDMA_AXI_S2M_DESC_RD_CFG_6_FIFO_FULL (1 << 8)
#define UDMA_AXI_S2M_DESC_RD_CFG_6_FIFO_FULL_MASK 0x00000100
#define UDMA_AXI_S2M_DESC_RD_CFG_6_FIFO_FULL_SHIFT 8
/*
 * Indication if empty  is full
 * Reset: 0x0         Access: RO
 */
#define UDMA_AXI_S2M_DESC_RD_CFG_6_FIFO_EMPTY (1 << 9)
#define UDMA_AXI_S2M_DESC_RD_CFG_6_FIFO_EMPTY_MASK 0x00000200
#define UDMA_AXI_S2M_DESC_RD_CFG_6_FIFO_EMPTY_SHIFT 9

/**** data_wr_cfg_3 register ****/
/*
 * Number of current outstanding transaction
 * Reset: 0x0         Access: RO
 */
#define UDMA_AXI_S2M_DATA_WR_CFG_3_FIFO_INUSE_MASK 0x000000FF
#define UDMA_AXI_S2M_DATA_WR_CFG_3_FIFO_INUSE_SHIFT 0
/*
 * Indication if fifo is full
 * Reset: 0x0         Access: RO
 */
#define UDMA_AXI_S2M_DATA_WR_CFG_3_FIFO_FULL (1 << 8)
#define UDMA_AXI_S2M_DATA_WR_CFG_3_FIFO_FULL_MASK 0x00000100
#define UDMA_AXI_S2M_DATA_WR_CFG_3_FIFO_FULL_SHIFT 8
/*
 * Indication if empty  is full
 * Reset: 0x0         Access: RO
 */
#define UDMA_AXI_S2M_DATA_WR_CFG_3_FIFO_EMPTY (1 << 9)
#define UDMA_AXI_S2M_DATA_WR_CFG_3_FIFO_EMPTY_MASK 0x00000200
#define UDMA_AXI_S2M_DATA_WR_CFG_3_FIFO_EMPTY_SHIFT 9

/**** comp_wr_cfg_3 register ****/
/*
 * Number of current outstanding transaction
 * Reset: 0x0         Access: RO
 */
#define UDMA_AXI_S2M_COMP_WR_CFG_3_FIFO_INUSE_MASK 0x000000FF
#define UDMA_AXI_S2M_COMP_WR_CFG_3_FIFO_INUSE_SHIFT 0
/*
 * Indication if fifo is full
 * Reset: 0x0         Access: RO
 */
#define UDMA_AXI_S2M_COMP_WR_CFG_3_FIFO_FULL (1 << 8)
#define UDMA_AXI_S2M_COMP_WR_CFG_3_FIFO_FULL_MASK 0x00000100
#define UDMA_AXI_S2M_COMP_WR_CFG_3_FIFO_FULL_SHIFT 8
/*
 * Indication if empty  is full
 * Reset: 0x0         Access: RO
 */
#define UDMA_AXI_S2M_COMP_WR_CFG_3_FIFO_EMPTY (1 << 9)
#define UDMA_AXI_S2M_COMP_WR_CFG_3_FIFO_EMPTY_MASK 0x00000200
#define UDMA_AXI_S2M_COMP_WR_CFG_3_FIFO_EMPTY_SHIFT 9

/**************************************************************************************************
 * udma_s2m
 *
 * S2M general configuration
 **************************************************************************************************/
struct udma_s2m {
	/*
	 * [0x0] DMA state
	 * 00  - No pending tasks
	 * 01 - Normal (active)
	 * 10 - Abort (error condition)
	 * 11 - Reserved
	 */
	uint32_t state;
	/* [0x4] CPU request to change DMA state */
	uint32_t change_state;
	/* [0x8] */
	uint32_t rsrvd_0;
	/*
	 * [0xc] S2M DMA error log mask.
	 * Each error has an interrupt controller cause bit.
	 * This register determines if these errors cause the S2M DMA to log the error condition.
	 * 0 - Log is enable
	 * 1 - Log is masked.
	 */
	uint32_t err_log_mask;
	/* [0x10] */
	uint32_t rsrvd_1;
	/*
	 * [0x14] DMA header log
	 * Sample the packet header that caused the error
	 */
	uint32_t log_0;
	/*
	 * [0x18] DMA header log
	 * Sample the packet header that caused the error.
	 */
	uint32_t log_1;
	/*
	 * [0x1c] DMA header log
	 * Sample the packet header that caused the error.
	 */
	uint32_t log_2;
	/*
	 * [0x20] DMA header log
	 * Sample the packet header that caused the error
	 */
	uint32_t log_3;
	/* [0x24] DMA clear error log */
	uint32_t clear_err_log;
	/* [0x28] S2M stream data FIFO status */
	uint32_t s_data_fifo_status;
	/* [0x2c] S2M stream header FIFO status */
	uint32_t s_header_fifo_status;
	/* [0x30] S2M AXI data FIFO status */
	uint32_t axi_data_fifo_status;
	/* [0x34] S2M unack FIFO status */
	uint32_t unack_fifo_status;
	/* [0x38] Select queue for debug */
	uint32_t indirect_ctrl;
	/*
	 * [0x3c] S2M prefetch FIFO status.
	 * Status of the selected queue in S2M_indirect_ctrl
	 */
	uint32_t sel_pref_fifo_status;
	/*
	 * [0x40] S2M completion FIFO status.
	 * Status of the selected queue in S2M_indirect_ctrl
	 */
	uint32_t sel_comp_fifo_status;
	/* [0x44] S2M state machine and FIFO clear control */
	uint32_t clear_ctrl;
	/* [0x48] S2M Misc Check enable */
	uint32_t check_en;
	/* [0x4c] S2M FIFO enable control, internal */
	uint32_t fifo_en;
	/* [0x50] Stream interface configuration */
	uint32_t stream_cfg;
	/* [0x54] S2M FIFO enable control, internal */
	uint32_t pref_queue_en;
	/* [0x58] */
	uint32_t rsrvd_2[42];
};

/**** state register ****/
/* Reset: 0x0         Access: RO */
#define UDMA_S2M_STATE_COMP_CTRL_MASK 0x00000003
#define UDMA_S2M_STATE_COMP_CTRL_SHIFT 0
/* Reset: 0x0         Access: RO */
#define UDMA_S2M_STATE_STREAM_IF_MASK 0x00000030
#define UDMA_S2M_STATE_STREAM_IF_SHIFT 4
/* Reset: 0x0         Access: RO */
#define UDMA_S2M_STATE_DATA_WR_CTRL_MASK 0x00000300
#define UDMA_S2M_STATE_DATA_WR_CTRL_SHIFT 8
/* Reset: 0x0         Access: RO */
#define UDMA_S2M_STATE_DESC_PREF_MASK 0x00003000
#define UDMA_S2M_STATE_DESC_PREF_SHIFT 12
/* Reset: 0x0         Access: RO */
#define UDMA_S2M_STATE_AXI_WR_DATA_MASK 0x00030000
#define UDMA_S2M_STATE_AXI_WR_DATA_SHIFT 16
/* Reset: 0x0         Access: RO */
#define UDMA_S2M_STATE_LMA_CTRL_MASK 0x00300000
#define UDMA_S2M_STATE_LMA_CTRL_SHIFT 20

/**** change_state register ****/
/*
 * Start normal operation
 * Reset: 0x0         Access: RW
 */
#define UDMA_S2M_CHANGE_STATE_NORMAL (1 << 0)
#define UDMA_S2M_CHANGE_STATE_NORMAL_MASK 0x00000001
#define UDMA_S2M_CHANGE_STATE_NORMAL_SHIFT 0
/*
 * Stop normal operation
 * Reset: 0x0         Access: RW
 */
#define UDMA_S2M_CHANGE_STATE_DIS    (1 << 1)
#define UDMA_S2M_CHANGE_STATE_DIS_MASK 0x00000002
#define UDMA_S2M_CHANGE_STATE_DIS_SHIFT 1
/*
 * Stop all machines.
 * (Prefetch, scheduling, completion and stream interface)
 * Reset: 0x0         Access: RW
 */
#define UDMA_S2M_CHANGE_STATE_ABORT  (1 << 2)
#define UDMA_S2M_CHANGE_STATE_ABORT_MASK 0x00000004
#define UDMA_S2M_CHANGE_STATE_ABORT_SHIFT 2

/**** err_log_mask register ****/
/*
 * Internal error
 * Reset: 0x0         Access: RW
 */
#define UDMA_S2M_ERR_LOG_MASK_INTERNAL_MASK 0xFFFFFFFF
#define UDMA_S2M_ERR_LOG_MASK_INTERNAL_SHIFT 0

/**** log_0 register ****/
/*
 * word_0
 * Reset: 0x0         Access: RO
 */
#define UDMA_S2M_LOG_0_HEADER_MASK   0xFFFFFFFF
#define UDMA_S2M_LOG_0_HEADER_SHIFT  0

/**** log_1 register ****/
/*
 * word_1
 * Reset: 0x0         Access: RO
 */
#define UDMA_S2M_LOG_1_HEADER_MASK   0xFFFFFFFF
#define UDMA_S2M_LOG_1_HEADER_SHIFT  0

/**** log_2 register ****/
/*
 * word_2
 * Reset: 0x0         Access: RO
 */
#define UDMA_S2M_LOG_2_HEADER_MASK   0xFFFFFFFF
#define UDMA_S2M_LOG_2_HEADER_SHIFT  0

/**** log_3 register ****/
/*
 * word_3
 * Reset: 0x0         Access: RO
 */
#define UDMA_S2M_LOG_3_HEADER_MASK   0xFFFFFFFF
#define UDMA_S2M_LOG_3_HEADER_SHIFT  0

/**** clear_err_log register ****/
/*
 * Clear error log
 * Reset: 0x0         Access: RW
 */
#define UDMA_S2M_CLEAR_ERR_LOG_CLEAR (1 << 0)
#define UDMA_S2M_CLEAR_ERR_LOG_CLEAR_MASK 0x00000001
#define UDMA_S2M_CLEAR_ERR_LOG_CLEAR_SHIFT 0

/**** s_data_fifo_status register ****/
/*
 * FIFO used indication
 * Reset: 0x0         Access: RO
 */
#define UDMA_S2M_S_DATA_FIFO_STATUS_USED_MASK 0x0000FFFF
#define UDMA_S2M_S_DATA_FIFO_STATUS_USED_SHIFT 0
/*
 * FIFO empty indication
 * Reset: 0x0         Access: RO
 */
#define UDMA_S2M_S_DATA_FIFO_STATUS_EMPTY (1 << 24)
#define UDMA_S2M_S_DATA_FIFO_STATUS_EMPTY_MASK 0x01000000
#define UDMA_S2M_S_DATA_FIFO_STATUS_EMPTY_SHIFT 24
/*
 * FIFO full indication
 * Reset: 0x0         Access: RO
 */
#define UDMA_S2M_S_DATA_FIFO_STATUS_FULL (1 << 28)
#define UDMA_S2M_S_DATA_FIFO_STATUS_FULL_MASK 0x10000000
#define UDMA_S2M_S_DATA_FIFO_STATUS_FULL_SHIFT 28

/**** s_header_fifo_status register ****/
/*
 * FIFO used indication
 * Reset: 0x0         Access: RO
 */
#define UDMA_S2M_S_HEADER_FIFO_STATUS_USED_MASK 0x0000FFFF
#define UDMA_S2M_S_HEADER_FIFO_STATUS_USED_SHIFT 0
/*
 * FIFO empty indication
 * Reset: 0x0         Access: RO
 */
#define UDMA_S2M_S_HEADER_FIFO_STATUS_EMPTY (1 << 24)
#define UDMA_S2M_S_HEADER_FIFO_STATUS_EMPTY_MASK 0x01000000
#define UDMA_S2M_S_HEADER_FIFO_STATUS_EMPTY_SHIFT 24
/*
 * FIFO full indication
 * Reset: 0x0         Access: RO
 */
#define UDMA_S2M_S_HEADER_FIFO_STATUS_FULL (1 << 28)
#define UDMA_S2M_S_HEADER_FIFO_STATUS_FULL_MASK 0x10000000
#define UDMA_S2M_S_HEADER_FIFO_STATUS_FULL_SHIFT 28

/**** axi_data_fifo_status register ****/
/*
 * FIFO used indication
 * Reset: 0x0         Access: RO
 */
#define UDMA_S2M_AXI_DATA_FIFO_STATUS_USED_MASK 0x0000FFFF
#define UDMA_S2M_AXI_DATA_FIFO_STATUS_USED_SHIFT 0
/*
 * FIFO empty indication
 * Reset: 0x0         Access: RO
 */
#define UDMA_S2M_AXI_DATA_FIFO_STATUS_EMPTY (1 << 24)
#define UDMA_S2M_AXI_DATA_FIFO_STATUS_EMPTY_MASK 0x01000000
#define UDMA_S2M_AXI_DATA_FIFO_STATUS_EMPTY_SHIFT 24
/*
 * FIFO full indication
 * Reset: 0x0         Access: RO
 */
#define UDMA_S2M_AXI_DATA_FIFO_STATUS_FULL (1 << 28)
#define UDMA_S2M_AXI_DATA_FIFO_STATUS_FULL_MASK 0x10000000
#define UDMA_S2M_AXI_DATA_FIFO_STATUS_FULL_SHIFT 28

/**** unack_fifo_status register ****/
/*
 * FIFO used indication
 * Reset: 0x0         Access: RO
 */
#define UDMA_S2M_UNACK_FIFO_STATUS_USED_MASK 0x0000FFFF
#define UDMA_S2M_UNACK_FIFO_STATUS_USED_SHIFT 0
/*
 * FIFO empty indication
 * Reset: 0x0         Access: RO
 */
#define UDMA_S2M_UNACK_FIFO_STATUS_EMPTY (1 << 24)
#define UDMA_S2M_UNACK_FIFO_STATUS_EMPTY_MASK 0x01000000
#define UDMA_S2M_UNACK_FIFO_STATUS_EMPTY_SHIFT 24
/*
 * FIFO full indication
 * Reset: 0x0         Access: RO
 */
#define UDMA_S2M_UNACK_FIFO_STATUS_FULL (1 << 28)
#define UDMA_S2M_UNACK_FIFO_STATUS_FULL_MASK 0x10000000
#define UDMA_S2M_UNACK_FIFO_STATUS_FULL_SHIFT 28

/**** indirect_ctrl register ****/
/*
 * Selected queue for status read
 * Reset: 0x0         Access: RW
 */
#define UDMA_S2M_INDIRECT_CTRL_Q_NUM_MASK 0x00000FFF
#define UDMA_S2M_INDIRECT_CTRL_Q_NUM_SHIFT 0

/**** sel_pref_fifo_status register ****/
/*
 * FIFO used indication
 * Reset: 0x0         Access: RO
 */
#define UDMA_S2M_SEL_PREF_FIFO_STATUS_USED_MASK 0x0000FFFF
#define UDMA_S2M_SEL_PREF_FIFO_STATUS_USED_SHIFT 0
/*
 * FIFO empty indication
 * Reset: 0x0         Access: RO
 */
#define UDMA_S2M_SEL_PREF_FIFO_STATUS_EMPTY (1 << 24)
#define UDMA_S2M_SEL_PREF_FIFO_STATUS_EMPTY_MASK 0x01000000
#define UDMA_S2M_SEL_PREF_FIFO_STATUS_EMPTY_SHIFT 24
/*
 * FIFO full indication
 * Reset: 0x0         Access: RO
 */
#define UDMA_S2M_SEL_PREF_FIFO_STATUS_FULL (1 << 28)
#define UDMA_S2M_SEL_PREF_FIFO_STATUS_FULL_MASK 0x10000000
#define UDMA_S2M_SEL_PREF_FIFO_STATUS_FULL_SHIFT 28

/**** sel_comp_fifo_status register ****/
/*
 * FIFO used indication
 * Reset: 0x0         Access: RO
 */
#define UDMA_S2M_SEL_COMP_FIFO_STATUS_USED_MASK 0x0000FFFF
#define UDMA_S2M_SEL_COMP_FIFO_STATUS_USED_SHIFT 0
/*
 * Coalescing ACTIVE FSM state indication.
 * Reset: 0x0         Access: RO
 */
#define UDMA_S2M_SEL_COMP_FIFO_STATUS_COAL_ACTIVE_STATE_MASK 0x00300000
#define UDMA_S2M_SEL_COMP_FIFO_STATUS_COAL_ACTIVE_STATE_SHIFT 20
/*
 * FIFO empty indication
 * Reset: 0x0         Access: RO
 */
#define UDMA_S2M_SEL_COMP_FIFO_STATUS_EMPTY (1 << 24)
#define UDMA_S2M_SEL_COMP_FIFO_STATUS_EMPTY_MASK 0x01000000
#define UDMA_S2M_SEL_COMP_FIFO_STATUS_EMPTY_SHIFT 24
/*
 * FIFO full indication
 * Reset: 0x0         Access: RO
 */
#define UDMA_S2M_SEL_COMP_FIFO_STATUS_FULL (1 << 28)
#define UDMA_S2M_SEL_COMP_FIFO_STATUS_FULL_MASK 0x10000000
#define UDMA_S2M_SEL_COMP_FIFO_STATUS_FULL_SHIFT 28

/**** clear_ctrl register ****/
/* Reset: 0x0         Access: RW */
#define UDMA_S2M_CLEAR_CTRL_RESERVED_31_0_MASK 0xFFFFFFFF
#define UDMA_S2M_CLEAR_CTRL_RESERVED_31_0_SHIFT 0

/**** check_en register ****/
/*
 * bit0 - mask packet len err
 * bit 1 - mask rx stream data err
 * bit 2 - mask rx hdr data err
 * bit 3 - mask rx data parity error
 * Reset: 0x1         Access: RW
 */
#define UDMA_S2M_CHECK_EN_EN_MASK    0xFFFFFFFF
#define UDMA_S2M_CHECK_EN_EN_SHIFT   0

/**** fifo_en register ****/
/* Reset: 0xffffffff  Access: RW */
#define UDMA_S2M_FIFO_EN_EN_MASK     0xFFFFFFFF
#define UDMA_S2M_FIFO_EN_EN_SHIFT    0

/**** stream_cfg register ****/
/*
 * Disables the stream interface operation.
 * Changing to 1 stops at the end of packet reception.
 * Reset: 0x0         Access: RW
 */
#define UDMA_S2M_STREAM_CFG_DISABLE_STREAM (1 << 0)
#define UDMA_S2M_STREAM_CFG_DISABLE_STREAM_MASK 0x00000001
#define UDMA_S2M_STREAM_CFG_DISABLE_STREAM_SHIFT 0
/*
 * Flush the stream interface operation.
 * Changing to 1 stops at the end of packet reception and assert ready to the stream I/F.
 * Reset: 0x0         Access: RW
 */
#define UDMA_S2M_STREAM_CFG_FLUSH    (1 << 4)
#define UDMA_S2M_STREAM_CFG_FLUSH_MASK 0x00000010
#define UDMA_S2M_STREAM_CFG_FLUSH_SHIFT 4
/*
 * Stop descriptor prefetch when the stream is disabled and the S2M is idle.
 * Reset: 0x0         Access: RW
 */
#define UDMA_S2M_STREAM_CFG_STOP_PREFETCH (1 << 8)
#define UDMA_S2M_STREAM_CFG_STOP_PREFETCH_MASK 0x00000100
#define UDMA_S2M_STREAM_CFG_STOP_PREFETCH_SHIFT 8

/**** pref_queue_en register ****/
/*
 * Queue Enable
 * Reset: 0xffff      Access: RW
 */
#define UDMA_S2M_PREF_QUEUE_EN_EN_MASK 0x0000FFFF
#define UDMA_S2M_PREF_QUEUE_EN_EN_SHIFT 0

/**************************************************************************************************
 * udma_s2m_rd
 *
 * S2M descriptor read  configuration
 **************************************************************************************************/
struct udma_s2m_rd {
	/* [0x0] S2M descriptor prefetch configuration */
	uint32_t desc_pref_cfg_1;
	/* [0x4] S2M descriptor prefetch configuration */
	uint32_t desc_pref_cfg_2;
	/* [0x8] S2M descriptor prefetch configuration */
	uint32_t desc_pref_cfg_3;
	/* [0xc] S2M descriptor prefetch configuration */
	uint32_t desc_pref_cfg_4;
	/* [0x10] */
	uint32_t rsrvd_0[12];
};

/**** desc_pref_cfg_2 register ****/
/*
 * Enable promotion of the current queue in progress
 * Reset: 0x1         Access: RW
 */
#define UDMA_S2M_RD_DESC_PREF_CFG_2_Q_PROMOTION (1 << 0)
#define UDMA_S2M_RD_DESC_PREF_CFG_2_Q_PROMOTION_MASK 0x00000001
#define UDMA_S2M_RD_DESC_PREF_CFG_2_Q_PROMOTION_SHIFT 0
/*
 * Force promotion of the current queue in progress
 * Reset: 0x1         Access: RW
 */
#define UDMA_S2M_RD_DESC_PREF_CFG_2_FORCE_PROMOTION (1 << 1)
#define UDMA_S2M_RD_DESC_PREF_CFG_2_FORCE_PROMOTION_MASK 0x00000002
#define UDMA_S2M_RD_DESC_PREF_CFG_2_FORCE_PROMOTION_SHIFT 1
/*
 * Enable prefetch prediction of next packet in line.
 * Reset: 0x1         Access: RW
 */
#define UDMA_S2M_RD_DESC_PREF_CFG_2_EN_PREF_PREDICTION (1 << 2)
#define UDMA_S2M_RD_DESC_PREF_CFG_2_EN_PREF_PREDICTION_MASK 0x00000004
#define UDMA_S2M_RD_DESC_PREF_CFG_2_EN_PREF_PREDICTION_SHIFT 2
/*
 * Threshold for queue promotion.
 * Queue is promoted for prefetch if there are less descriptors in the prefetch FIFO than the
 * threshold
 * Reset: 0x4         Access: RW
 */
#define UDMA_S2M_RD_DESC_PREF_CFG_2_PROMOTION_TH_MASK 0x0000FF00
#define UDMA_S2M_RD_DESC_PREF_CFG_2_PROMOTION_TH_SHIFT 8
/*
 * Force RR arbitration in the prefetch arbiter.
 * 0 - Standard arbitration based on queue QoS
 * 1 - Force round robin arbitration
 * Reset: 0x1         Access: RW
 */
#define UDMA_S2M_RD_DESC_PREF_CFG_2_PREF_FORCE_RR (1 << 16)
#define UDMA_S2M_RD_DESC_PREF_CFG_2_PREF_FORCE_RR_MASK 0x00010000
#define UDMA_S2M_RD_DESC_PREF_CFG_2_PREF_FORCE_RR_SHIFT 16

/**** desc_pref_cfg_3 register ****/
/*
 * Minimum descriptor burst size when prefetch FIFO level is below the descriptor prefetch threshold
 * (must be 1)
 * Reset: 0x1         Access: RW
 */
#define UDMA_S2M_RD_DESC_PREF_CFG_3_MIN_BURST_BELOW_THR_MASK 0x0000000F
#define UDMA_S2M_RD_DESC_PREF_CFG_3_MIN_BURST_BELOW_THR_SHIFT 0
/*
 * Minimum descriptor burst size when prefetch FIFO level is above the descriptor prefetch threshold
 * Reset: 0x4         Access: RW
 */
#define UDMA_S2M_RD_DESC_PREF_CFG_3_MIN_BURST_ABOVE_THR_MASK 0x000000F0
#define UDMA_S2M_RD_DESC_PREF_CFG_3_MIN_BURST_ABOVE_THR_SHIFT 4
/*
 * Descriptor fetch threshold.
 * Used as a threshold to determine the allowed minimum descriptor burst size.
 * (Must be at least "max_desc_per_pkt")
 * Reset: 0x8         Access: RW
 */
#define UDMA_S2M_RD_DESC_PREF_CFG_3_PREF_THR_MASK 0x0000FF00
#define UDMA_S2M_RD_DESC_PREF_CFG_3_PREF_THR_SHIFT 8

/**** desc_pref_cfg_4 register ****/
/*
 * Used as a threshold for generating almost FULL indication to the application
 * Reset: 0x8         Access: RW
 */
#define UDMA_S2M_RD_DESC_PREF_CFG_4_A_FULL_THR_MASK 0x0000FFFF
#define UDMA_S2M_RD_DESC_PREF_CFG_4_A_FULL_THR_SHIFT 0

/**************************************************************************************************
 * udma_s2m_wr
 *
 * S2M data write  configuration
 **************************************************************************************************/
struct udma_s2m_wr {
	/* [0x0] Stream data FIFO configuration */
	uint32_t data_cfg_1;
	/* [0x4] Data write configuration */
	uint32_t data_cfg_2;
	/* [0x8] */
	uint32_t data_cfg_3;
	/* [0xc] FE opeating rx desc to detect flush marker */
	struct al_cell_fe_regs flush_marker_fe;
	/* [0x10] */
	uint32_t rsrvd_0[12];
};

/**** data_cfg_1 register ****/
/*
 * Maximum number of data beats in the data write FIFO.
 * Defined based on data FIFO size
 * (default FIFO size 512B  32 beats)
 * Reset: 0x40        Access: RW
 */
#define UDMA_S2M_WR_DATA_CFG_1_DATA_FIFO_DEPTH_MASK 0x000003FF
#define UDMA_S2M_WR_DATA_CFG_1_DATA_FIFO_DEPTH_SHIFT 0
/*
 * Maximum number of packets in the data write FIFO.
 * Defined based on header FIFO size
 * Reset: 0x20        Access: RW
 */
#define UDMA_S2M_WR_DATA_CFG_1_MAX_PKT_LIMIT_MASK 0x00FF0000
#define UDMA_S2M_WR_DATA_CFG_1_MAX_PKT_LIMIT_SHIFT 16
/*
 * Internal use
 * Data FIFO margin
 * Reset: 0x0         Access: RW
 */
#define UDMA_S2M_WR_DATA_CFG_1_FIFO_MARGIN_MASK 0xFF000000
#define UDMA_S2M_WR_DATA_CFG_1_FIFO_MARGIN_SHIFT 24

/**** data_cfg_2 register ****/
/*
 * Drop timer.
 * Waiting time for the host to write new descriptor to the queue
 * (for the current packet in process)
 * Reset: 0x2710      Access: RW
 */
#define UDMA_S2M_WR_DATA_CFG_2_DESC_WAIT_TIMER_MASK 0x00FFFFFF
#define UDMA_S2M_WR_DATA_CFG_2_DESC_WAIT_TIMER_SHIFT 0
/*
 * When set, wait_for_pref register ignored,
 * and when timeout pop and no desc -  drop packet (dont care if they are desc in ring/host)
 * Reset: 0x0         Access: RW
 */
#define UDMA_S2M_WR_DATA_CFG_2_FORCE_DROP_NO_WAIT (1 << 24)
#define UDMA_S2M_WR_DATA_CFG_2_FORCE_DROP_NO_WAIT_MASK 0x01000000
#define UDMA_S2M_WR_DATA_CFG_2_FORCE_DROP_NO_WAIT_SHIFT 24
/*
 * Drop enable.
 * Enable packet drop if there are no available descriptors in the system for this queue
 * Reset: 0x0         Access: RW
 */
#define UDMA_S2M_WR_DATA_CFG_2_DROP_IF_NO_DESC (1 << 27)
#define UDMA_S2M_WR_DATA_CFG_2_DROP_IF_NO_DESC_MASK 0x08000000
#define UDMA_S2M_WR_DATA_CFG_2_DROP_IF_NO_DESC_SHIFT 27
/*
 * Lack of descriptors hint.
 * Generate interrupt when a packet is waiting but there are no available descriptors in the queue
 * Reset: 0x1         Access: RW
 */
#define UDMA_S2M_WR_DATA_CFG_2_HINT_IF_NO_DESC (1 << 28)
#define UDMA_S2M_WR_DATA_CFG_2_HINT_IF_NO_DESC_MASK 0x10000000
#define UDMA_S2M_WR_DATA_CFG_2_HINT_IF_NO_DESC_SHIFT 28
/*
 * Drop conditions
 * Wait until a descriptor is available in the prefetch FIFO or the host before dropping packet.
 * 1 - Drop if a descriptor is not available in the prefetch.
 * 0 - Drop if a descriptor is not available in the system
 * Reset: 0x1         Access: RW
 */
#define UDMA_S2M_WR_DATA_CFG_2_WAIT_FOR_PREF (1 << 29)
#define UDMA_S2M_WR_DATA_CFG_2_WAIT_FOR_PREF_MASK 0x20000000
#define UDMA_S2M_WR_DATA_CFG_2_WAIT_FOR_PREF_SHIFT 29
/*
 * DRAM write optimization
 * 0 - Data write with byte enable
 * 1 - Data write is always in Full AXI bus width (128 bit)
 * Reset: 0x0         Access: RW
 */
#define UDMA_S2M_WR_DATA_CFG_2_FULL_LINE_MODE (1 << 30)
#define UDMA_S2M_WR_DATA_CFG_2_FULL_LINE_MODE_MASK 0x40000000
#define UDMA_S2M_WR_DATA_CFG_2_FULL_LINE_MODE_SHIFT 30
/*
 * Direct data write address
 * 1 - Use buffer 1 instead of buffer 2 when direct data placement is used with header split.
 * 0 - Use buffer 2 for the header.
 * Reset: 0x0         Access: RW
 */
#define UDMA_S2M_WR_DATA_CFG_2_DIRECT_HDR_USE_BUF1 (1 << 31)
#define UDMA_S2M_WR_DATA_CFG_2_DIRECT_HDR_USE_BUF1_MASK 0x80000000
#define UDMA_S2M_WR_DATA_CFG_2_DIRECT_HDR_USE_BUF1_SHIFT 31

/**** data_cfg_3 register ****/
/*
 * Fix BUG of buffer cross 4G boundary
 * Reset: 0x1         Access: RW
 */
#define UDMA_S2M_WR_DATA_CFG_3_BUG_FIX_4G_EN (1 << 0)
#define UDMA_S2M_WR_DATA_CFG_3_BUG_FIX_4G_EN_MASK 0x00000001
#define UDMA_S2M_WR_DATA_CFG_3_BUG_FIX_4G_EN_SHIFT 0
/*
 * Enable to override incoming queue
 * Reset: 0x0         Access: RW
 */
#define UDMA_S2M_WR_DATA_CFG_3_QUEUE_OVERRIDE_EN (1 << 2)
#define UDMA_S2M_WR_DATA_CFG_3_QUEUE_OVERRIDE_EN_MASK 0x00000004
#define UDMA_S2M_WR_DATA_CFG_3_QUEUE_OVERRIDE_EN_SHIFT 2
/*
 * Queue value to override
 * Reset: 0x0         Access: RW
 */
#define UDMA_S2M_WR_DATA_CFG_3_OVERRIDE_VAL_MASK 0x000000F0
#define UDMA_S2M_WR_DATA_CFG_3_OVERRIDE_VAL_SHIFT 4

/**************************************************************************************************
 * udma_s2m_comp
 *
 * S2M completion control configuration
 **************************************************************************************************/
struct udma_s2m_comp {
	/* [0x0] Completion controller configuration */
	uint32_t cfg_1c;
	/* [0x4] Completion controller configuration */
	uint32_t cfg_2c;
	/* [0x8] */
	uint32_t rsrvd_0;
	/* [0xc] Completion controller application acknowledge configuration */
	uint32_t cfg_application_ack;
	/* [0x10] */
	uint32_t rsrvd_1[12];
};

/**** cfg_1c register ****/
/*
 * Completion descriptor size.
 * (words)
 * Reset: 0x4         Access: RW
 */
#define UDMA_S2M_COMP_CFG_1C_DESC_SIZE_MASK 0x0000000F
#define UDMA_S2M_COMP_CFG_1C_DESC_SIZE_SHIFT 0
/*
 * Completion queue counter configuration.
 * Completion FIFO in use counter measured in words or descriptors
 * 1 - Words
 * 0 - Descriptors
 * Reset: 0x0         Access: RW
 */
#define UDMA_S2M_COMP_CFG_1C_CNT_WORDS (1 << 8)
#define UDMA_S2M_COMP_CFG_1C_CNT_WORDS_MASK 0x00000100
#define UDMA_S2M_COMP_CFG_1C_CNT_WORDS_SHIFT 8
/*
 * Enable promotion of the current queue in progress in the completion write scheduler.
 * Reset: 0x1         Access: RW
 */
#define UDMA_S2M_COMP_CFG_1C_Q_PROMOTION (1 << 12)
#define UDMA_S2M_COMP_CFG_1C_Q_PROMOTION_MASK 0x00001000
#define UDMA_S2M_COMP_CFG_1C_Q_PROMOTION_SHIFT 12
/*
 * Qualified when cmpl_queue_wr_en  is '0'
 * When '0' - NO cmpl will be sent over AXI and YES crhp update (AL7/AL8 mode)
 * When '1' - NO cmpl will be sent over AXI and NO rcrhp update (Tonga new mode)
 * Reset: 0x0         Access: RW
 */
#define UDMA_S2M_COMP_CFG_1C_BLOCK_RCRHP_UPD (1 << 13)
#define UDMA_S2M_COMP_CFG_1C_BLOCK_RCRHP_UPD_MASK 0x00002000
#define UDMA_S2M_COMP_CFG_1C_BLOCK_RCRHP_UPD_SHIFT 13
/*
 * Force RR arbitration in the completion arbiter
 * Reset: 0x0         Access: RW
 */
#define UDMA_S2M_COMP_CFG_1C_FORCE_RR (1 << 16)
#define UDMA_S2M_COMP_CFG_1C_FORCE_RR_MASK 0x00010000
#define UDMA_S2M_COMP_CFG_1C_FORCE_RR_SHIFT 16
/*
 * Minimum number of free completion entries to qualify for promotion
 * Reset: 0x0         Access: RW
 */
#define UDMA_S2M_COMP_CFG_1C_Q_FREE_MIN_MASK 0xF0000000
#define UDMA_S2M_COMP_CFG_1C_Q_FREE_MIN_SHIFT 28

/**** cfg_2c register ****/
/*
 * Completion FIFO size.
 * (words per queue)
 * Reset: 0x80        Access: RW
 */
#define UDMA_S2M_COMP_CFG_2C_COMP_FIFO_DEPTH_MASK 0x00000FFF
#define UDMA_S2M_COMP_CFG_2C_COMP_FIFO_DEPTH_SHIFT 0
/*
 * Unacknowledged FIFO size.
 * (descriptors)
 * Reset: 0x80        Access: RW
 */
#define UDMA_S2M_COMP_CFG_2C_UNACK_FIFO_DEPTH_MASK 0x0FFF0000
#define UDMA_S2M_COMP_CFG_2C_UNACK_FIFO_DEPTH_SHIFT 16

/**** cfg_application_ack register ****/
/*
 * Acknowledge timeout timer.
 * ACK from the application through the stream interface)
 * Reset: 0x186a0     Access: RW
 */
#define UDMA_S2M_COMP_CFG_APPLICATION_ACK_TOUT_MASK 0xFFFFFFFF
#define UDMA_S2M_COMP_CFG_APPLICATION_ACK_TOUT_SHIFT 0

/**************************************************************************************************
 * udma_s2m_stat
 *
 * S2M statistics
 **************************************************************************************************/
struct udma_s2m_stat {
	/* [0x0] */
	uint32_t rsrvd_0;
	/* [0x4] Number of dropped packets */
	uint32_t drop_pkt;
	/*
	 * [0x8] Counting the net length of the data buffers [64-bit]
	 * Should be read before rx_bytes_high
	 */
	uint32_t rx_bytes_low;
	/*
	 * [0xc] Counting the net length of the data buffers [64-bit]
	 * Should be read after  tx_bytes_low (value is sampled when reading Should be read before
	 * rx_bytes_low
	 */
	uint32_t rx_bytes_high;
	/* [0x10] Total number of descriptors read from the host memory */
	uint32_t prefed_desc;
	/* [0x14] Number of packets written into the completion ring */
	uint32_t comp_pkt;
	/* [0x18] Number of descriptors written into the completion ring */
	uint32_t comp_desc;
	/*
	 * [0x1c] Number of acknowledged packets.
	 * (acknowledge sent to the stream interface)
	 */
	uint32_t ack_pkts;
	/* [0x20] */
	uint32_t rsrvd_1[56];
};

/**** drop_pkt register ****/
/*
 * Number of dropped packets
 * Reset: 0x0         Access: RO, RtoClr
 */
#define UDMA_S2M_STAT_DROP_PKT_CNT_MASK 0xFFFFFFFF
#define UDMA_S2M_STAT_DROP_PKT_CNT_SHIFT 0

/**** rx_bytes_low register ****/
/*
 * Counter bits [31:0]
 * Reset: 0x0         Access: RO, RtoClr
 */
#define UDMA_S2M_STAT_RX_BYTES_LOW_CNT_MASK 0xFFFFFFFF
#define UDMA_S2M_STAT_RX_BYTES_LOW_CNT_SHIFT 0

/**** rx_bytes_high register ****/
/*
 * Counter bits [63:32]
 * Reset: 0x0         Access: RO, RtoClr
 */
#define UDMA_S2M_STAT_RX_BYTES_HIGH_CNT_MASK 0xFFFFFFFF
#define UDMA_S2M_STAT_RX_BYTES_HIGH_CNT_SHIFT 0

/**** prefed_desc register ****/
/*
 * Total number of descriptors read from the host memory
 * Reset: 0x0         Access: RO, RtoClr
 */
#define UDMA_S2M_STAT_PREFED_DESC_CNT_MASK 0xFFFFFFFF
#define UDMA_S2M_STAT_PREFED_DESC_CNT_SHIFT 0

/**** comp_pkt register ****/
/*
 * Number of packets written into the completion ring
 * Reset: 0x0         Access: RO, RtoClr
 */
#define UDMA_S2M_STAT_COMP_PKT_CNT_MASK 0xFFFFFFFF
#define UDMA_S2M_STAT_COMP_PKT_CNT_SHIFT 0

/**** comp_desc register ****/
/*
 * Number of descriptors written into the completion ring
 * Reset: 0x0         Access: RO, RtoClr
 */
#define UDMA_S2M_STAT_COMP_DESC_CNT_MASK 0xFFFFFFFF
#define UDMA_S2M_STAT_COMP_DESC_CNT_SHIFT 0

/**** ack_pkts register ****/
/*
 * Number of acknowledged packets.
 * (acknowledge sent to the stream interface)
 * Reset: 0x0         Access: RO, RtoClr
 */
#define UDMA_S2M_STAT_ACK_PKTS_CNT_MASK 0xFFFFFFFF
#define UDMA_S2M_STAT_ACK_PKTS_CNT_SHIFT 0

/**************************************************************************************************
 * udma_s2m_feature
 *
 * S2M Feature registers
 **************************************************************************************************/
struct udma_s2m_feature {
	/*
	 * [0x0] S2M Feature register
	 * S2M instantiation parameters
	 */
	uint32_t reg_1;
	/* [0x4] Reserved S2M feature register */
	uint32_t reg_2;
	/*
	 * [0x8] S2M Feature register
	 * S2M instantiation parameters
	 */
	uint32_t reg_3;
	/*
	 * [0xc] S2M Feature register.
	 * S2M instantiation parameters.
	 */
	uint32_t reg_4;
	/*
	 * [0x10] S2M Feature register.
	 * S2M instantiation parameters.
	 */
	uint32_t reg_5;
	/* [0x14] S2M Feature register. S2M instantiation parameters. */
	uint32_t reg_6;
	/* [0x18] */
	uint32_t rsrvd_0[58];
};

/**** reg_1 register ****/
/*
 * Descriptor prefetch FIFO size
 * (descriptors)
 * Reset: 0x400       Access: RW, WInit
 */
#define UDMA_S2M_FEATURE_REG_1_DESC_PREFERCH_FIFO_DEPTH_MASK 0x00000FFF
#define UDMA_S2M_FEATURE_REG_1_DESC_PREFERCH_FIFO_DEPTH_SHIFT 0

/**** reg_2 register ****/
/* Reset: 0x0         Access: RW, WInit */
#define UDMA_S2M_FEATURE_REG_2_RESERVED_31_0_MASK 0xFFFFFFFF
#define UDMA_S2M_FEATURE_REG_2_RESERVED_31_0_SHIFT 0

/**** reg_3 register ****/
/*
 * Maximum number of data beats in the data write FIFO.
 * Defined based on data FIFO size
 * (default FIFO size 2KB 32 beats)
 * Reset: 0x40        Access: RW, WInit
 */
#define UDMA_S2M_FEATURE_REG_3_DATA_FIFO_DEPTH_MASK 0x00000FFF
#define UDMA_S2M_FEATURE_REG_3_DATA_FIFO_DEPTH_SHIFT 0
/*
 * Maximum number of packets in the data write FIFO.
 * Defined based on header FIFO size
 * Reset: 0x100       Access: RW, WInit
 */
#define UDMA_S2M_FEATURE_REG_3_DATA_WR_MAX_PKT_LIMIT_MASK 0x0FFF0000
#define UDMA_S2M_FEATURE_REG_3_DATA_WR_MAX_PKT_LIMIT_SHIFT 16

/**** reg_4 register ****/
/*
 * Completion FIFO size.
 * (words per queue)
 * Reset: 0x80        Access: RW, WInit
 */
#define UDMA_S2M_FEATURE_REG_4_COMP_FIFO_DEPTH_MASK 0x00000FFF
#define UDMA_S2M_FEATURE_REG_4_COMP_FIFO_DEPTH_SHIFT 0
/*
 * Unacknowledged FIFO size.
 * (descriptors)
 * Reset: 0x80        Access: RW, WInit
 */
#define UDMA_S2M_FEATURE_REG_4_COMP_UNACK_FIFO_DEPTH_MASK 0x0FFF0000
#define UDMA_S2M_FEATURE_REG_4_COMP_UNACK_FIFO_DEPTH_SHIFT 16

/**** reg_5 register ****/
/*
 * Maximum number of outstanding data writes to the AXI - up to 128
 * Reset: 0x20        Access: RW, WInit
 */
#define UDMA_S2M_FEATURE_REG_5_MAX_DATA_WR_OSTAND_MASK 0x000000FF
#define UDMA_S2M_FEATURE_REG_5_MAX_DATA_WR_OSTAND_SHIFT 0
/*
 * Maximum number of outstanding data beats for data write to AXI.
 * (AXI beats) - up to 64
 * Reset: 0x40        Access: RW, WInit
 */
#define UDMA_S2M_FEATURE_REG_5_MAX_DATA_BEATS_WR_OSTAND_MASK 0x0000FF00
#define UDMA_S2M_FEATURE_REG_5_MAX_DATA_BEATS_WR_OSTAND_SHIFT 8
/*
 * Maximum number of outstanding descriptor reads to the AXI.
 * (AXI transactions) - up to 128
 * Reset: 0x20        Access: RW, WInit
 */
#define UDMA_S2M_FEATURE_REG_5_MAX_COMP_REQ_MASK 0x00FF0000
#define UDMA_S2M_FEATURE_REG_5_MAX_COMP_REQ_SHIFT 16
/*
 * Maximum number of outstanding data beats for descriptor write to AXI.
 * (AXI beats) - up to 64
 * Reset: 0x40        Access: RW, WInit
 */
#define UDMA_S2M_FEATURE_REG_5_MAX_COMP_DATA_WR_OSTAND_MASK 0xFF000000
#define UDMA_S2M_FEATURE_REG_5_MAX_COMP_DATA_WR_OSTAND_SHIFT 24

/**** reg_6 register ****/
/*
 * Maximum number of outstanding descriptor reads to the AXI - up to 128
 * Reset: 0x20        Access: RW, WInit
 */
#define UDMA_S2M_FEATURE_REG_6_MAX_DESC_RD_OSTAND_MASK 0x000000FF
#define UDMA_S2M_FEATURE_REG_6_MAX_DESC_RD_OSTAND_SHIFT 0
/*
 * Maximum number of outstanding stream acknowledges
 * Reset: 0x40        Access: RW, WInit
 */
#define UDMA_S2M_FEATURE_REG_6_MAX_STREAM_ACK_MASK 0x00FF0000
#define UDMA_S2M_FEATURE_REG_6_MAX_STREAM_ACK_SHIFT 16

/**************************************************************************************************
 * udma_s2m_shadow_access_shadow_index
 **************************************************************************************************/
struct udma_s2m_shadow_access_shadow_index {
	/* [0x0] */
	uint32_t rd_permission;
	/* [0x4] */
	uint32_t wr_permission;
};

/**** rd_permission register ****/
/* Reset: 0x0         Access: RW */
#define UDMA_S2M_SHADOW_ACCESS_SHADOW_INDEX_RD_PERMISSION_DATA_MASK 0xFFFFFFFF
#define UDMA_S2M_SHADOW_ACCESS_SHADOW_INDEX_RD_PERMISSION_DATA_SHIFT 0

/**** wr_permission register ****/
/* Reset: 0x0         Access: RW */
#define UDMA_S2M_SHADOW_ACCESS_SHADOW_INDEX_WR_PERMISSION_DATA_MASK 0xFFFFFFFF
#define UDMA_S2M_SHADOW_ACCESS_SHADOW_INDEX_WR_PERMISSION_DATA_SHIFT 0

/**************************************************************************************************
 * udma_s2m_shadow_access
 **************************************************************************************************/
struct udma_s2m_shadow_access {
	/* [0x0] */
	struct udma_s2m_shadow_access_shadow_index shadow_index[32];
};

/**************************************************************************************************
 * udma_s2m_q_fill_th
 *
 * 4*Queue fill level cfg  -
 * 4 sets of queue level cfg to calcualte rx desc fill level for ETH.
 * each sets include 4 level (hysteresis)
 **************************************************************************************************/
struct udma_s2m_q_fill_th {
	/* [0x0] current level is a & (number of desc > level_a_high)- > next_level = level_b */
	uint32_t level_a_high;
	/* [0x4] current level is b & (number of desc < level_b_low) - > next_level = level_a */
	uint32_t level_a_low;
	/* [0x8] current level is b & (number of desc > level_c_high) - > next_level = level_c */
	uint32_t level_b_high;
	/* [0xc] current level is c & (number of desc < level_b_low)  - > next_level = level_a */
	uint32_t level_b_low;
	/* [0x10] current level is c & (number of desc > level_c_high) - > next_level = level_c */
	uint32_t level_c_high;
	/*
	 * [0x14] current level is d & (number of desc < level_c_low)
	 * - > next_level = level_c
	 */
	uint32_t level_c_low;
};

/**** level_a_high register ****/
/* Reset: 0x0         Access: RW */
#define UDMA_S2M_Q_FILL_TH_LEVEL_A_HIGH_VAL_MASK 0x00FFFFFF
#define UDMA_S2M_Q_FILL_TH_LEVEL_A_HIGH_VAL_SHIFT 0

/**** level_a_low register ****/
/* Reset: 0x0         Access: RW */
#define UDMA_S2M_Q_FILL_TH_LEVEL_A_LOW_VAL_MASK 0x00FFFFFF
#define UDMA_S2M_Q_FILL_TH_LEVEL_A_LOW_VAL_SHIFT 0

/**** level_b_high register ****/
/* Reset: 0x0         Access: RW */
#define UDMA_S2M_Q_FILL_TH_LEVEL_B_HIGH_VAL_MASK 0x00FFFFFF
#define UDMA_S2M_Q_FILL_TH_LEVEL_B_HIGH_VAL_SHIFT 0

/**** level_b_low register ****/
/* Reset: 0x0         Access: RW */
#define UDMA_S2M_Q_FILL_TH_LEVEL_B_LOW_VAL_MASK 0x00FFFFFF
#define UDMA_S2M_Q_FILL_TH_LEVEL_B_LOW_VAL_SHIFT 0

/**** level_c_high register ****/
/* Reset: 0x0         Access: RW */
#define UDMA_S2M_Q_FILL_TH_LEVEL_C_HIGH_VAL_MASK 0x00FFFFFF
#define UDMA_S2M_Q_FILL_TH_LEVEL_C_HIGH_VAL_SHIFT 0

/**** level_c_low register ****/
/* Reset: 0x0         Access: RW */
#define UDMA_S2M_Q_FILL_TH_LEVEL_C_LOW_VAL_MASK 0x00FFFFFF
#define UDMA_S2M_Q_FILL_TH_LEVEL_C_LOW_VAL_SHIFT 0

/**************************************************************************************************
 * udma_s2m_q
 **************************************************************************************************/
struct udma_s2m_q {
	/* [0x0] descriptor prefetch configuration */
	uint32_t desc_pref_cfg;
	/* [0x4] descriptor prefetch configuration */
	uint32_t desc_pref_cfg2;
	/* [0x8] */
	uint32_t rsrvd_0[6];
	/* [0x20] S2M Descriptor ring configuration */
	uint32_t cfg;
	/* [0x24] S2M Descriptor ring status and information */
	uint32_t status;
	/* [0x28] Rx Descriptor Ring Base Pointer [31:6] */
	uint32_t rdrbp_low;
	/* [0x2c] Rx Descriptor Ring Base Pointer [63:32] */
	uint32_t rdrbp_high;
	/* [0x30] Rx Descriptor Ring Length[23:2] */
	uint32_t rdrl;
	/* [0x34] RX Descriptor Ring Head Pointer */
	uint32_t rdrhp;
	/* [0x38] Rx Descriptor Tail Pointer increment */
	uint32_t rdrtp_inc;
	/* [0x3c] Rx Descriptor Tail Pointer */
	uint32_t rdrtp;
	/* [0x40] RX Descriptor Current Pointer */
	uint32_t rdcp;
	/* [0x44] Rx Completion Ring Base Pointer [31:6] */
	uint32_t rcrbp_low;
	/* [0x48] Rx Completion Ring Base Pointer [63:32] */
	uint32_t rcrbp_high;
	/* [0x4c] Rx Completion Ring Head Pointer */
	uint32_t rcrhp;
	/*
	 * [0x50] RX Completion Ring Head Pointer internal.
	 * (Before the coalescing FIFO)
	 */
	uint32_t rcrhp_internal;
	/* [0x54] Completion controller configuration for the queue */
	uint32_t comp_cfg;
	/* [0x58] Completion controller configuration for the queue */
	uint32_t comp_cfg_2;
	/* [0x5c] Packet handler configuration */
	uint32_t pkt_cfg;
	/* [0x60] Queue QoS configuration */
	uint32_t qos_cfg;
	/* [0x64] DMB software control */
	uint32_t q_sw_ctrl;
	/* [0x68] Number of S2M Rx packets after completion */
	uint32_t q_rx_pkt;
	/*
	 * [0x6c] Enable to set Receive descriptor ring to certain value instead of '0' on reset -
	 * should be relevant while doing VM migration and queue should be opened not from zero
	 * state
	 */
	uint32_t rdrtp_set;
	/*
	 * [0x70] Enable to set Receive descriptor ring to certain value instead of '0' on reset -
	 * should be relevant while doing VM migration and queue should be opened not from zero
	 * state
	 */
	uint32_t rdrhp_set;
	/*
	 * [0x74] 4*Queue fill level cfg  -
	 * 4 sets of queue level cfg to calcualte rx desc fill level for ETH.
	 * each sets include 4 level (hysteresis)
	 */
	struct udma_s2m_q_fill_th fill_th[4];
	/* [0xd4] */
	uint32_t rsrvd_1[971];
};

/**** desc_pref_cfg register ****/
/*
 * Size of the descriptor prefetch FIFO (in descriptors)
 * Reset: 0x80        Access: RW
 */
#define UDMA_S2M_Q_DESC_PREF_CFG_FIFO_DEPTH_MASK 0x00000FFF
#define UDMA_S2M_Q_DESC_PREF_CFG_FIFO_DEPTH_SHIFT 0
/*
 * Size of the descriptor prefetch FIFO (in descriptors)
 * Reset: Variable    Access: RW
 *  Index    ResetValue
 *  0        0x0
 *  1        0x80
 *  2        0x100
 *  3        0x180
 *  4        0x200
 *  5        0x280
 *  6        0x300
 *  7        0x380
 *  8        0x400
 *  9        0x480
 *  10       0x500
 *  11       0x580
 *  12       0x600
 *  13       0x680
 *  14       0x700
 *  15       0x780
 */
#define UDMA_S2M_Q_DESC_PREF_CFG_FIFO_START_ADDR_MASK 0x07FF0000
#define UDMA_S2M_Q_DESC_PREF_CFG_FIFO_START_ADDR_SHIFT 16

/**** desc_pref_cfg2 register ****/
/*
 * Size of the descriptor prefetch FIFO (in descriptors)
 * Reset: Variable    Access: RW
 *  Index    ResetValue
 *  0        0x7f
 *  1        0xff
 *  2        0x17f
 *  3        0x1ff
 *  4        0x27f
 *  5        0x2ff
 *  6        0x37f
 *  7        0x3ff
 *  8        0x47f
 *  9        0x4ff
 *  10       0x57f
 *  11       0x5ff
 *  12       0x67f
 *  13       0x6ff
 *  14       0x77f
 *  15       0x7ff
 */
#define UDMA_S2M_Q_DESC_PREF_CFG2_FIFO_END_ADDR_MASK 0x000007FF
#define UDMA_S2M_Q_DESC_PREF_CFG2_FIFO_END_ADDR_SHIFT 0

/**** cfg register ****/
/*
 * Configure the AXI AWCACHE
 * for header write.
 * Reset: 0x3         Access: RW
 */
#define UDMA_S2M_Q_CFG_AXI_AWCACHE_HDR_MASK 0x0000000F
#define UDMA_S2M_Q_CFG_AXI_AWCACHE_HDR_SHIFT 0
/*
 * Configure the AXI AWCACHE
 * for data write.
 * Reset: 0x3         Access: RW
 */
#define UDMA_S2M_Q_CFG_AXI_AWCACHE_DATA_MASK 0x000000F0
#define UDMA_S2M_Q_CFG_AXI_AWCACHE_DATA_SHIFT 4
/*
 * Enable operation of this queue.
 * Start prefetch.
 * Reset: 0x0         Access: RW
 */
#define UDMA_S2M_Q_CFG_EN_PREF       (1 << 16)
#define UDMA_S2M_Q_CFG_EN_PREF_MASK  0x00010000
#define UDMA_S2M_Q_CFG_EN_PREF_SHIFT 16
/*
 * Enables the reception of packets from the stream to this queue
 * Reset: 0x0         Access: RW
 */
#define UDMA_S2M_Q_CFG_EN_STREAM     (1 << 17)
#define UDMA_S2M_Q_CFG_EN_STREAM_MASK 0x00020000
#define UDMA_S2M_Q_CFG_EN_STREAM_SHIFT 17
/*
 * Allow prefetch of less than minimum prefetch burst size.
 * Reset: 0x0         Access: RW
 */
#define UDMA_S2M_Q_CFG_ALLOW_LT_MIN_PREF (1 << 20)
#define UDMA_S2M_Q_CFG_ALLOW_LT_MIN_PREF_MASK 0x00100000
#define UDMA_S2M_Q_CFG_ALLOW_LT_MIN_PREF_SHIFT 20
/*
 * Data write force full line write. If partial, repeat pre-start with the old data and fill
 * post-end with previous ring-id indicator.
 * Reset: 0x0         Access: RW
 */
#define UDMA_S2M_Q_CFG_DATA_FORCE_FULL_LINE (1 << 23)
#define UDMA_S2M_Q_CFG_DATA_FORCE_FULL_LINE_MASK 0x00800000
#define UDMA_S2M_Q_CFG_DATA_FORCE_FULL_LINE_SHIFT 23
/*
 * Configure the AXI AWCACHE
 * for completion descriptor write
 * Reset: 0x3         Access: RW
 */
#define UDMA_S2M_Q_CFG_AXI_AWCACHE_COMP_MASK 0x0F000000
#define UDMA_S2M_Q_CFG_AXI_AWCACHE_COMP_SHIFT 24
/*
 * AXI QoS
 * This value is used in AXI transactions associated with this queue and the prefetch and completion
 * arbiters.
 * Reset: 0x0         Access: RW
 */
#define UDMA_S2M_Q_CFG_AXI_QOS_MASK  0x70000000
#define UDMA_S2M_Q_CFG_AXI_QOS_SHIFT 28
/*
 * Completion write force full line write. If partial, repeat pre-start with the old data and fill
 * post-end with previous ring-id indicator.
 * Reset: 0x0         Access: RW
 */
#define UDMA_S2M_Q_CFG_CMPL_FORCE_FULL_LINE (1 << 31)
#define UDMA_S2M_Q_CFG_CMPL_FORCE_FULL_LINE_MASK 0x80000000
#define UDMA_S2M_Q_CFG_CMPL_FORCE_FULL_LINE_SHIFT 31

/**** status register ****/
/*
 * Indicates how many entries are used in the Queue
 * Reset: 0x0         Access: RO
 */
#define UDMA_S2M_Q_STATUS_Q_USED_MASK 0x01FFFFFF
#define UDMA_S2M_Q_STATUS_Q_USED_SHIFT 0
/*
 * prefetch status
 * 0 - prefetch operation is stopped
 * 1 - prefetch is operational
 * Reset: 0x0         Access: RO
 */
#define UDMA_S2M_Q_STATUS_PREFETCH   (1 << 28)
#define UDMA_S2M_Q_STATUS_PREFETCH_MASK 0x10000000
#define UDMA_S2M_Q_STATUS_PREFETCH_SHIFT 28
/*
 * Queue receive status
 * 0 -queue RX operation is stopped
 * 1 - RX queue is active and processing packets
 * Reset: 0x0         Access: RO
 */
#define UDMA_S2M_Q_STATUS_RX         (1 << 29)
#define UDMA_S2M_Q_STATUS_RX_MASK    0x20000000
#define UDMA_S2M_Q_STATUS_RX_SHIFT   29
/*
 * Indicates if the queue is full.
 * (Used by the host when head pointer equals tail pointer)
 * Reset: 0x0         Access: RO
 */
#define UDMA_S2M_Q_STATUS_Q_FULL     (1 << 31)
#define UDMA_S2M_Q_STATUS_Q_FULL_MASK 0x80000000
#define UDMA_S2M_Q_STATUS_Q_FULL_SHIFT 31

/**** rdrbp_low register ****/
/*
 * S2M Descriptor Ring Base address [31:6].
 * Value of the base address of the S2M descriptor ring
 * [5:0] - 0 - 64B alignment is enforced
 * ([11:6] should be 0 for 4KB alignment)
 * Reset: 0x1         Access: RW
 */
#define UDMA_S2M_Q_RDRBP_LOW_ADDR_MASK 0xFFFFFFC0
#define UDMA_S2M_Q_RDRBP_LOW_ADDR_SHIFT 6

/**** rdrbp_high register ****/
/*
 * Value of the base address of the S2M descriptor ring
 * Reset: 0x0         Access: RW
 */
#define UDMA_S2M_Q_RDRBP_HIGH_ADDR_MASK 0xFFFFFFFF
#define UDMA_S2M_Q_RDRBP_HIGH_ADDR_SHIFT 0

/**** rdrl register ****/
/*
 * Length of the descriptor ring.
 * (descriptors)
 * Associated with the ring base address ends at maximum burst size alignment
 * Reset: 0x0         Access: RW
 */
#define UDMA_S2M_Q_RDRL_OFFSET_MASK  0x00FFFFFF
#define UDMA_S2M_Q_RDRL_OFFSET_SHIFT 0

/**** rdrhp register ****/
/*
 * Relative offset of the next descriptor that needs to be read into the prefetch FIFO.
 * Incremented when the DMA reads valid descriptors from the host memory to the prefetch FIFO.
 * Note that this is the offset in # of descriptors and not in byte address.
 * Reset: 0x0         Access: RO
 */
#define UDMA_S2M_Q_RDRHP_OFFSET_MASK 0x00FFFFFF
#define UDMA_S2M_Q_RDRHP_OFFSET_SHIFT 0
/*
 * Ring ID
 * Reset: 0x1         Access: RO
 */
#define UDMA_S2M_Q_RDRHP_RING_ID_MASK 0xC0000000
#define UDMA_S2M_Q_RDRHP_RING_ID_SHIFT 30

/**** rdrtp_inc register ****/
/*
 * Increments the value in Q_RDRTP with the value written to this field in number of descriptors.
 * Reset: 0x0         Access: RW
 */
#define UDMA_S2M_Q_RDRTP_INC_VAL_MASK 0x00FFFFFF
#define UDMA_S2M_Q_RDRTP_INC_VAL_SHIFT 0

/**** rdrtp register ****/
/*
 * Relative offset of the next free descriptor in the host memory.
 * Note that this is the offset in # of descriptors and not in byte address.
 * Reset: 0x0         Access: RO
 */
#define UDMA_S2M_Q_RDRTP_OFFSET_MASK 0x00FFFFFF
#define UDMA_S2M_Q_RDRTP_OFFSET_SHIFT 0
/*
 * Ring ID
 * Reset: 0x1         Access: RO
 */
#define UDMA_S2M_Q_RDRTP_RING_ID_MASK 0xC0000000
#define UDMA_S2M_Q_RDRTP_RING_ID_SHIFT 30

/**** rdcp register ****/
/*
 * Relative offset of the first descriptor in the prefetch FIFO.
 * Reset: 0x0         Access: RO
 */
#define UDMA_S2M_Q_RDCP_OFFSET_MASK  0x00FFFFFF
#define UDMA_S2M_Q_RDCP_OFFSET_SHIFT 0
/*
 * Ring ID
 * Reset: 0x1         Access: RO
 */
#define UDMA_S2M_Q_RDCP_RING_ID_MASK 0xC0000000
#define UDMA_S2M_Q_RDCP_RING_ID_SHIFT 30

/**** rcrbp_low register ****/
/*
 * S2M Descriptor Ring Base address [31:6].
 * Value of the base address of the S2M descriptor ring
 * [5:0] - 0 - 64B alignment is enforced
 * ([11:6] Must be 0 for 4KB alignment)
 * NOTE:
 * Length of the descriptor ring (in descriptors) associated with the ring base address ends at
 * maximum burst size alignment
 * Reset: 0x0         Access: RW
 */
#define UDMA_S2M_Q_RCRBP_LOW_ADDR_MASK 0xFFFFFFC0
#define UDMA_S2M_Q_RCRBP_LOW_ADDR_SHIFT 6

/**** rcrbp_high register ****/
/*
 * S2M Base address of the completion ring
 * Reset: 0x0         Access: RW
 */
#define UDMA_S2M_Q_RCRBP_HIGH_ADDR_MASK 0xFFFFFFFF
#define UDMA_S2M_Q_RCRBP_HIGH_ADDR_SHIFT 0

/**** rcrhp register ****/
/*
 * Relative offset of the next descriptor that needs to be updated by the completion controller.
 * Note: This is in descriptors and not in byte address.
 * Reset: 0x0         Access: RO
 */
#define UDMA_S2M_Q_RCRHP_OFFSET_MASK 0x00FFFFFF
#define UDMA_S2M_Q_RCRHP_OFFSET_SHIFT 0
/*
 * Ring ID
 * Reset: 0x1         Access: RO
 */
#define UDMA_S2M_Q_RCRHP_RING_ID_MASK 0xC0000000
#define UDMA_S2M_Q_RCRHP_RING_ID_SHIFT 30

/**** rcrhp_internal register ****/
/*
 * Relative offset of the next descriptor that needs to be updated by the completion controller.
 * Note: This is in descriptors and not in byte address.
 * Reset: 0x0         Access: RO
 */
#define UDMA_S2M_Q_RCRHP_INTERNAL_OFFSET_MASK 0x00FFFFFF
#define UDMA_S2M_Q_RCRHP_INTERNAL_OFFSET_SHIFT 0
/*
 * Ring ID
 * Reset: 0x1         Access: RO
 */
#define UDMA_S2M_Q_RCRHP_INTERNAL_RING_ID_MASK 0xC0000000
#define UDMA_S2M_Q_RCRHP_INTERNAL_RING_ID_SHIFT 30

/**** comp_cfg register ****/
/*
 * Enables writing to the completion ring.
 * Reset: 0x1         Access: RW
 */
#define UDMA_S2M_Q_COMP_CFG_EN_COMP_RING_UPDATE (1 << 0)
#define UDMA_S2M_Q_COMP_CFG_EN_COMP_RING_UPDATE_MASK 0x00000001
#define UDMA_S2M_Q_COMP_CFG_EN_COMP_RING_UPDATE_SHIFT 0
/*
 * Disables the completion coalescing function.
 * Reset: 0x1         Access: RW
 */
#define UDMA_S2M_Q_COMP_CFG_DIS_COMP_COAL (1 << 1)
#define UDMA_S2M_Q_COMP_CFG_DIS_COMP_COAL_MASK 0x00000002
#define UDMA_S2M_Q_COMP_CFG_DIS_COMP_COAL_SHIFT 1
/*
 * Reserved
 * Reset: 0x1         Access: RW
 */
#define UDMA_S2M_Q_COMP_CFG_FIRST_PKT_PROMOTION (1 << 2)
#define UDMA_S2M_Q_COMP_CFG_FIRST_PKT_PROMOTION_MASK 0x00000004
#define UDMA_S2M_Q_COMP_CFG_FIRST_PKT_PROMOTION_SHIFT 2
/*
 * Buffer 2 location.
 * Determines the position of the buffer 2 length in the S2M completion descriptor.
 * 0 - WORD 1 [31:16]
 * 1 - WORD 2 [31:16]
 * Reset: 0x1         Access: RW
 */
#define UDMA_S2M_Q_COMP_CFG_BUF2_LEN_LOCATION (1 << 3)
#define UDMA_S2M_Q_COMP_CFG_BUF2_LEN_LOCATION_MASK 0x00000008
#define UDMA_S2M_Q_COMP_CFG_BUF2_LEN_LOCATION_SHIFT 3
/*
 * Decide if word 1 bits 31:8 will be override with BUF1 FE,
 * Reset: 0x0         Access: RW
 */
#define UDMA_S2M_Q_COMP_CFG_W1_OVERRIDE (1 << 4)
#define UDMA_S2M_Q_COMP_CFG_W1_OVERRIDE_MASK 0x00000010
#define UDMA_S2M_Q_COMP_CFG_W1_OVERRIDE_SHIFT 4
/*
 * FE of 24 bits - operate on buf1_addr,
 * Can be put in W1 cmpl for IPP purpose.
 * Reset: 0x8         Access: RW
 */
#define UDMA_S2M_Q_COMP_CFG_BUF1_FE_MASK 0x000007E0
#define UDMA_S2M_Q_COMP_CFG_BUF1_FE_SHIFT 5
/*
 * When set UDMA cmpl frst/last will be by block boundaries and not by packet boundaries
 * Reset: 0x0         Access: RW
 */
#define UDMA_S2M_Q_COMP_CFG_CMPL_BLOCK_MODE (1 << 11)
#define UDMA_S2M_Q_COMP_CFG_CMPL_BLOCK_MODE_MASK 0x00000800
#define UDMA_S2M_Q_COMP_CFG_CMPL_BLOCK_MODE_SHIFT 11

/**** comp_cfg_2 register ****/
/*
 * Completion coalescing timer.
 * Each queue has its own timer.
 * Reset: 0x186a0     Access: RW
 */
#define UDMA_S2M_Q_COMP_CFG_2_TIMER_MASK 0xFFFFFFFF
#define UDMA_S2M_Q_COMP_CFG_2_TIMER_SHIFT 0

/**** pkt_cfg register ****/
/*
 * Header size. (bytes)
 * Reset: 0x40        Access: RW
 */
#define UDMA_S2M_Q_PKT_CFG_HDR_SPLIT_SIZE_MASK 0x0000FFFF
#define UDMA_S2M_Q_PKT_CFG_HDR_SPLIT_SIZE_SHIFT 0
/*
 * Force header split
 * Reset: 0x0         Access: RW
 */
#define UDMA_S2M_Q_PKT_CFG_FORCE_HDR_SPLIT (1 << 16)
#define UDMA_S2M_Q_PKT_CFG_FORCE_HDR_SPLIT_MASK 0x00010000
#define UDMA_S2M_Q_PKT_CFG_FORCE_HDR_SPLIT_SHIFT 16
/*
 * Enable header split.
 * Reset: 0x0         Access: RW
 */
#define UDMA_S2M_Q_PKT_CFG_EN_HDR_SPLIT (1 << 17)
#define UDMA_S2M_Q_PKT_CFG_EN_HDR_SPLIT_MASK 0x00020000
#define UDMA_S2M_Q_PKT_CFG_EN_HDR_SPLIT_SHIFT 17
/*
 * Enable desc flush (WQE mode) from packet header - bit 83 from packet header.
 * Reset: 0x1         Access: RW
 */
#define UDMA_S2M_Q_PKT_CFG_PKT_HDR_FLUSH_EN (1 << 18)
#define UDMA_S2M_Q_PKT_CFG_PKT_HDR_FLUSH_EN_MASK 0x00040000
#define UDMA_S2M_Q_PKT_CFG_PKT_HDR_FLUSH_EN_SHIFT 18
/*
 * Enable desc store (WQE mode) from packet header - bit 84 from packet header.
 * Reset: 0x1         Access: RW
 */
#define UDMA_S2M_Q_PKT_CFG_PKT_HDR_STORE_EN (1 << 19)
#define UDMA_S2M_Q_PKT_CFG_PKT_HDR_STORE_EN_MASK 0x00080000
#define UDMA_S2M_Q_PKT_CFG_PKT_HDR_STORE_EN_SHIFT 19

/**** qos_cfg register ****/
/*
 * Queue QoS
 * Reset: 0x0         Access: RW
 */
#define UDMA_S2M_QOS_CFG_Q_QOS_MASK 0x000000FF
#define UDMA_S2M_QOS_CFG_Q_QOS_SHIFT 0

/**** q_sw_ctrl register ****/
/*
 * Reset the tail pointer hardware.
 * Reset: 0x0         Access: RW
 */
#define UDMA_S2M_Q_SW_CTRL_RST_TAIL_PTR (1 << 1)
#define UDMA_S2M_Q_SW_CTRL_RST_TAIL_PTR_MASK 0x00000002
#define UDMA_S2M_Q_SW_CTRL_RST_TAIL_PTR_SHIFT 1
/*
 * Reset the head pointer hardware.
 * Reset: 0x0         Access: RW
 */
#define UDMA_S2M_Q_SW_CTRL_RST_HEAD_PTR (1 << 2)
#define UDMA_S2M_Q_SW_CTRL_RST_HEAD_PTR_MASK 0x00000004
#define UDMA_S2M_Q_SW_CTRL_RST_HEAD_PTR_SHIFT 2
/*
 * Reset the current pointer hardware.
 * Reset: 0x0         Access: RW
 */
#define UDMA_S2M_Q_SW_CTRL_RST_CURRENT_PTR (1 << 3)
#define UDMA_S2M_Q_SW_CTRL_RST_CURRENT_PTR_MASK 0x00000008
#define UDMA_S2M_Q_SW_CTRL_RST_CURRENT_PTR_SHIFT 3
/*
 * Reset the prefetch FIFO
 * Reset: 0x0         Access: RW
 */
#define UDMA_S2M_Q_SW_CTRL_RST_PREFETCH (1 << 4)
#define UDMA_S2M_Q_SW_CTRL_RST_PREFETCH_MASK 0x00000010
#define UDMA_S2M_Q_SW_CTRL_RST_PREFETCH_SHIFT 4
/*
 * Reset the queue
 * Reset: 0x0         Access: RW
 */
#define UDMA_S2M_Q_SW_CTRL_RST_Q   (1 << 8)
#define UDMA_S2M_Q_SW_CTRL_RST_Q_MASK 0x00000100
#define UDMA_S2M_Q_SW_CTRL_RST_Q_SHIFT 8

/**** q_rx_pkt register ****/
/*
 * Counting the number of packets received per queue
 * Reset: 0x0         Access: RO, RtoClr
 */
#define UDMA_S2M_Q_RX_PKT_CNT_MASK 0xFFFFFFFF
#define UDMA_S2M_Q_RX_PKT_CNT_SHIFT 0

/**** rdrtp_set register ****/
/*
 * this value will go to
 * submission queue tail pointer
 * Reset: 0x0         Access: WO
 */
#define UDMA_S2M_Q_RDRTP_SET_PTR_VALUE_MASK 0x00FFFFFF
#define UDMA_S2M_Q_RDRTP_SET_PTR_VALUE_SHIFT 0
/*
 * this value will go to
 *  sumission queue rind id
 * Reset: 0x0         Access: WO
 */
#define UDMA_S2M_Q_RDRTP_SET_RING_ID_MASK 0x03000000
#define UDMA_S2M_Q_RDRTP_SET_RING_ID_SHIFT 24

/**** rdrhp_set register ****/
/*
 * this value will go to:
 * submission queue head pointer
 * cmpl queue head pointer
 * Reset: 0x0         Access: WO
 */
#define UDMA_S2M_Q_RDRHP_SET_PTR_VALUE_MASK 0x00FFFFFF
#define UDMA_S2M_Q_RDRHP_SET_PTR_VALUE_SHIFT 0
/*
 * this value will go to:
 * submission queue head pointer
 * cmpl queue ring id
 * Reset: 0x0         Access: WO
 */
#define UDMA_S2M_Q_RDRHP_SET_RING_ID_MASK 0x03000000
#define UDMA_S2M_Q_RDRHP_SET_RING_ID_SHIFT 24

/**************************************************************************************************
 * udma_regs
 **************************************************************************************************/
struct udma_s2m_regs {
	/* [0x0] */
	uint32_t rsrvd_0[64];
	/* [0x100] AXI S2M configuration */
	struct udma_axi_s2m axi_s2m;
	/* [0x200] S2M general configuration */
	struct udma_s2m s2m;
	/* [0x300] S2M descriptor read  configuration */
	struct udma_s2m_rd s2m_rd;
	/* [0x340] S2M data write  configuration */
	struct udma_s2m_wr s2m_wr;
	/* [0x380] S2M completion control configuration */
	struct udma_s2m_comp s2m_comp;
	/* [0x3c0] */
	uint32_t rsrvd_1[80];
	/* [0x500] S2M statistics */
	struct udma_s2m_stat s2m_stat;
	/* [0x600] S2M Feature registers */
	struct udma_s2m_feature s2m_feature;
	/* [0x700] */
	struct udma_s2m_shadow_access s2m_shadow_access;
	/* [0x800] */
	uint32_t rsrvd_2[512];
	/* [0x1000] */
	struct udma_s2m_q s2m_q[16];
	/* [0x11000] */
	uint32_t rsrvd_3[15360];
};

/* Asserts */
al_static_assert(sizeof(struct al_cell_fe_regs) == 4,
	"Expected other registers struct size!");

#ifdef __cplusplus
}
#endif

#endif

/** @} */
