/*
 * Copyright 2019, Amazon.com, Inc. or its affiliates. All Rights Reserved
 */

/**
 *  @{
 * @file   al_hal_udma_gen_regs.h
 *
 * @brief udma_gen registers
 *
 * This file was auto-generated by RegGen v1.3.14
 *
 * Hash Key is: 61556dae46e729556b572c7839d32973
 *
 * JSON: al_udma_gen_regs.json
 *
 */

#ifndef __AL_HAL_UDMA_GEN_REGS_H__
#define __AL_HAL_UDMA_GEN_REGS_H__

#include "al_hal_common.h"

#include "al_hal_cell_fe_regs.h"

#ifdef __cplusplus
extern "C" {
#endif

/**************************************************************************************************
 * udma_gen_dma_misc
 *
 * AXI configuration
 **************************************************************************************************/
struct udma_gen_dma_misc {
	/* [0x0] Reserved register for the interrupt controller */
	uint32_t int_cfg;
	/* [0x4] Revision register */
	uint32_t revision;
	/* [0x8] Reserved for future use */
	uint32_t general_cfg_1;
	/* [0xc] Reserved for future use */
	uint32_t general_cfg_2;
	/* [0x10] Reserved for future use */
	uint32_t general_cfg_3;
	/* [0x14] Reserved for future use */
	uint32_t general_cfg_4;
	/* [0x18] General timer configuration */
	uint32_t general_cfg_5;
	/*
	 * [0x1c] from toprock UDMA_abort goes also for the applicaiton, this register should
	 * control if abort should go only to UDMA or only to application or both. Default goes to
	 * both
	 */
	uint32_t abort_ctl;
	/* [0x20] */
	uint32_t bw_bug_fixes;
	/* [0x24] */
	uint32_t rsrvd_0[55];
};

/**** int_cfg register ****/
/*
 * MSIX data width
 * 1 - 64 bit
 * 0 - 32 bit
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_DMA_MISC_INT_CFG_MSIX_64 (1 << 0)
#define UDMA_GEN_DMA_MISC_INT_CFG_MSIX_64_MASK 0x00000001
#define UDMA_GEN_DMA_MISC_INT_CFG_MSIX_64_SHIFT 0
/*
 * General configuration
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_DMA_MISC_INT_CFG_RESERVED_3_1_MASK 0x0000000E
#define UDMA_GEN_DMA_MISC_INT_CFG_RESERVED_3_1_SHIFT 1
/*
 * MSIx AXI QoS
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_DMA_MISC_INT_CFG_MSIX_AXI_QOS_MASK 0x00000070
#define UDMA_GEN_DMA_MISC_INT_CFG_MSIX_AXI_QOS_SHIFT 4
/* Reset: 0x0         Access: RW */
#define UDMA_GEN_DMA_MISC_INT_CFG_RESERVED_31_7_MASK 0xFFFFFF80
#define UDMA_GEN_DMA_MISC_INT_CFG_RESERVED_31_7_SHIFT 7

/**** revision register ****/
/*
 * Design programming interface  revision ID
 * Reset: 0x1         Access: RO
 */
#define UDMA_GEN_DMA_MISC_REVISION_PROGRAMMING_ID_MASK 0x00000FFF
#define UDMA_GEN_DMA_MISC_REVISION_PROGRAMMING_ID_SHIFT 0
/*
 * Design minor revision ID
 * Reset: 0x1         Access: RO
 */
#define UDMA_GEN_DMA_MISC_REVISION_MINOR_ID_MASK 0x00FFF000
#define UDMA_GEN_DMA_MISC_REVISION_MINOR_ID_SHIFT 12
/*
 * Design major revision ID
 * Reset: 0x2         Access: RO
 */
#define UDMA_GEN_DMA_MISC_REVISION_MAJOR_ID_MASK 0xFF000000
#define UDMA_GEN_DMA_MISC_REVISION_MAJOR_ID_SHIFT 24

/**** general_cfg_1 register ****/
/* Reset: 0x0         Access: RW */
#define UDMA_GEN_DMA_MISC_GENERAL_CFG_1_RESERVED_31_0_MASK 0xFFFFFFFF
#define UDMA_GEN_DMA_MISC_GENERAL_CFG_1_RESERVED_31_0_SHIFT 0

/**** general_cfg_2 register ****/
/* Reset: 0x0         Access: RW */
#define UDMA_GEN_DMA_MISC_GENERAL_CFG_2_RESERVED_31_0_MASK 0xFFFFFFFF
#define UDMA_GEN_DMA_MISC_GENERAL_CFG_2_RESERVED_31_0_SHIFT 0

/**** general_cfg_3 register ****/
/* Reset: 0x0         Access: RW */
#define UDMA_GEN_DMA_MISC_GENERAL_CFG_3_RESERVED_31_0_MASK 0xFFFFFFFF
#define UDMA_GEN_DMA_MISC_GENERAL_CFG_3_RESERVED_31_0_SHIFT 0

/**** general_cfg_4 register ****/
/* Reset: 0x0         Access: RW */
#define UDMA_GEN_DMA_MISC_GENERAL_CFG_4_RESERVED_31_0_MASK 0xFFFFFFFF
#define UDMA_GEN_DMA_MISC_GENERAL_CFG_4_RESERVED_31_0_SHIFT 0

/**** general_cfg_5 register ****/
/*
 * Timer value
 * 0 - not active
 * 1-2^32 - SB clock cycles
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_DMA_MISC_GENERAL_CFG_5_TIMER_MASK 0xFFFFFFFF
#define UDMA_GEN_DMA_MISC_GENERAL_CFG_5_TIMER_SHIFT 0

/**** abort_ctl register ****/
/*
 * When set mask the abort indicaiton coming from INT controller (after local int Controller mask) -
 * otherwise pass abort indicaiton (same as GDMA)
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_DMA_MISC_ABORT_CTL_MASK_LOCAL_ABORT (1 << 0)
#define UDMA_GEN_DMA_MISC_ABORT_CTL_MASK_LOCAL_ABORT_MASK 0x00000001
#define UDMA_GEN_DMA_MISC_ABORT_CTL_MASK_LOCAL_ABORT_SHIFT 0
/*
 * When set mask the abort indicaiton Going toward application/Adapter from INT controller (after
 * local int Controller mask)
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_DMA_MISC_ABORT_CTL_MASK_APP_ABORT (1 << 1)
#define UDMA_GEN_DMA_MISC_ABORT_CTL_MASK_APP_ABORT_MASK 0x00000002
#define UDMA_GEN_DMA_MISC_ABORT_CTL_MASK_APP_ABORT_SHIFT 1

/**** bw_bug_fixes register ****/
/*
 * When '1' BUG fix enabled When '0' work as PKR mode
 * Reset: 0x1         Access: RW
 */
#define UDMA_GEN_DMA_MISC_BW_BUG_FIXES_RX_DATA_BUILD_FSM (1 << 0)
#define UDMA_GEN_DMA_MISC_BW_BUG_FIXES_RX_DATA_BUILD_FSM_MASK 0x00000001
#define UDMA_GEN_DMA_MISC_BW_BUG_FIXES_RX_DATA_BUILD_FSM_SHIFT 0
/*
 * When '1' BUG fix enabled When '0' work as PKR mode
 * Reset: 0x1         Access: RW
 */
#define UDMA_GEN_DMA_MISC_BW_BUG_FIXES_RX_PREF_FIFO (1 << 1)
#define UDMA_GEN_DMA_MISC_BW_BUG_FIXES_RX_PREF_FIFO_MASK 0x00000002
#define UDMA_GEN_DMA_MISC_BW_BUG_FIXES_RX_PREF_FIFO_SHIFT 1
/*
 * When '1' BUG fix enabled
 * When '0' work as PKR mode
 * Reset: 0x1         Access: RW
 */
#define UDMA_GEN_DMA_MISC_BW_BUG_FIXES_TX_STREAMER_FSM (1 << 2)
#define UDMA_GEN_DMA_MISC_BW_BUG_FIXES_TX_STREAMER_FSM_MASK 0x00000004
#define UDMA_GEN_DMA_MISC_BW_BUG_FIXES_TX_STREAMER_FSM_SHIFT 2
/*
 * When '1' UDMA will send packet header on metadatra bus while desc/data will be send on data bus,
 * When '0' work as TPR/PKR mode
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_DMA_MISC_BW_BUG_FIXES_TX_PKTHDR (1 << 3)
#define UDMA_GEN_DMA_MISC_BW_BUG_FIXES_TX_PKTHDR_MASK 0x00000008
#define UDMA_GEN_DMA_MISC_BW_BUG_FIXES_TX_PKTHDR_SHIFT 3

/**************************************************************************************************
 * udma_gen_mailbox
 *
 * Mailbox between DMAs
 **************************************************************************************************/
struct udma_gen_mailbox {
	/*
	 * [0x0] Mailbox interrupt generator.
	 * Generates interrupt to neighbor DMA
	 */
	uint32_t interrupt;
	/* [0x4] Mailbox message data out */
	uint32_t msg_out;
	/* [0x8] Mailbox message data in */
	uint32_t msg_in;
	/* [0xc] */
	uint32_t rsrvd_0[13];
};

/**** interrupt register ****/
/*
 * Generate interrupt to another DMA
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_MAILBOX_INTERRUPT_SET   (1 << 0)
#define UDMA_GEN_MAILBOX_INTERRUPT_SET_MASK 0x00000001
#define UDMA_GEN_MAILBOX_INTERRUPT_SET_SHIFT 0

/**** msg_out register ****/
/* Reset: 0x0         Access: RW */
#define UDMA_GEN_MAILBOX_MSG_OUT_DATA_MASK 0xFFFFFFFF
#define UDMA_GEN_MAILBOX_MSG_OUT_DATA_SHIFT 0

/**** msg_in register ****/
/* Reset: 0x0         Access: RO */
#define UDMA_GEN_MAILBOX_MSG_IN_DATA_MASK 0xFFFFFFFF
#define UDMA_GEN_MAILBOX_MSG_IN_DATA_SHIFT 0

/**************************************************************************************************
 * udma_gen_axi
 *
 * AXI configuration
 **************************************************************************************************/
struct udma_gen_axi {
	/* [0x0] Configuration of the AXI masters */
	uint32_t cfg_1;
	/* [0x4] Configuration of the AXI masters */
	uint32_t cfg_2;
	/* [0x8] Configuration of the AXI masters. Endianness configuration */
	uint32_t endian_cfg;
	/* [0xc] */
	uint32_t rsrvd_0[29];
};

/**** cfg_1 register ****/
/*
 * Timeout value for all transactions on the AXI
 * Reset: 0x2710      Access: RW
 */
#define UDMA_GEN_AXI_CFG_1_TOUT_MASK     0xFFFFFFFF
#define UDMA_GEN_AXI_CFG_1_TOUT_SHIFT    0

/**** cfg_2 register ****/
/*
 * Enable arbitration promotion.
 * Increment master priority after configured number of arbitration cycles
 * Reset: 0x8         Access: RW
 */
#define UDMA_GEN_AXI_CFG_2_ARB_PROMOTION_MASK 0x0000000F
#define UDMA_GEN_AXI_CFG_2_ARB_PROMOTION_SHIFT 0

/**** endian_cfg register ****/
/*
 * Swap M2S descriptor read and completion descriptor write.
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_AXI_ENDIAN_CFG_SWAP_M2S_DESC (1 << 0)
#define UDMA_GEN_AXI_ENDIAN_CFG_SWAP_M2S_DESC_MASK 0x00000001
#define UDMA_GEN_AXI_ENDIAN_CFG_SWAP_M2S_DESC_SHIFT 0
/*
 * Swap M2S data read.
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_AXI_ENDIAN_CFG_SWAP_M2S_DATA (1 << 1)
#define UDMA_GEN_AXI_ENDIAN_CFG_SWAP_M2S_DATA_MASK 0x00000002
#define UDMA_GEN_AXI_ENDIAN_CFG_SWAP_M2S_DATA_SHIFT 1
/*
 * Swap S2M descriptor read and completion descriptor write.
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_AXI_ENDIAN_CFG_SWAP_S2M_DESC (1 << 2)
#define UDMA_GEN_AXI_ENDIAN_CFG_SWAP_S2M_DESC_MASK 0x00000004
#define UDMA_GEN_AXI_ENDIAN_CFG_SWAP_S2M_DESC_SHIFT 2
/*
 * Swap S2M data write.
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_AXI_ENDIAN_CFG_SWAP_S2M_DATA (1 << 3)
#define UDMA_GEN_AXI_ENDIAN_CFG_SWAP_S2M_DATA_MASK 0x00000008
#define UDMA_GEN_AXI_ENDIAN_CFG_SWAP_S2M_DATA_SHIFT 3
/*
 * Swap 32 or 64 bit mode:
 * 0 - Swap groups of 4 bytes
 * 1 - Swap groups of 8 bytes
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_AXI_ENDIAN_CFG_SWAP_64B_EN (1 << 4)
#define UDMA_GEN_AXI_ENDIAN_CFG_SWAP_64B_EN_MASK 0x00000010
#define UDMA_GEN_AXI_ENDIAN_CFG_SWAP_64B_EN_SHIFT 4

/**************************************************************************************************
 * udma_gen_reflect_rx_cmpl_agent_error_detect
 *
 * Cfg for error detrct and action
 **************************************************************************************************/
struct udma_gen_reflect_rx_cmpl_agent_error_detect {
	/* [0x0] */
	uint32_t match;
	/* [0x4] */
	uint32_t match_mask;
	/* [0x8] */
	uint32_t error_mask;
};

/**** match register ****/
/* Reset: 0x0         Access: RW */
#define UDMA_GEN_REFLECT_RX_CMPL_AGENT_ERROR_DETECT_MATCH_VAL_MASK 0xFFFFFFFF
#define UDMA_GEN_REFLECT_RX_CMPL_AGENT_ERROR_DETECT_MATCH_VAL_SHIFT 0

/**** match_mask register ****/
/* Reset: 0x0         Access: RW */
#define UDMA_GEN_REFLECT_RX_CMPL_AGENT_ERROR_DETECT_MATCH_MASK_VAL_MASK 0xFFFFFFFF
#define UDMA_GEN_REFLECT_RX_CMPL_AGENT_ERROR_DETECT_MATCH_MASK_VAL_SHIFT 0

/**** error_mask register ****/
/* Reset: 0x0         Access: RW */
#define UDMA_GEN_REFLECT_RX_CMPL_AGENT_ERROR_DETECT_ERROR_MASK_VAL_MASK 0xFFFFFFFF
#define UDMA_GEN_REFLECT_RX_CMPL_AGENT_ERROR_DETECT_ERROR_MASK_VAL_SHIFT 0

/**************************************************************************************************
 * udma_gen_reflect_rx_cmpl_agent
 *
 * Cfg for rx cmpl error agent
 **************************************************************************************************/
struct udma_gen_reflect_rx_cmpl_agent {
	/* [0x0] */
	uint32_t enable;
	/* [0x4] Cfg for error detrct and action */
	struct udma_gen_reflect_rx_cmpl_agent_error_detect error_detect[16];
};

/**** enable register ****/
/*
 * Enable to rx_cmpl_error changes to issue cache update
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_REFLECT_RX_CMPL_AGENT_ENABLE_ENABLE (1 << 0)
#define UDMA_GEN_REFLECT_RX_CMPL_AGENT_ENABLE_ENABLE_MASK 0x00000001
#define UDMA_GEN_REFLECT_RX_CMPL_AGENT_ENABLE_ENABLE_SHIFT 0
/*
 * Allow timer skip due agent changes
 * Reset: 0x1         Access: RW
 */
#define UDMA_GEN_REFLECT_RX_CMPL_AGENT_ENABLE_BYPASS_TIMER_EN (1 << 1)
#define UDMA_GEN_REFLECT_RX_CMPL_AGENT_ENABLE_BYPASS_TIMER_EN_MASK 0x00000002
#define UDMA_GEN_REFLECT_RX_CMPL_AGENT_ENABLE_BYPASS_TIMER_EN_SHIFT 1

/**************************************************************************************************
 * udma_gen_reflect_tx_cmpl_agent_error_detect
 *
 * Cfg for error detrct and action
 **************************************************************************************************/
struct udma_gen_reflect_tx_cmpl_agent_error_detect {
	/* [0x0] */
	uint32_t match;
	/* [0x4] */
	uint32_t match_mask;
	/* [0x8] */
	uint32_t error_mask;
};

/**** match register ****/
/* Reset: 0x0         Access: RW */
#define UDMA_GEN_REFLECT_TX_CMPL_AGENT_ERROR_DETECT_MATCH_VAL_MASK 0xFFFFFFFF
#define UDMA_GEN_REFLECT_TX_CMPL_AGENT_ERROR_DETECT_MATCH_VAL_SHIFT 0

/**** match_mask register ****/
/* Reset: 0x0         Access: RW */
#define UDMA_GEN_REFLECT_TX_CMPL_AGENT_ERROR_DETECT_MATCH_MASK_VAL_MASK 0xFFFFFFFF
#define UDMA_GEN_REFLECT_TX_CMPL_AGENT_ERROR_DETECT_MATCH_MASK_VAL_SHIFT 0

/**** error_mask register ****/
/* Reset: 0x0         Access: RW */
#define UDMA_GEN_REFLECT_TX_CMPL_AGENT_ERROR_DETECT_ERROR_MASK_VAL_MASK 0xFFFFFFFF
#define UDMA_GEN_REFLECT_TX_CMPL_AGENT_ERROR_DETECT_ERROR_MASK_VAL_SHIFT 0

/**************************************************************************************************
 * udma_gen_reflect_tx_cmpl_agent
 *
 * Cfg for rx cmpl error agent
 **************************************************************************************************/
struct udma_gen_reflect_tx_cmpl_agent {
	/* [0x0] */
	uint32_t enable;
	/* [0x4] Cfg for error detrct and action */
	struct udma_gen_reflect_tx_cmpl_agent_error_detect error_detect[4];
};

/**** enable register ****/
/*
 * Enable to rx_cmpl_error changes to issue cache update
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_REFLECT_TX_CMPL_AGENT_ENABLE_ENABLE (1 << 0)
#define UDMA_GEN_REFLECT_TX_CMPL_AGENT_ENABLE_ENABLE_MASK 0x00000001
#define UDMA_GEN_REFLECT_TX_CMPL_AGENT_ENABLE_ENABLE_SHIFT 0
/*
 * Allow timer skip due agent changes
 * Reset: 0x1         Access: RW
 */
#define UDMA_GEN_REFLECT_TX_CMPL_AGENT_ENABLE_BYPASS_TIMER_EN (1 << 1)
#define UDMA_GEN_REFLECT_TX_CMPL_AGENT_ENABLE_BYPASS_TIMER_EN_MASK 0x00000002
#define UDMA_GEN_REFLECT_TX_CMPL_AGENT_ENABLE_BYPASS_TIMER_EN_SHIFT 1

/**************************************************************************************************
 * udma_gen_reflect_axi
 *
 * AXI write configuration for reflect engine
 **************************************************************************************************/
struct udma_gen_reflect_axi {
	/* [0x0] AXI attributes */
	uint32_t cfg0;
	/* [0x4] AXI awuser */
	uint32_t cfg1;
	/* [0x8] AXI timer (for timeout) */
	uint32_t timer;
	/* [0xc] fifo ctrl of axi write agent */
	uint32_t fifo_ctl;
	/* [0x10] AXI fifos status */
	uint32_t fifo_status;
};

/**** cfg0 register ****/
/* Reset: 0x1         Access: RW */
#define UDMA_GEN_REFLECT_AXI_CFG0_AWBURST_MASK 0x00000003
#define UDMA_GEN_REFLECT_AXI_CFG0_AWBURST_SHIFT 0
/* Reset: 0x3         Access: RW */
#define UDMA_GEN_REFLECT_AXI_CFG0_AWCACHE_MASK 0x0000003C
#define UDMA_GEN_REFLECT_AXI_CFG0_AWCACHE_SHIFT 2
/* Reset: 0x5         Access: RW */
#define UDMA_GEN_REFLECT_AXI_CFG0_AWID_MASK 0x000007C0
#define UDMA_GEN_REFLECT_AXI_CFG0_AWID_SHIFT 6
/* Reset: 0x3         Access: RW */
#define UDMA_GEN_REFLECT_AXI_CFG0_AWPROT_MASK 0x00003800
#define UDMA_GEN_REFLECT_AXI_CFG0_AWPROT_SHIFT 11
/* Reset: 0x0         Access: RW */
#define UDMA_GEN_REFLECT_AXI_CFG0_AWQOS_MASK 0x0001C000
#define UDMA_GEN_REFLECT_AXI_CFG0_AWQOS_SHIFT 14
/* Reset: 0x5         Access: RW */
#define UDMA_GEN_REFLECT_AXI_CFG0_AWSIZE_MASK 0x000E0000
#define UDMA_GEN_REFLECT_AXI_CFG0_AWSIZE_SHIFT 17
/* Reset: 0x0         Access: RW */
#define UDMA_GEN_REFLECT_AXI_CFG0_AWSNP  (1 << 20)
#define UDMA_GEN_REFLECT_AXI_CFG0_AWSNP_MASK 0x00100000
#define UDMA_GEN_REFLECT_AXI_CFG0_AWSNP_SHIFT 20

/**** cfg1 register ****/
/*
 * awuser
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_REFLECT_AXI_CFG1_AWUSER_MASK 0x003FFFFF
#define UDMA_GEN_REFLECT_AXI_CFG1_AWUSER_SHIFT 0

/**** timer register ****/
/* Reset: 0x2710      Access: RW */
#define UDMA_GEN_REFLECT_AXI_TIMER_VAL_MASK 0xFFFFFFFF
#define UDMA_GEN_REFLECT_AXI_TIMER_VAL_SHIFT 0

/**** fifo_ctl register ****/
/*
 * Max value is 16
 * Reset: 0x10        Access: RW
 */
#define UDMA_GEN_REFLECT_AXI_FIFO_CTL_REQ_FIFO_LIMIT_MASK 0x0000001F
#define UDMA_GEN_REFLECT_AXI_FIFO_CTL_REQ_FIFO_LIMIT_SHIFT 0
/*
 * Max value is 8
 * Reset: 0x8         Access: RW
 */
#define UDMA_GEN_REFLECT_AXI_FIFO_CTL_DATA_FIFO_LIMIT_MASK 0x000001E0
#define UDMA_GEN_REFLECT_AXI_FIFO_CTL_DATA_FIFO_LIMIT_SHIFT 5
/*
 * Enable req fifo
 * Reset: 0x1         Access: RW
 */
#define UDMA_GEN_REFLECT_AXI_FIFO_CTL_REQ_FIFO_EN (1 << 9)
#define UDMA_GEN_REFLECT_AXI_FIFO_CTL_REQ_FIFO_EN_MASK 0x00000200
#define UDMA_GEN_REFLECT_AXI_FIFO_CTL_REQ_FIFO_EN_SHIFT 9

/**** fifo_status register ****/
/* Reset: 0x0         Access: RO */
#define UDMA_GEN_REFLECT_AXI_FIFO_STATUS_REQ_FIFO_FULL (1 << 0)
#define UDMA_GEN_REFLECT_AXI_FIFO_STATUS_REQ_FIFO_FULL_MASK 0x00000001
#define UDMA_GEN_REFLECT_AXI_FIFO_STATUS_REQ_FIFO_FULL_SHIFT 0
/* Reset: 0x0         Access: RO */
#define UDMA_GEN_REFLECT_AXI_FIFO_STATUS_REQ_FIFO_EMPTY (1 << 1)
#define UDMA_GEN_REFLECT_AXI_FIFO_STATUS_REQ_FIFO_EMPTY_MASK 0x00000002
#define UDMA_GEN_REFLECT_AXI_FIFO_STATUS_REQ_FIFO_EMPTY_SHIFT 1
/* Reset: 0x0         Access: RO */
#define UDMA_GEN_REFLECT_AXI_FIFO_STATUS_DATA_FIFO_FULL (1 << 2)
#define UDMA_GEN_REFLECT_AXI_FIFO_STATUS_DATA_FIFO_FULL_MASK 0x00000004
#define UDMA_GEN_REFLECT_AXI_FIFO_STATUS_DATA_FIFO_FULL_SHIFT 2
/* Reset: 0x0         Access: RO */
#define UDMA_GEN_REFLECT_AXI_FIFO_STATUS_DATA_FIFO_EMPTY (1 << 3)
#define UDMA_GEN_REFLECT_AXI_FIFO_STATUS_DATA_FIFO_EMPTY_MASK 0x00000008
#define UDMA_GEN_REFLECT_AXI_FIFO_STATUS_DATA_FIFO_EMPTY_SHIFT 3
/* Reset: 0x0         Access: RO */
#define UDMA_GEN_REFLECT_AXI_FIFO_STATUS_REQ_FIFO_INUSE_MASK 0x000001F0
#define UDMA_GEN_REFLECT_AXI_FIFO_STATUS_REQ_FIFO_INUSE_SHIFT 4
/* Reset: 0x0         Access: RO */
#define UDMA_GEN_REFLECT_AXI_FIFO_STATUS_DATA_FIFO_INUSE_MASK 0x00001E00
#define UDMA_GEN_REFLECT_AXI_FIFO_STATUS_DATA_FIFO_INUSE_SHIFT 9

/**************************************************************************************************
 * udma_gen_reflect_cfg_error_counter
 *
 * Cfg for error counter clear
 **************************************************************************************************/
struct udma_gen_reflect_cfg_error_counter {
	/* [0x0] RX */
	uint32_t rx;
	/* [0x4] TX */
	uint32_t tx;
};

/**** rx register ****/
/* Reset: 0x0         Access: WO, PulseOnW */
#define UDMA_GEN_REFLECT_CFG_ERROR_COUNTER_RX_CLEAR_MASK 0x0000FFFF
#define UDMA_GEN_REFLECT_CFG_ERROR_COUNTER_RX_CLEAR_SHIFT 0

/**** tx register ****/
/* Reset: 0x0         Access: WO, PulseOnW */
#define UDMA_GEN_REFLECT_CFG_ERROR_COUNTER_TX_CLEAR_MASK 0x0000FFFF
#define UDMA_GEN_REFLECT_CFG_ERROR_COUNTER_TX_CLEAR_SHIFT 0

/**************************************************************************************************
 * udma_gen_reflect
 *
 * Reflect configuration
 **************************************************************************************************/
struct udma_gen_reflect {
	/*
	 * [0x0] Global timer for reflect,
	 * After updating cache lien - each queue wait timer cycles until allow to send another
	 * update.
	 * Timer max count in SB cycles
	 */
	uint32_t timer_cfg;
	/* [0x4] */
	uint32_t rx_head_agent;
	/* [0x8] */
	uint32_t tx_head_agent;
	/* [0xc] Cfg for rx cmpl error agent */
	struct udma_gen_reflect_rx_cmpl_agent rx_cmpl_agent;
	/* [0xd0] Cfg for rx cmpl error agent */
	struct udma_gen_reflect_tx_cmpl_agent tx_cmpl_agent;
	/* [0x104] */
	uint32_t app_stat_agent;
	/* [0x108] AXI write configuration for reflect engine */
	struct udma_gen_reflect_axi axi;
	/* [0x11c] Global cfg for reflect engine */
	uint32_t cfg;
	/* [0x120] Cfg for error counter clear */
	struct udma_gen_reflect_cfg_error_counter cfg_error_counter;
};

/**** timer_cfg register ****/
/*
 * CNT value - default is 1us
 * Reset: 0x2ee       Access: RW
 */
#define UDMA_GEN_REFLECT_TIMER_CFG_VAL_MASK 0xFFFFFFFF
#define UDMA_GEN_REFLECT_TIMER_CFG_VAL_SHIFT 0

/**** rx_head_agent register ****/
/*
 * Enable to rx head changes to issue cache update
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_REFLECT_RX_HEAD_AGENT_ENABLE (1 << 0)
#define UDMA_GEN_REFLECT_RX_HEAD_AGENT_ENABLE_MASK 0x00000001
#define UDMA_GEN_REFLECT_RX_HEAD_AGENT_ENABLE_SHIFT 0
/*
 * Allow timer skip due agent changes (reach max_th)
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_REFLECT_RX_HEAD_AGENT_BYPASS_TIMER_EN (1 << 1)
#define UDMA_GEN_REFLECT_RX_HEAD_AGENT_BYPASS_TIMER_EN_MASK 0x00000002
#define UDMA_GEN_REFLECT_RX_HEAD_AGENT_BYPASS_TIMER_EN_SHIFT 1

/**** tx_head_agent register ****/
/*
 * Enable to tx head changes to issue cache update
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_REFLECT_TX_HEAD_AGENT_ENABLE (1 << 0)
#define UDMA_GEN_REFLECT_TX_HEAD_AGENT_ENABLE_MASK 0x00000001
#define UDMA_GEN_REFLECT_TX_HEAD_AGENT_ENABLE_SHIFT 0
/*
 * Allow timer skip due agent changes (reach max_th)
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_REFLECT_TX_HEAD_AGENT_BYPASS_TIMER_EN (1 << 1)
#define UDMA_GEN_REFLECT_TX_HEAD_AGENT_BYPASS_TIMER_EN_MASK 0x00000002
#define UDMA_GEN_REFLECT_TX_HEAD_AGENT_BYPASS_TIMER_EN_SHIFT 1

/**** app_stat_agent register ****/
/*
 * Enable to app status changes to issue cache update
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_REFLECT_APP_STAT_AGENT_ENABLE (1 << 0)
#define UDMA_GEN_REFLECT_APP_STAT_AGENT_ENABLE_MASK 0x00000001
#define UDMA_GEN_REFLECT_APP_STAT_AGENT_ENABLE_SHIFT 0
/*
 * Allow timer skip due agent changes (reach max_th)
 * Reset: 0x1         Access: RW
 */
#define UDMA_GEN_REFLECT_APP_STAT_AGENT_BYPASS_TIMER_EN (1 << 1)
#define UDMA_GEN_REFLECT_APP_STAT_AGENT_BYPASS_TIMER_EN_MASK 0x00000002
#define UDMA_GEN_REFLECT_APP_STAT_AGENT_BYPASS_TIMER_EN_SHIFT 1

/**** cfg register ****/
/*
 * Global enable for reflect engine
 * Reset: 0x1         Access: RW
 */
#define UDMA_GEN_REFLECT_CFG_GLOBAL_EN   (1 << 0)
#define UDMA_GEN_REFLECT_CFG_GLOBAL_EN_MASK 0x00000001
#define UDMA_GEN_REFLECT_CFG_GLOBAL_EN_SHIFT 0

/**************************************************************************************************
 * udma_gen_tgtid
 *
 * Target-ID configurations
 **************************************************************************************************/
struct udma_gen_tgtid {
	/* [0x0] Target-ID control */
	uint32_t cfg_tgtid_0;
};

/**** cfg_tgtid_0 register ****/
/*
 * use TGTID_n [7:0] from MSI-X Controller for MSI-X message
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_TGTID_CFG_TGTID_0_MSIX_TGTID_SEL (1 << 8)
#define UDMA_GEN_TGTID_CFG_TGTID_0_MSIX_TGTID_SEL_MASK 0x00000100
#define UDMA_GEN_TGTID_CFG_TGTID_0_MSIX_TGTID_SEL_SHIFT 8
/*
 * Enable write to all TGTID_n registers in the MSI-X Controller
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_TGTID_CFG_TGTID_0_MSIX_TGTID_ACCESS_EN (1 << 9)
#define UDMA_GEN_TGTID_CFG_TGTID_0_MSIX_TGTID_ACCESS_EN_MASK 0x00000200
#define UDMA_GEN_TGTID_CFG_TGTID_0_MSIX_TGTID_ACCESS_EN_SHIFT 9

/**************************************************************************************************
 * udma_gen_axi_master_shaper
 *
 * LImit number of outstanding Read/Write per udma
 **************************************************************************************************/
struct udma_gen_axi_master_shaper {
	/* [0x0] Configure number of allowed outstanding transaction */
	uint32_t num_of_allowed_os;
	/* [0x4] Get indication number of transaction in flight */
	uint32_t num_os_in_flight;
	/* [0x8] Clear num of os cnt */
	uint32_t clr_cnt;
	/* [0xc] Option to stop gracefully rd/wr channel */
	uint32_t halt;
};

/**** num_of_allowed_os register ****/
/* Reset: 0x80        Access: RW */
#define UDMA_GEN_AXI_MASTER_SHAPER_NUM_OF_ALLOWED_OS_RD_MASK 0x000003FF
#define UDMA_GEN_AXI_MASTER_SHAPER_NUM_OF_ALLOWED_OS_RD_SHIFT 0
/* Reset: 0x80        Access: RW */
#define UDMA_GEN_AXI_MASTER_SHAPER_NUM_OF_ALLOWED_OS_WR_MASK 0x03FF0000
#define UDMA_GEN_AXI_MASTER_SHAPER_NUM_OF_ALLOWED_OS_WR_SHIFT 16

/**** num_os_in_flight register ****/
/* Reset: 0x0         Access: RO */
#define UDMA_GEN_AXI_MASTER_SHAPER_NUM_OS_IN_FLIGHT_RD_MASK 0x000003FF
#define UDMA_GEN_AXI_MASTER_SHAPER_NUM_OS_IN_FLIGHT_RD_SHIFT 0
/* Reset: 0x0         Access: RO */
#define UDMA_GEN_AXI_MASTER_SHAPER_NUM_OS_IN_FLIGHT_WR_MASK 0x03FF0000
#define UDMA_GEN_AXI_MASTER_SHAPER_NUM_OS_IN_FLIGHT_WR_SHIFT 16

/**** clr_cnt register ****/
/* Reset: 0x0         Access: WO, PulseOnW */
#define UDMA_GEN_AXI_MASTER_SHAPER_CLR_CNT_RD (1 << 0)
#define UDMA_GEN_AXI_MASTER_SHAPER_CLR_CNT_RD_MASK 0x00000001
#define UDMA_GEN_AXI_MASTER_SHAPER_CLR_CNT_RD_SHIFT 0
/* Reset: 0x0         Access: WO, PulseOnW */
#define UDMA_GEN_AXI_MASTER_SHAPER_CLR_CNT_WR (1 << 1)
#define UDMA_GEN_AXI_MASTER_SHAPER_CLR_CNT_WR_MASK 0x00000002
#define UDMA_GEN_AXI_MASTER_SHAPER_CLR_CNT_WR_SHIFT 1

/**** halt register ****/
/*
 * halt rd channel
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_AXI_MASTER_SHAPER_HALT_RD (1 << 0)
#define UDMA_GEN_AXI_MASTER_SHAPER_HALT_RD_MASK 0x00000001
#define UDMA_GEN_AXI_MASTER_SHAPER_HALT_RD_SHIFT 0
/*
 * halt wr cahnnel
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_AXI_MASTER_SHAPER_HALT_WR (1 << 1)
#define UDMA_GEN_AXI_MASTER_SHAPER_HALT_WR_MASK 0x00000002
#define UDMA_GEN_AXI_MASTER_SHAPER_HALT_WR_SHIFT 1

/**************************************************************************************************
 * udma_gen_tgtaddr
 *
 * TGTADDR
 **************************************************************************************************/
struct udma_gen_tgtaddr {
	/* [0x0] Target-ID control */
	uint32_t cfg_vm_ctrl;
	/* [0x4] */
	uint32_t rsrvd_0;
	/* [0x8] TX queue TGTADDR/TGTID */
	uint32_t cfg_tx_vm;
	/* [0xc] RX queue TGTADDR/TGTID */
	uint32_t cfg_rx_vm;
};

/**** cfg_vm_ctrl register ****/
/*
 * For S2M queues, enable usage of the Target-ID from the buffer address 63:56
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_TGTADDR_CFG_VM_CTRL_RX_Q_TGTID_DESC_EN (1 << 0)
#define UDMA_GEN_TGTADDR_CFG_VM_CTRL_RX_Q_TGTID_DESC_EN_MASK 0x00000001
#define UDMA_GEN_TGTADDR_CFG_VM_CTRL_RX_Q_TGTID_DESC_EN_SHIFT 0
/*
 * For S2M queues , enable usage of the Target-ID from the configuration register (cfg_tgtid_3/4 used for
 * M2S queue_x)
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_TGTADDR_CFG_VM_CTRL_RX_Q_TGTID_QUEUE_EN (1 << 1)
#define UDMA_GEN_TGTADDR_CFG_VM_CTRL_RX_Q_TGTID_QUEUE_EN_MASK 0x00000002
#define UDMA_GEN_TGTADDR_CFG_VM_CTRL_RX_Q_TGTID_QUEUE_EN_SHIFT 1
/*
 * For M2S queues, enable usage of the Target-ID from the buffer address 63:56
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_TGTADDR_CFG_VM_CTRL_TX_Q_TGTID_DESC_EN (1 << 2)
#define UDMA_GEN_TGTADDR_CFG_VM_CTRL_TX_Q_TGTID_DESC_EN_MASK 0x00000004
#define UDMA_GEN_TGTADDR_CFG_VM_CTRL_TX_Q_TGTID_DESC_EN_SHIFT 2
/*
 * For M2S queues, enable usage of the Target-ID from the configuration register (cfg_tgtid_1/2 used for
 * M2S queue_x)
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_TGTADDR_CFG_VM_CTRL_TX_Q_TGTID_QUEUE_EN (1 << 3)
#define UDMA_GEN_TGTADDR_CFG_VM_CTRL_TX_Q_TGTID_QUEUE_EN_MASK 0x00000008
#define UDMA_GEN_TGTADDR_CFG_VM_CTRL_TX_Q_TGTID_QUEUE_EN_SHIFT 3

/**** cfg_tx_vm register ****/
/*
 * TX queue Target-ID value
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_TGTADDR_CFG_TX_VM_TX_Q_TGTID_MASK 0x0000FFFF
#define UDMA_GEN_TGTADDR_CFG_TX_VM_TX_Q_TGTID_SHIFT 0
/*
 * TX queue TGTADDR value
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_TGTADDR_CFG_TX_VM_TX_Q_TGTADDR_MASK 0xFFFF0000
#define UDMA_GEN_TGTADDR_CFG_TX_VM_TX_Q_TGTADDR_SHIFT 16

/**** cfg_rx_vm register ****/
/*
 * RX queue Target-ID value
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_TGTADDR_CFG_RX_VM_RX_Q_TGTID_MASK 0x0000FFFF
#define UDMA_GEN_TGTADDR_CFG_RX_VM_RX_Q_TGTID_SHIFT 0
/*
 * RX queue TGTADDR value
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_TGTADDR_CFG_RX_VM_RX_Q_TGTADDR_MASK 0xFFFF0000
#define UDMA_GEN_TGTADDR_CFG_RX_VM_RX_Q_TGTADDR_SHIFT 16

/**************************************************************************************************
 * udma_gen_axi_outstanding_cnt
 **************************************************************************************************/
struct udma_gen_axi_outstanding_cnt {
	/* [0x0] How many outstanding desc pref */
	uint32_t tx_desc_read;
	/* [0x4] How many outstanding data read */
	uint32_t tx_data_read;
	/* [0x8] How many outstanding cmpl write */
	uint32_t tx_cmpl_write;
	/* [0xc] How many outstanding desc pref */
	uint32_t rx_desc_read;
	/* [0x10] How many outstanding data write */
	uint32_t rx_data_write;
	/* [0x14] How many outstanding cmpl write */
	uint32_t rx_cmpl_write;
	/* [0x18] Write to this register will reset Outstnading cnt to zero */
	uint32_t rst_counters;
};

/**** tx_desc_read register ****/
/* Reset: 0x0         Access: RO */
#define UDMA_GEN_AXI_OUTSTANDING_CNT_TX_DESC_READ_VALUE_MASK 0xFF000000
#define UDMA_GEN_AXI_OUTSTANDING_CNT_TX_DESC_READ_VALUE_SHIFT 24

/**** tx_data_read register ****/
/* Reset: 0x0         Access: RO */
#define UDMA_GEN_AXI_OUTSTANDING_CNT_TX_DATA_READ_VALUE_MASK 0xFF000000
#define UDMA_GEN_AXI_OUTSTANDING_CNT_TX_DATA_READ_VALUE_SHIFT 24

/**** tx_cmpl_write register ****/
/* Reset: 0x0         Access: RO */
#define UDMA_GEN_AXI_OUTSTANDING_CNT_TX_CMPL_WRITE_VALUE_MASK 0xFF000000
#define UDMA_GEN_AXI_OUTSTANDING_CNT_TX_CMPL_WRITE_VALUE_SHIFT 24

/**** rx_desc_read register ****/
/* Reset: 0x0         Access: RO */
#define UDMA_GEN_AXI_OUTSTANDING_CNT_RX_DESC_READ_VALUE_MASK 0xFF000000
#define UDMA_GEN_AXI_OUTSTANDING_CNT_RX_DESC_READ_VALUE_SHIFT 24

/**** rx_data_write register ****/
/* Reset: 0x0         Access: RO */
#define UDMA_GEN_AXI_OUTSTANDING_CNT_RX_DATA_WRITE_VALUE_MASK 0xFF000000
#define UDMA_GEN_AXI_OUTSTANDING_CNT_RX_DATA_WRITE_VALUE_SHIFT 24

/**** rx_cmpl_write register ****/
/* Reset: 0x0         Access: RO */
#define UDMA_GEN_AXI_OUTSTANDING_CNT_RX_CMPL_WRITE_VALUE_MASK 0xFF000000
#define UDMA_GEN_AXI_OUTSTANDING_CNT_RX_CMPL_WRITE_VALUE_SHIFT 24

/**** rst_counters register ****/
/* Reset: 0x0         Access: WO */
#define UDMA_GEN_AXI_OUTSTANDING_CNT_RST_COUNTERS_RX_CMPL_WRITE (1 << 26)
#define UDMA_GEN_AXI_OUTSTANDING_CNT_RST_COUNTERS_RX_CMPL_WRITE_MASK 0x04000000
#define UDMA_GEN_AXI_OUTSTANDING_CNT_RST_COUNTERS_RX_CMPL_WRITE_SHIFT 26
/* Reset: 0x0         Access: WO */
#define UDMA_GEN_AXI_OUTSTANDING_CNT_RST_COUNTERS_RX_DATA_WRITE (1 << 27)
#define UDMA_GEN_AXI_OUTSTANDING_CNT_RST_COUNTERS_RX_DATA_WRITE_MASK 0x08000000
#define UDMA_GEN_AXI_OUTSTANDING_CNT_RST_COUNTERS_RX_DATA_WRITE_SHIFT 27
/* Reset: 0x0         Access: WO */
#define UDMA_GEN_AXI_OUTSTANDING_CNT_RST_COUNTERS_RX_DESC_READ (1 << 28)
#define UDMA_GEN_AXI_OUTSTANDING_CNT_RST_COUNTERS_RX_DESC_READ_MASK 0x10000000
#define UDMA_GEN_AXI_OUTSTANDING_CNT_RST_COUNTERS_RX_DESC_READ_SHIFT 28
/* Reset: 0x0         Access: WO */
#define UDMA_GEN_AXI_OUTSTANDING_CNT_RST_COUNTERS_TX_CMPL_WRITE (1 << 29)
#define UDMA_GEN_AXI_OUTSTANDING_CNT_RST_COUNTERS_TX_CMPL_WRITE_MASK 0x20000000
#define UDMA_GEN_AXI_OUTSTANDING_CNT_RST_COUNTERS_TX_CMPL_WRITE_SHIFT 29
/* Reset: 0x0         Access: WO */
#define UDMA_GEN_AXI_OUTSTANDING_CNT_RST_COUNTERS_TX_DATA_READ (1 << 30)
#define UDMA_GEN_AXI_OUTSTANDING_CNT_RST_COUNTERS_TX_DATA_READ_MASK 0x40000000
#define UDMA_GEN_AXI_OUTSTANDING_CNT_RST_COUNTERS_TX_DATA_READ_SHIFT 30
/* Reset: 0x0         Access: WO */
#define UDMA_GEN_AXI_OUTSTANDING_CNT_RST_COUNTERS_TX_DESC_READ (1 << 31)
#define UDMA_GEN_AXI_OUTSTANDING_CNT_RST_COUNTERS_TX_DESC_READ_MASK 0x80000000
#define UDMA_GEN_AXI_OUTSTANDING_CNT_RST_COUNTERS_TX_DESC_READ_SHIFT 31

/**************************************************************************************************
 * udma_gen_axi_error_detection_table
 *
 * Each axi generator has an error detecion table, the Addr to the table is
 * {axi_parity_error,axi_timeout_error,axi_response_error} Instance 0 - M2S - Desc read
 * Instance 1 -  M2S - Data read
 * Instance 2 -  M2s -  Cmpl Write
 * Instance 3 -  S2M -  Desc read
 * Instance 4 - S2M -   Data Write
 * Instance 5 - S2M -  Cmpl Write
 * Instance 6 - MSIX
 **************************************************************************************************/
struct udma_gen_axi_error_detection_table {
	/* [0x0] Addr to table is {axi_parity_error,axi_timeout_error,axi_response_error} */
	uint32_t addr0;
	/* [0x4] */
	uint32_t addr1;
	/* [0x8] */
	uint32_t addr2;
	/* [0xc] */
	uint32_t addr3;
	/* [0x10] */
	uint32_t addr4;
	/* [0x14] */
	uint32_t addr5;
	/* [0x18] */
	uint32_t addr6;
	/* [0x1c] */
	uint32_t addr7;
	/* [0x20] */
	uint32_t addr8;
	/* [0x24] */
	uint32_t addr9;
	/* [0x28] */
	uint32_t addr10;
	/* [0x2c] */
	uint32_t addr11;
	/* [0x30] */
	uint32_t addr12;
	/* [0x34] */
	uint32_t addr13;
	/* [0x38] */
	uint32_t addr14;
	/* [0x3c] */
	uint32_t addr15;
};

/**** addr0 register ****/
/*
 * Coding of error type
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR0_ERROR_TYPE_MASK 0x00000007
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR0_ERROR_TYPE_SHIFT 0
/*
 * decide if action required
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR0_ERROR_INDICATION (1 << 3)
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR0_ERROR_INDICATION_MASK 0x00000008
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR0_ERROR_INDICATION_SHIFT 3

/**** addr1 register ****/
/*
 * Coding of error type
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR1_ERROR_TYPE_MASK 0x00000007
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR1_ERROR_TYPE_SHIFT 0
/*
 * decide if action required
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR1_ERROR_INDICATION (1 << 3)
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR1_ERROR_INDICATION_MASK 0x00000008
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR1_ERROR_INDICATION_SHIFT 3

/**** addr2 register ****/
/*
 * Coding of error type
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR2_ERROR_TYPE_MASK 0x00000007
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR2_ERROR_TYPE_SHIFT 0
/*
 * decide if action required
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR2_ERROR_INDICATION (1 << 3)
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR2_ERROR_INDICATION_MASK 0x00000008
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR2_ERROR_INDICATION_SHIFT 3

/**** addr3 register ****/
/*
 * Coding of error type
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR3_ERROR_TYPE_MASK 0x00000007
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR3_ERROR_TYPE_SHIFT 0
/*
 * decide if action required
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR3_ERROR_INDICATION (1 << 3)
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR3_ERROR_INDICATION_MASK 0x00000008
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR3_ERROR_INDICATION_SHIFT 3

/**** addr4 register ****/
/*
 * Coding of error type
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR4_ERROR_TYPE_MASK 0x00000007
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR4_ERROR_TYPE_SHIFT 0
/*
 * decide if action required
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR4_ERROR_INDICATION (1 << 3)
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR4_ERROR_INDICATION_MASK 0x00000008
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR4_ERROR_INDICATION_SHIFT 3

/**** addr5 register ****/
/*
 * Coding of error type
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR5_ERROR_TYPE_MASK 0x00000007
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR5_ERROR_TYPE_SHIFT 0
/*
 * decide if action required
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR5_ERROR_INDICATION (1 << 3)
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR5_ERROR_INDICATION_MASK 0x00000008
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR5_ERROR_INDICATION_SHIFT 3

/**** addr6 register ****/
/*
 * Coding of error type
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR6_ERROR_TYPE_MASK 0x00000007
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR6_ERROR_TYPE_SHIFT 0
/*
 * decide if action required
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR6_ERROR_INDICATION (1 << 3)
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR6_ERROR_INDICATION_MASK 0x00000008
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR6_ERROR_INDICATION_SHIFT 3

/**** addr7 register ****/
/*
 * Coding of error type
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR7_ERROR_TYPE_MASK 0x00000007
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR7_ERROR_TYPE_SHIFT 0
/*
 * decide if action required
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR7_ERROR_INDICATION (1 << 3)
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR7_ERROR_INDICATION_MASK 0x00000008
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR7_ERROR_INDICATION_SHIFT 3

/**** addr8 register ****/
/*
 * Coding of error type
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR8_ERROR_TYPE_MASK 0x00000007
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR8_ERROR_TYPE_SHIFT 0
/*
 * decide if action required
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR8_ERROR_INDICATION (1 << 3)
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR8_ERROR_INDICATION_MASK 0x00000008
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR8_ERROR_INDICATION_SHIFT 3

/**** addr9 register ****/
/*
 * Coding of error type
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR9_ERROR_TYPE_MASK 0x00000007
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR9_ERROR_TYPE_SHIFT 0
/*
 * decide if action required
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR9_ERROR_INDICATION (1 << 3)
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR9_ERROR_INDICATION_MASK 0x00000008
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR9_ERROR_INDICATION_SHIFT 3

/**** addr10 register ****/
/*
 * Coding of error type
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR10_ERROR_TYPE_MASK 0x00000007
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR10_ERROR_TYPE_SHIFT 0
/*
 * decide if action required
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR10_ERROR_INDICATION (1 << 3)
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR10_ERROR_INDICATION_MASK 0x00000008
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR10_ERROR_INDICATION_SHIFT 3

/**** addr11 register ****/
/*
 * Coding of error type
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR11_ERROR_TYPE_MASK 0x00000007
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR11_ERROR_TYPE_SHIFT 0
/*
 * decide if action required
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR11_ERROR_INDICATION (1 << 3)
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR11_ERROR_INDICATION_MASK 0x00000008
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR11_ERROR_INDICATION_SHIFT 3

/**** addr12 register ****/
/*
 * Coding of error type
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR12_ERROR_TYPE_MASK 0x00000007
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR12_ERROR_TYPE_SHIFT 0
/*
 * decide if action required
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR12_ERROR_INDICATION (1 << 3)
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR12_ERROR_INDICATION_MASK 0x00000008
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR12_ERROR_INDICATION_SHIFT 3

/**** addr13 register ****/
/*
 * Coding of error type
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR13_ERROR_TYPE_MASK 0x00000007
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR13_ERROR_TYPE_SHIFT 0
/*
 * decide if action required
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR13_ERROR_INDICATION (1 << 3)
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR13_ERROR_INDICATION_MASK 0x00000008
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR13_ERROR_INDICATION_SHIFT 3

/**** addr14 register ****/
/*
 * Coding of error type
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR14_ERROR_TYPE_MASK 0x00000007
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR14_ERROR_TYPE_SHIFT 0
/*
 * decide if action required
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR14_ERROR_INDICATION (1 << 3)
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR14_ERROR_INDICATION_MASK 0x00000008
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR14_ERROR_INDICATION_SHIFT 3

/**** addr15 register ****/
/*
 * Coding of error type
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR15_ERROR_TYPE_MASK 0x00000007
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR15_ERROR_TYPE_SHIFT 0
/*
 * decide if action required
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR15_ERROR_INDICATION (1 << 3)
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR15_ERROR_INDICATION_MASK 0x00000008
#define UDMA_GEN_AXI_ERROR_DETECTION_TABLE_ADDR15_ERROR_INDICATION_SHIFT 3

/**************************************************************************************************
 * udma_gen_axi_error_control
 *
 * Each axi generator has an error control table, the Addr to the table is {queue_number,error_type
 * (from error detection_table}
 * Instance 0 - M2S - Desc read
 * Instance 1 -  M2S - Data read
 * Instance 2 -  M2s -  Cmpl Write
 * Instance 3 -  S2M -  Desc read
 * Instance 4 - S2M -   Data Write
 * Instance 5 - S2M -  Cmpl Write
 * Instance 6 - MSIX
 **************************************************************************************************/
struct udma_gen_axi_error_control {
	/* [0x0] */
	uint32_t table_addr;
	/* [0x4] */
	uint32_t table_data;
};

/**** table_addr register ****/
/* Reset: 0x0         Access: RW */
#define UDMA_GEN_AXI_ERROR_CONTROL_TABLE_ADDR_VAL_MASK 0x0000007F
#define UDMA_GEN_AXI_ERROR_CONTROL_TABLE_ADDR_VAL_SHIFT 0

/**** table_data register ****/
/*
 * This bit stop rx for relevantg queue
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_AXI_ERROR_CONTROL_TABLE_DATA_ENABLE_RX_STOP (1 << 0)
#define UDMA_GEN_AXI_ERROR_CONTROL_TABLE_DATA_ENABLE_RX_STOP_MASK 0x00000001
#define UDMA_GEN_AXI_ERROR_CONTROL_TABLE_DATA_ENABLE_RX_STOP_SHIFT 0
/*
 * This bit stop tx for relevantg queue
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_AXI_ERROR_CONTROL_TABLE_DATA_ENABLE_TX_STOP (1 << 1)
#define UDMA_GEN_AXI_ERROR_CONTROL_TABLE_DATA_ENABLE_TX_STOP_MASK 0x00000002
#define UDMA_GEN_AXI_ERROR_CONTROL_TABLE_DATA_ENABLE_TX_STOP_SHIFT 1
/*
 * this bit sample the error that occured to  the status register (for relevant queue)
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_AXI_ERROR_CONTROL_TABLE_DATA_SET_DETECTION_STATUS (1 << 2)
#define UDMA_GEN_AXI_ERROR_CONTROL_TABLE_DATA_SET_DETECTION_STATUS_MASK 0x00000004
#define UDMA_GEN_AXI_ERROR_CONTROL_TABLE_DATA_SET_DETECTION_STATUS_SHIFT 2
/* Reset: 0x0         Access: RW */
#define UDMA_GEN_AXI_ERROR_CONTROL_TABLE_DATA_SPARE_BIT (1 << 3)
#define UDMA_GEN_AXI_ERROR_CONTROL_TABLE_DATA_SPARE_BIT_MASK 0x00000008
#define UDMA_GEN_AXI_ERROR_CONTROL_TABLE_DATA_SPARE_BIT_SHIFT 3
/*
 * this bit decide if to set INT A/B/C/D for relevant queue
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_AXI_ERROR_CONTROL_TABLE_DATA_ENABLE_INT_MASK 0x000000F0
#define UDMA_GEN_AXI_ERROR_CONTROL_TABLE_DATA_ENABLE_INT_SHIFT 4

/**************************************************************************************************
 * udma_gen_axi_queue
 **************************************************************************************************/
struct udma_gen_axi_queue {
	/* [0x0] this register can change axi queue state ACTIVE/NON_ACTIVE */
	uint32_t state_request;
	/* [0x4] This register is read on clear on read */
	uint32_t error_status;
	/* [0x8] */
	uint32_t cfg;
};

/**** state_request register ****/
/*
 * Change rx queue to active state
 * Reset: 0x0         Access: WO
 */
#define UDMA_GEN_AXI_QUEUE_STATE_REQUEST_RX_SET_QUEUE_STATE_ACTIVE (1 << 0)
#define UDMA_GEN_AXI_QUEUE_STATE_REQUEST_RX_SET_QUEUE_STATE_ACTIVE_MASK 0x00000001
#define UDMA_GEN_AXI_QUEUE_STATE_REQUEST_RX_SET_QUEUE_STATE_ACTIVE_SHIFT 0
/*
 * Change rx queue to non-active state
 * Reset: 0x0         Access: WO
 */
#define UDMA_GEN_AXI_QUEUE_STATE_REQUEST_RX_SET_QUEUE_STATE_NON_ACTIVE (1 << 1)
#define UDMA_GEN_AXI_QUEUE_STATE_REQUEST_RX_SET_QUEUE_STATE_NON_ACTIVE_MASK 0x00000002
#define UDMA_GEN_AXI_QUEUE_STATE_REQUEST_RX_SET_QUEUE_STATE_NON_ACTIVE_SHIFT 1
/*
 * Change tx queue to active state
 * Reset: 0x0         Access: WO
 */
#define UDMA_GEN_AXI_QUEUE_STATE_REQUEST_TX_SET_QUEUE_STATE_ACTIVE (1 << 2)
#define UDMA_GEN_AXI_QUEUE_STATE_REQUEST_TX_SET_QUEUE_STATE_ACTIVE_MASK 0x00000004
#define UDMA_GEN_AXI_QUEUE_STATE_REQUEST_TX_SET_QUEUE_STATE_ACTIVE_SHIFT 2
/*
 * Change tx queue to non-active state
 * Reset: 0x0         Access: WO
 */
#define UDMA_GEN_AXI_QUEUE_STATE_REQUEST_TX_SET_QUEUE_STATE_NON_ACTIVE (1 << 3)
#define UDMA_GEN_AXI_QUEUE_STATE_REQUEST_TX_SET_QUEUE_STATE_NON_ACTIVE_MASK 0x00000008
#define UDMA_GEN_AXI_QUEUE_STATE_REQUEST_TX_SET_QUEUE_STATE_NON_ACTIVE_SHIFT 3

/**** error_status register ****/
/*
 * axi_parity_error,axi_timeout_error,axi_response_error}
 * Reset: 0x0         Access: RO
 */
#define UDMA_GEN_AXI_QUEUE_ERROR_STATUS_M2S_DESC_READ_MASK 0x0000000F
#define UDMA_GEN_AXI_QUEUE_ERROR_STATUS_M2S_DESC_READ_SHIFT 0
/*
 * axi_parity_error,axi_timeout_error,axi_response_error}
 * Reset: 0x0         Access: RO
 */
#define UDMA_GEN_AXI_QUEUE_ERROR_STATUS_M2S_DATA_READ_MASK 0x000000F0
#define UDMA_GEN_AXI_QUEUE_ERROR_STATUS_M2S_DATA_READ_SHIFT 4
/*
 * axi_parity_error,axi_timeout_error,axi_response_error}
 * Reset: 0x0         Access: RO
 */
#define UDMA_GEN_AXI_QUEUE_ERROR_STATUS_M2S_CMPL_WRITE_MASK 0x00000F00
#define UDMA_GEN_AXI_QUEUE_ERROR_STATUS_M2S_CMPL_WRITE_SHIFT 8
/*
 * axi_parity_error,axi_timeout_error,axi_response_error}
 * Reset: 0x0         Access: RO
 */
#define UDMA_GEN_AXI_QUEUE_ERROR_STATUS_S2M_DESC_READ_MASK 0x0000F000
#define UDMA_GEN_AXI_QUEUE_ERROR_STATUS_S2M_DESC_READ_SHIFT 12
/*
 * axi_parity_error,axi_timeout_error,axi_response_error}
 * Reset: 0x0         Access: RO
 */
#define UDMA_GEN_AXI_QUEUE_ERROR_STATUS_S2M_DATA_WRITE_MASK 0x000F0000
#define UDMA_GEN_AXI_QUEUE_ERROR_STATUS_S2M_DATA_WRITE_SHIFT 16
/*
 * axi_parity_error,axi_timeout_error,axi_response_error}
 * Reset: 0x0         Access: RO
 */
#define UDMA_GEN_AXI_QUEUE_ERROR_STATUS_S2M_CMPL_WRITE_MASK 0x00F00000
#define UDMA_GEN_AXI_QUEUE_ERROR_STATUS_S2M_CMPL_WRITE_SHIFT 20
/*
 * axi_parity_error,axi_timeout_error,axi_response_error}
 * Reset: 0x0         Access: RO
 */
#define UDMA_GEN_AXI_QUEUE_ERROR_STATUS_MSIX_MASK 0x0F000000
#define UDMA_GEN_AXI_QUEUE_ERROR_STATUS_MSIX_SHIFT 24
/*
 * indicates if error occured - when value is bigger then 0 error occured, and value means how many
 * times, stuck at max_error_occured (below register) until cleared
 * Reset: 0x0         Access: RO
 */
#define UDMA_GEN_AXI_QUEUE_ERROR_STATUS_ERROR_OCCURED_MASK 0xF0000000
#define UDMA_GEN_AXI_QUEUE_ERROR_STATUS_ERROR_OCCURED_SHIFT 28

/**** cfg register ****/
/*
 * State of axi error per queue
 * 0 -ACTIVE
 * 1 - NON_ACTIVE
 * Reset: 0x0         Access: RO
 */
#define UDMA_GEN_AXI_QUEUE_CFG_RX_STATE  (1 << 0)
#define UDMA_GEN_AXI_QUEUE_CFG_RX_STATE_MASK 0x00000001
#define UDMA_GEN_AXI_QUEUE_CFG_RX_STATE_SHIFT 0
/*
 * indicates to "mark" rx pkt (CMPL)
 * 0-  dont mark pkt with error
 * 1 - mark pkt with error if queue in NON_ACTIVE state
 * 2 -  mark any pkt with error
 *
 * Marking will cause
 * 1.Stopping Queue prefetch
 * 2.Drop pkt from stream
 * 3.Set Error bit in S2M CMPL
 * Each one of the three behaviors can be masked independently
 * Reset: 0x1         Access: RW
 */
#define UDMA_GEN_AXI_QUEUE_CFG_RX_MARK_PKT_MASK 0x00000030
#define UDMA_GEN_AXI_QUEUE_CFG_RX_MARK_PKT_SHIFT 4
/*
 * When set- masked the rx stop prefetch (Prefetch will occur)
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_AXI_QUEUE_CFG_RX_MASK_STOP_DESC_PREFETCH (1 << 6)
#define UDMA_GEN_AXI_QUEUE_CFG_RX_MASK_STOP_DESC_PREFETCH_MASK 0x00000040
#define UDMA_GEN_AXI_QUEUE_CFG_RX_MASK_STOP_DESC_PREFETCH_SHIFT 6
/*
 * When set- masked the rx drop stream (Pkt will NOT! Be dropped)
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_AXI_QUEUE_CFG_RX_MASK_DROP_STREAM (1 << 7)
#define UDMA_GEN_AXI_QUEUE_CFG_RX_MASK_DROP_STREAM_MASK 0x00000080
#define UDMA_GEN_AXI_QUEUE_CFG_RX_MASK_DROP_STREAM_SHIFT 7
/*
 * When set- masked the cmpl error indication (No Error will be reported in S2M CMPL due to queue in
 * non active state)
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_AXI_QUEUE_CFG_RX_MASK_CMPL_ERROR (1 << 8)
#define UDMA_GEN_AXI_QUEUE_CFG_RX_MASK_CMPL_ERROR_MASK 0x00000100
#define UDMA_GEN_AXI_QUEUE_CFG_RX_MASK_CMPL_ERROR_SHIFT 8
/*
 * State of axi error per queue
 * 0 -ACTIVE
 * 1 - NON_ACTIVE
 * Reset: 0x0         Access: RO
 */
#define UDMA_GEN_AXI_QUEUE_CFG_TX_STATE  (1 << 12)
#define UDMA_GEN_AXI_QUEUE_CFG_TX_STATE_MASK 0x00001000
#define UDMA_GEN_AXI_QUEUE_CFG_TX_STATE_SHIFT 12
/*
 * indicates to "mark" tx pkt (STREAM)
 * 0-  dont mark pkt with error
 * 1 - mark pkt with error if queue in NON_ACTIVE state
 * 2 -  mark any pkt with error
 * Marking will cause
 * 1.Stopping Queue prefetch
 * 2. Stopping Queue scheduling
 * 3. Set Error bit in M2S CMPL
 * 4. Set Error bit in AXI_STREAM i/f with APP
 * Each one of the four  behaviors can be masked independently
 * Reset: 0x1         Access: RW
 */
#define UDMA_GEN_AXI_QUEUE_CFG_TX_MARK_PKT_MASK 0x00030000
#define UDMA_GEN_AXI_QUEUE_CFG_TX_MARK_PKT_SHIFT 16
/*
 * When set- masked the tx stop prefetch (Prefetch will occur)
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_AXI_QUEUE_CFG_TX_MASK_STOP_DESC_PREFETCH (1 << 18)
#define UDMA_GEN_AXI_QUEUE_CFG_TX_MASK_STOP_DESC_PREFETCH_MASK 0x00040000
#define UDMA_GEN_AXI_QUEUE_CFG_TX_MASK_STOP_DESC_PREFETCH_SHIFT 18
/*
 * When set- masked the tx pkt sched (Pkt will BE! Sched)
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_AXI_QUEUE_CFG_TX_MASK_STOP_SCHED (1 << 19)
#define UDMA_GEN_AXI_QUEUE_CFG_TX_MASK_STOP_SCHED_MASK 0x00080000
#define UDMA_GEN_AXI_QUEUE_CFG_TX_MASK_STOP_SCHED_SHIFT 19
/*
 * When set- masked the cmpl error indication (No Error will be reported in M2S CMPL due to queue in
 * non active state)
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_AXI_QUEUE_CFG_TX_MASK_CMPL_ERROR (1 << 20)
#define UDMA_GEN_AXI_QUEUE_CFG_TX_MASK_CMPL_ERROR_MASK 0x00100000
#define UDMA_GEN_AXI_QUEUE_CFG_TX_MASK_CMPL_ERROR_SHIFT 20
/*
 * When set Mask the error bit indication to APP on axi stream
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_AXI_QUEUE_CFG_TX_MASK_STREAM_ERROR (1 << 21)
#define UDMA_GEN_AXI_QUEUE_CFG_TX_MASK_STREAM_ERROR_MASK 0x00200000
#define UDMA_GEN_AXI_QUEUE_CFG_TX_MASK_STREAM_ERROR_SHIFT 21
/*
 * Max value that error occurred cnt will cnt for (from error status register), when reaching to
 * this value, cnt will stuck until reset (clear on read)
 * Reset: 0xf         Access: RW
 */
#define UDMA_GEN_AXI_QUEUE_CFG_MAX_ERROR_OCCURRED_MASK 0x0F000000
#define UDMA_GEN_AXI_QUEUE_CFG_MAX_ERROR_OCCURRED_SHIFT 24

/**************************************************************************************************
 * udma_gen_pp
 *
 * Push packet desc cfg
 **************************************************************************************************/
struct udma_gen_pp {
	/* [0x0] Global_cfg */
	uint32_t cfg;
	/* [0x4] This value will be used to mask pp strb */
	uint32_t strb_detection_mask;
	/*
	 * [0x8] This value will be used to match strb val
	 * (in_strb & strb_detection_mask) == (strb_detection_val & strb_detectin_val)
	 */
	uint32_t strb_detection_val;
	/* [0xc] FE to get queue number */
	struct al_cell_fe_regs queue_fe;
	/* [0x10] FE to get if desc is tx or rx */
	struct al_cell_fe_regs tx_fe;
};

/**** cfg register ****/
/*
 * When set prefetch engine will not work, and desc will be pushed to pref_desc_fifo using push
 * packet i/f
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_PP_CFG_RX_PP_MODE_EN    (1 << 0)
#define UDMA_GEN_PP_CFG_RX_PP_MODE_EN_MASK 0x00000001
#define UDMA_GEN_PP_CFG_RX_PP_MODE_EN_SHIFT 0
/*
 * When set prefetch engine will not work, and desc will be pushed to pref_desc_fifo using push
 * packet i/f
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_PP_CFG_TX_PP_MODE_EN    (1 << 1)
#define UDMA_GEN_PP_CFG_TX_PP_MODE_EN_MASK 0x00000002
#define UDMA_GEN_PP_CFG_TX_PP_MODE_EN_SHIFT 1
/*
 * HW detect rewrite of strb  - enable to mask this error
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_PP_CFG_STRB_ERR_MASK    (1 << 3)
#define UDMA_GEN_PP_CFG_STRB_ERR_MASK_MASK 0x00000008
#define UDMA_GEN_PP_CFG_STRB_ERR_MASK_SHIFT 3
/*
 * HW detect PP want to push desc when prefetch fifo full - enable to mask this error
 * Reset: 0x0         Access: RW
 */
#define UDMA_GEN_PP_CFG_FIFO_FULL_ERR_MASK (1 << 4)
#define UDMA_GEN_PP_CFG_FIFO_FULL_ERR_MASK_MASK 0x00000010
#define UDMA_GEN_PP_CFG_FIFO_FULL_ERR_MASK_SHIFT 4

/**** strb_detection_mask register ****/
/* Reset: 0xffff      Access: RW */
#define UDMA_GEN_PP_STRB_DETECTION_MASK_VAL_MASK 0x0000FFFF
#define UDMA_GEN_PP_STRB_DETECTION_MASK_VAL_SHIFT 0

/**** strb_detection_val register ****/
/* Reset: 0xffff      Access: RW */
#define UDMA_GEN_PP_STRB_DETECTION_VAL_VAL_MASK 0x0000FFFF
#define UDMA_GEN_PP_STRB_DETECTION_VAL_VAL_SHIFT 0

/**************************************************************************************************
 * udma_gen_pmu
 *
 * Here you can configure in which q PMU counter will count
 **************************************************************************************************/
struct udma_gen_pmu {
	/*
	 * [0x0] RX HDR fifo
	 * PMUhas 3 counters
	 * 1.Fifo size lower then low th
	 * 2.FIfo size higher then high th
	 * 3.FIfo size is between th
	 */
	uint32_t rx_hdr;
	/*
	 * [0x4] RX DATA fifo
	 * PMUhas 3 counters
	 * 1.Fifo size lower then low th
	 * 2.FIfo size higher then high th
	 * 3.FIfo size is between th
	 */
	uint32_t rx_data;
	/*
	 * [0x8] TX DATA fifo
	 * PMUhas 3 counters
	 * 1.Fifo size lower then low th
	 * 2.FIfo size higher then high th
	 * 3.FIfo size is between th
	 */
	uint32_t tx_data;
	/* [0xc] PMU can count drop packet on selected queues, (4 queues to count on them) */
	uint32_t rx_drop;
};

/**** rx_hdr register ****/
/* Reset: 0x8         Access: RW */
#define UDMA_GEN_PMU_RX_HDR_INUSE_LOW_TH_MASK 0x0000003F
#define UDMA_GEN_PMU_RX_HDR_INUSE_LOW_TH_SHIFT 0
/* Reset: 0x10        Access: RW */
#define UDMA_GEN_PMU_RX_HDR_INUSE_HIGH_TH_MASK 0x003F0000
#define UDMA_GEN_PMU_RX_HDR_INUSE_HIGH_TH_SHIFT 16

/**** rx_data register ****/
/* Reset: 0x8         Access: RW */
#define UDMA_GEN_PMU_RX_DATA_INUSE_LOW_TH_MASK 0x0000007F
#define UDMA_GEN_PMU_RX_DATA_INUSE_LOW_TH_SHIFT 0
/* Reset: 0x10        Access: RW */
#define UDMA_GEN_PMU_RX_DATA_INUSE_HIGH_TH_MASK 0x007F0000
#define UDMA_GEN_PMU_RX_DATA_INUSE_HIGH_TH_SHIFT 16

/**** tx_data register ****/
/* Reset: 0x20        Access: RW */
#define UDMA_GEN_PMU_TX_DATA_INUSE_LOW_TH_MASK 0x000007FF
#define UDMA_GEN_PMU_TX_DATA_INUSE_LOW_TH_SHIFT 0
/* Reset: 0x200       Access: RW */
#define UDMA_GEN_PMU_TX_DATA_INUSE_HIGH_TH_MASK 0x07FF0000
#define UDMA_GEN_PMU_TX_DATA_INUSE_HIGH_TH_SHIFT 16

/**** rx_drop register ****/
/* Reset: 0x0         Access: RW */
#define UDMA_GEN_PMU_RX_DROP_Q0_CNT_MASK 0x0000000F
#define UDMA_GEN_PMU_RX_DROP_Q0_CNT_SHIFT 0
/* Reset: 0x1         Access: RW */
#define UDMA_GEN_PMU_RX_DROP_Q1_CNT_MASK 0x00000F00
#define UDMA_GEN_PMU_RX_DROP_Q1_CNT_SHIFT 8
/* Reset: 0x2         Access: RW */
#define UDMA_GEN_PMU_RX_DROP_Q2_CNT_MASK 0x000F0000
#define UDMA_GEN_PMU_RX_DROP_Q2_CNT_SHIFT 16
/* Reset: 0x3         Access: RW */
#define UDMA_GEN_PMU_RX_DROP_Q3_CNT_MASK 0x0F000000
#define UDMA_GEN_PMU_RX_DROP_Q3_CNT_SHIFT 24

/**************************************************************************************************
 * udma_gen_init_memory
 **************************************************************************************************/
struct udma_gen_init_memory {
	/* [0x0] */
	uint32_t rx_init_trigger;
	/* [0x4] */
	uint32_t rx_init_in_progress;
	/* [0x8] */
	uint32_t tx_init_trigger;
	/* [0xc] */
	uint32_t tx_init_in_progress;
	/* [0x10] */
	uint32_t rsrvd_0[4];
};

/**** rx_init_trigger register ****/
/* Reset: 0x1         Access: RW */
#define UDMA_GEN_INIT_MEMORY_RX_INIT_TRIGGER_CMPL_MEM0 (1 << 0)
#define UDMA_GEN_INIT_MEMORY_RX_INIT_TRIGGER_CMPL_MEM0_MASK 0x00000001
#define UDMA_GEN_INIT_MEMORY_RX_INIT_TRIGGER_CMPL_MEM0_SHIFT 0
/* Reset: 0x1         Access: RW */
#define UDMA_GEN_INIT_MEMORY_RX_INIT_TRIGGER_CMPL_MEM1 (1 << 1)
#define UDMA_GEN_INIT_MEMORY_RX_INIT_TRIGGER_CMPL_MEM1_MASK 0x00000002
#define UDMA_GEN_INIT_MEMORY_RX_INIT_TRIGGER_CMPL_MEM1_SHIFT 1
/* Reset: 0x1         Access: RW */
#define UDMA_GEN_INIT_MEMORY_RX_INIT_TRIGGER_PREF_DESC0 (1 << 2)
#define UDMA_GEN_INIT_MEMORY_RX_INIT_TRIGGER_PREF_DESC0_MASK 0x00000004
#define UDMA_GEN_INIT_MEMORY_RX_INIT_TRIGGER_PREF_DESC0_SHIFT 2
/* Reset: 0x1         Access: RW */
#define UDMA_GEN_INIT_MEMORY_RX_INIT_TRIGGER_PREF_DESC1 (1 << 3)
#define UDMA_GEN_INIT_MEMORY_RX_INIT_TRIGGER_PREF_DESC1_MASK 0x00000008
#define UDMA_GEN_INIT_MEMORY_RX_INIT_TRIGGER_PREF_DESC1_SHIFT 3

/**** rx_init_in_progress register ****/
/* Reset: 0x0         Access: RO */
#define UDMA_GEN_INIT_MEMORY_RX_INIT_IN_PROGRESS_CMPL_MEM1 (1 << 0)
#define UDMA_GEN_INIT_MEMORY_RX_INIT_IN_PROGRESS_CMPL_MEM1_MASK 0x00000001
#define UDMA_GEN_INIT_MEMORY_RX_INIT_IN_PROGRESS_CMPL_MEM1_SHIFT 0
/* Reset: 0x0         Access: RO */
#define UDMA_GEN_INIT_MEMORY_RX_INIT_IN_PROGRESS_CMPL_MEM0 (1 << 1)
#define UDMA_GEN_INIT_MEMORY_RX_INIT_IN_PROGRESS_CMPL_MEM0_MASK 0x00000002
#define UDMA_GEN_INIT_MEMORY_RX_INIT_IN_PROGRESS_CMPL_MEM0_SHIFT 1
/* Reset: 0x0         Access: RO */
#define UDMA_GEN_INIT_MEMORY_RX_INIT_IN_PROGRESS_PREF_DESC0 (1 << 2)
#define UDMA_GEN_INIT_MEMORY_RX_INIT_IN_PROGRESS_PREF_DESC0_MASK 0x00000004
#define UDMA_GEN_INIT_MEMORY_RX_INIT_IN_PROGRESS_PREF_DESC0_SHIFT 2
/* Reset: 0x0         Access: RO */
#define UDMA_GEN_INIT_MEMORY_RX_INIT_IN_PROGRESS_PREF_DESC1 (1 << 3)
#define UDMA_GEN_INIT_MEMORY_RX_INIT_IN_PROGRESS_PREF_DESC1_MASK 0x00000008
#define UDMA_GEN_INIT_MEMORY_RX_INIT_IN_PROGRESS_PREF_DESC1_SHIFT 3

/**** tx_init_trigger register ****/
/* Reset: 0x1         Access: RW */
#define UDMA_GEN_INIT_MEMORY_TX_INIT_TRIGGER_CMPL_MEM0 (1 << 0)
#define UDMA_GEN_INIT_MEMORY_TX_INIT_TRIGGER_CMPL_MEM0_MASK 0x00000001
#define UDMA_GEN_INIT_MEMORY_TX_INIT_TRIGGER_CMPL_MEM0_SHIFT 0
/* Reset: 0x1         Access: RW */
#define UDMA_GEN_INIT_MEMORY_TX_INIT_TRIGGER_CMPL_MEM1 (1 << 1)
#define UDMA_GEN_INIT_MEMORY_TX_INIT_TRIGGER_CMPL_MEM1_MASK 0x00000002
#define UDMA_GEN_INIT_MEMORY_TX_INIT_TRIGGER_CMPL_MEM1_SHIFT 1
/* Reset: 0x1         Access: RW */
#define UDMA_GEN_INIT_MEMORY_TX_INIT_TRIGGER_PREF_DESC0 (1 << 2)
#define UDMA_GEN_INIT_MEMORY_TX_INIT_TRIGGER_PREF_DESC0_MASK 0x00000004
#define UDMA_GEN_INIT_MEMORY_TX_INIT_TRIGGER_PREF_DESC0_SHIFT 2
/* Reset: 0x1         Access: RW */
#define UDMA_GEN_INIT_MEMORY_TX_INIT_TRIGGER_PREF_DESC1 (1 << 3)
#define UDMA_GEN_INIT_MEMORY_TX_INIT_TRIGGER_PREF_DESC1_MASK 0x00000008
#define UDMA_GEN_INIT_MEMORY_TX_INIT_TRIGGER_PREF_DESC1_SHIFT 3
/* Reset: 0x1         Access: RW */
#define UDMA_GEN_INIT_MEMORY_TX_INIT_TRIGGER_PREF_HDR0 (1 << 4)
#define UDMA_GEN_INIT_MEMORY_TX_INIT_TRIGGER_PREF_HDR0_MASK 0x00000010
#define UDMA_GEN_INIT_MEMORY_TX_INIT_TRIGGER_PREF_HDR0_SHIFT 4
/* Reset: 0x1         Access: RW */
#define UDMA_GEN_INIT_MEMORY_TX_INIT_TRIGGER_PREF_HDR1 (1 << 5)
#define UDMA_GEN_INIT_MEMORY_TX_INIT_TRIGGER_PREF_HDR1_MASK 0x00000020
#define UDMA_GEN_INIT_MEMORY_TX_INIT_TRIGGER_PREF_HDR1_SHIFT 5

/**** tx_init_in_progress register ****/
/* Reset: 0x0         Access: RO */
#define UDMA_GEN_INIT_MEMORY_TX_INIT_IN_PROGRESS_CMPL_MEM1 (1 << 0)
#define UDMA_GEN_INIT_MEMORY_TX_INIT_IN_PROGRESS_CMPL_MEM1_MASK 0x00000001
#define UDMA_GEN_INIT_MEMORY_TX_INIT_IN_PROGRESS_CMPL_MEM1_SHIFT 0
/* Reset: 0x0         Access: RO */
#define UDMA_GEN_INIT_MEMORY_TX_INIT_IN_PROGRESS_CMPL_MEM0 (1 << 1)
#define UDMA_GEN_INIT_MEMORY_TX_INIT_IN_PROGRESS_CMPL_MEM0_MASK 0x00000002
#define UDMA_GEN_INIT_MEMORY_TX_INIT_IN_PROGRESS_CMPL_MEM0_SHIFT 1
/* Reset: 0x0         Access: RO */
#define UDMA_GEN_INIT_MEMORY_TX_INIT_IN_PROGRESS_PREF_DESC0 (1 << 2)
#define UDMA_GEN_INIT_MEMORY_TX_INIT_IN_PROGRESS_PREF_DESC0_MASK 0x00000004
#define UDMA_GEN_INIT_MEMORY_TX_INIT_IN_PROGRESS_PREF_DESC0_SHIFT 2
/* Reset: 0x0         Access: RO */
#define UDMA_GEN_INIT_MEMORY_TX_INIT_IN_PROGRESS_PREF_DESC1 (1 << 3)
#define UDMA_GEN_INIT_MEMORY_TX_INIT_IN_PROGRESS_PREF_DESC1_MASK 0x00000008
#define UDMA_GEN_INIT_MEMORY_TX_INIT_IN_PROGRESS_PREF_DESC1_SHIFT 3
/* Reset: 0x0         Access: RO */
#define UDMA_GEN_INIT_MEMORY_TX_INIT_IN_PROGRESS_PREF_HDR0 (1 << 4)
#define UDMA_GEN_INIT_MEMORY_TX_INIT_IN_PROGRESS_PREF_HDR0_MASK 0x00000010
#define UDMA_GEN_INIT_MEMORY_TX_INIT_IN_PROGRESS_PREF_HDR0_SHIFT 4
/* Reset: 0x0         Access: RO */
#define UDMA_GEN_INIT_MEMORY_TX_INIT_IN_PROGRESS_PREF_HDR1 (1 << 5)
#define UDMA_GEN_INIT_MEMORY_TX_INIT_IN_PROGRESS_PREF_HDR1_MASK 0x00000020
#define UDMA_GEN_INIT_MEMORY_TX_INIT_IN_PROGRESS_PREF_HDR1_SHIFT 5

/**************************************************************************************************
 * udma_gen_spare_reg
 *
 * spare registers for ECO
 **************************************************************************************************/
struct udma_gen_spare_reg {
	/* [0x0] */
	uint32_t zeroes0;
	/* [0x4] */
	uint32_t zeroes1;
	/* [0x8] */
	uint32_t ones0;
	/* [0xc] */
	uint32_t ones1;
};

/**** zeroes0 register ****/
/* Reset: 0x0         Access: RW */
#define UDMA_GEN_SPARE_REG_ZEROES0_VAL_MASK 0xFFFFFFFF
#define UDMA_GEN_SPARE_REG_ZEROES0_VAL_SHIFT 0

/**** zeroes1 register ****/
/* Reset: 0x0         Access: RW */
#define UDMA_GEN_SPARE_REG_ZEROES1_VAL_MASK 0xFFFFFFFF
#define UDMA_GEN_SPARE_REG_ZEROES1_VAL_SHIFT 0

/**** ones0 register ****/
/* Reset: 0xffffffff  Access: RW */
#define UDMA_GEN_SPARE_REG_ONES0_VAL_MASK 0xFFFFFFFF
#define UDMA_GEN_SPARE_REG_ONES0_VAL_SHIFT 0

/**** ones1 register ****/
/* Reset: 0xffffffff  Access: RW */
#define UDMA_GEN_SPARE_REG_ONES1_VAL_MASK 0xFFFFFFFF
#define UDMA_GEN_SPARE_REG_ONES1_VAL_SHIFT 0

/**************************************************************************************************
 * udma_gen_intc_shadow_access_shadow_index
 **************************************************************************************************/
struct udma_gen_intc_shadow_access_shadow_index {
	/* [0x0] */
	uint32_t rd_permission;
	/* [0x4] */
	uint32_t wr_permission;
};

/**** rd_permission register ****/
/* Reset: 0x0         Access: RW */
#define UDMA_GEN_INTC_SHADOW_ACCESS_SHADOW_INDEX_RD_PERMISSION_DATA_MASK 0xFFFFFFFF
#define UDMA_GEN_INTC_SHADOW_ACCESS_SHADOW_INDEX_RD_PERMISSION_DATA_SHIFT 0

/**** wr_permission register ****/
/* Reset: 0x0         Access: RW */
#define UDMA_GEN_INTC_SHADOW_ACCESS_SHADOW_INDEX_WR_PERMISSION_DATA_MASK 0xFFFFFFFF
#define UDMA_GEN_INTC_SHADOW_ACCESS_SHADOW_INDEX_WR_PERMISSION_DATA_SHIFT 0

/**************************************************************************************************
 * udma_gen_intc_shadow_access
 **************************************************************************************************/
struct udma_gen_intc_shadow_access {
	/* [0x0] */
	struct udma_gen_intc_shadow_access_shadow_index shadow_index[32];
};

/**************************************************************************************************
 * udma_gen_shadow_access_stat
 *
 * Stat for shadow access
 **************************************************************************************************/
struct udma_gen_shadow_access_stat {
	/* [0x0] Total req by VM */
	uint32_t total_req;
	/* [0x4] Total illeg req by VM */
	uint32_t total_illegal_req;
	/* [0x8] */
	uint32_t illegal_req_latch;
	/* [0xc] */
	uint32_t rsrvd_0;
};

/**** total_req register ****/
/* Reset: 0x0         Access: RO, RtoClr */
#define UDMA_GEN_SHADOW_ACCESS_STAT_TOTAL_REQ_CNT_MASK 0xFFFFFFFF
#define UDMA_GEN_SHADOW_ACCESS_STAT_TOTAL_REQ_CNT_SHIFT 0

/**** total_illegal_req register ****/
/* Reset: 0x0         Access: RO, RtoClr */
#define UDMA_GEN_SHADOW_ACCESS_STAT_TOTAL_ILLEGAL_REQ_CNT_MASK 0xFFFFFFFF
#define UDMA_GEN_SHADOW_ACCESS_STAT_TOTAL_ILLEGAL_REQ_CNT_SHIFT 0

/**** illegal_req_latch register ****/
/*
 * addr of transaction
 * Reset: 0x0         Access: RO
 */
#define UDMA_GEN_SHADOW_ACCESS_STAT_ILLEGAL_REQ_LATCH_ADDR_MASK 0x003FFFFF
#define UDMA_GEN_SHADOW_ACCESS_STAT_ILLEGAL_REQ_LATCH_ADDR_SHIFT 0
/*
 * 0 - Read, 1 - Write
 * Reset: 0x0         Access: RO
 */
#define UDMA_GEN_SHADOW_ACCESS_STAT_ILLEGAL_REQ_LATCH_OP (1 << 22)
#define UDMA_GEN_SHADOW_ACCESS_STAT_ILLEGAL_REQ_LATCH_OP_MASK 0x00400000
#define UDMA_GEN_SHADOW_ACCESS_STAT_ILLEGAL_REQ_LATCH_OP_SHIFT 22

/**************************************************************************************************
 * udma_gen_regs
 **************************************************************************************************/
struct udma_gen_regs {
	/* [0x0] */
	uint32_t int_ctrl_base_addr[2048];
	/* [0x2000] */
	uint32_t int_ctrl_sec_addr[64];
	/* [0x2100] AXI configuration */
	struct udma_gen_dma_misc dma_misc;
	/* [0x2200] Mailbox between DMAs */
	struct udma_gen_mailbox mailbox[4];
	/* [0x2300] AXI configuration */
	struct udma_gen_axi axi;
	/* [0x2380] Reflect configuration */
	struct udma_gen_reflect reflect;
	/* [0x24a8] */
	uint32_t rsrvd_0[22];
	/* [0x2500] Target-ID configurations */
	struct udma_gen_tgtid tgtid;
	/* [0x2504] */
	uint32_t rsrvd_1[31];
	/* [0x2580] LImit number of outstanding Read/Write per udma */
	struct udma_gen_axi_master_shaper axi_master_shaper;
	/* [0x2590] */
	uint32_t rsrvd_2[28];
	/* [0x2600] TGTADDR */
	struct udma_gen_tgtaddr tgtaddr[16];
	/* [0x2700] */
	struct udma_gen_axi_outstanding_cnt axi_outstanding_cnt[16];
	/* [0x28c0] */
	uint32_t rsrvd_3[16];
	/*
	 * [0x2900] Each axi generator has an error detecion table, the Addr to the table is
	 * {axi_parity_error,axi_timeout_error,axi_response_error} Instance 0 - M2S - Desc read
	 * Instance 1 -  M2S - Data read
	 * Instance 2 -  M2s -  Cmpl Write
	 * Instance 3 -  S2M -  Desc read
	 * Instance 4 - S2M -   Data Write
	 * Instance 5 - S2M -  Cmpl Write
	 * Instance 6 - MSIX
	 */
	struct udma_gen_axi_error_detection_table axi_error_detection_table[7];
	/* [0x2ac0] */
	uint32_t rsrvd_4[16];
	/*
	 * [0x2b00] Each axi generator has an error control table, the Addr to the table is
	 * {queue_number,error_type (from error detection_table}
	 * Instance 0 - M2S - Desc read
	 * Instance 1 -  M2S - Data read
	 * Instance 2 -  M2s -  Cmpl Write
	 * Instance 3 -  S2M -  Desc read
	 * Instance 4 - S2M -   Data Write
	 * Instance 5 - S2M -  Cmpl Write
	 * Instance 6 - MSIX
	 */
	struct udma_gen_axi_error_control axi_error_control[7];
	/* [0x2b38] */
	uint32_t rsrvd_5[50];
	/* [0x2c00] */
	struct udma_gen_axi_queue axi_queue[16];
	/* [0x2cc0] Push packet desc cfg */
	struct udma_gen_pp pp;
	/* [0x2cd4] */
	uint32_t rsrvd_6[11];
	/* [0x2d00] m2s_desc_read */
	uint32_t int_ctrl0[64];
	/* [0x2e00] m2s_data_read */
	uint32_t int_ctrl1[64];
	/* [0x2f00] m2s_cmpl_write */
	uint32_t int_ctrl2[64];
	/* [0x3000] s2m_desc_read */
	uint32_t int_ctrl3[64];
	/* [0x3100] s2m_data_write */
	uint32_t int_ctrl4[64];
	/* [0x3200] s2m_cmpl_write */
	uint32_t int_ctrl5[64];
	/* [0x3300] msix_write */
	uint32_t int_ctrl6[64];
	/* [0x3400] Here you can configure in which q PMU counter will count */
	struct udma_gen_pmu pmu;
	/* [0x3410] */
	uint32_t rsrvd_7[4];
	/* [0x3420] */
	struct udma_gen_init_memory init_memory;
	/* [0x3440] */
	uint32_t rsrvd_8[8];
	/* [0x3460] spare registers for ECO */
	struct udma_gen_spare_reg spare_reg;
	/* [0x3470] */
	uint32_t rsrvd_9[36];
	/* [0x3500] */
	struct udma_gen_intc_shadow_access intc_shadow_access;
	/* [0x3600] Stat for shadow access */
	struct udma_gen_shadow_access_stat shadow_access_stat;
	/* [0x3610] */
	uint32_t rsrvd_10[29308];
};

/* Asserts */
al_static_assert(sizeof(struct al_cell_fe_regs) == 4,
	"Expected other registers struct size!");

#ifdef __cplusplus
}
#endif

#endif

/** @} */
