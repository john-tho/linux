/*
 * Copyright 2019, Amazon.com, Inc. or its affiliates. All Rights Reserved
 */

/**
 *  @{
 * @file   al_hal_iofic_grp_ctrl_regs.h
 *
 * @brief iofic_grp_ctrl registers
 *
 * This file was auto-generated by RegGen v1.3.12
 *
 * Hash Key is: 55e7a7726d4c77a13532d492ebe23278
 *
 * JSON: ap_intc_grp_ctrl.json
 *
 */

#ifndef __AL_HAL_IOFIC_GRP_CTRL_REGS_H__
#define __AL_HAL_IOFIC_GRP_CTRL_REGS_H__

#include "al_hal_common.h"

#ifdef __cplusplus
extern "C" {
#endif

/**************************************************************************************************
 * al_iofic_grp_ctrl_regs
 *
 * interrupt group
 **************************************************************************************************/
struct al_iofic_grp_ctrl_regs {
	/*
	 * [0x0] Interrupt Cause Register Set by hardware
	 * - If MSI-X is enabled and auto_clear control bit =TRUE, automatically cleared after MSI-X
	 * message associated with this specific interrupt bit is sent (MSI-X acknowledge is
	 * received).
	 * - Software can set a bit in this register by writing 1 to the associated bit in the
	 * Interrupt Cause Set register Write-0 clears a bit. Write-1 has no effect.
	 * - On CPU Read - If clear_on_read control bit =TRUE, automatically cleared (all bits are
	 * cleared).
	 * When there is a conflict and on the same clock cycle, hardware tries to set a bit in the
	 * Interrupt Cause register, the specific bit is set to ensure the interrupt indication is
	 * not lost.
	 */
	uint32_t int_cause_grp;
	/* [0x4] */
	uint32_t rsrvd_0;
	/*
	 * [0x8] Interrupt Cause Set Register
	 * Writing 1 to a bit in this register sets its corresponding cause bit, enabling software
	 * to generate a hardware interrupt.
	 * Write 0 has no effect.
	 */
	uint32_t int_cause_set_grp;
	/* [0xc] */
	uint32_t rsrvd_1;
	/*
	 * [0x10] Interrupt Mask Register
	 * If Auto-mask control bit =TRUE, automatically set to 1 after MSI-X message associated
	 * with the associated interrupt bit is sent (AXI write acknowledge is received).
	 */
	uint32_t int_mask_grp;
	/* [0x14] */
	uint32_t rsrvd_2;
	/*
	 * [0x18] Interrupt Mask Clear Register
	 * Used when auto-mask control bit=True. Enables CPU to clear a specific bit. It prevents a
	 * scenario in which the CPU overrides another bit with 1 (old value) that hardware has just
	 * cleared to 0.
	 * Write 0 to this register clears its corresponding mask bit. Write 1 has no effect.
	 */
	uint32_t int_mask_clear_grp;
	/* [0x1c] */
	uint32_t rsrvd_3;
	/*
	 * [0x20] Interrupt Status Register
	 * This register latches the status of the interrupt source.
	 */
	uint32_t int_status_grp;
	/* [0x24] */
	uint32_t rsrvd_4;
	/* [0x28] Interrupt Control Register */
	uint32_t int_control_grp;
	/*
	 * [0x2c] Interrupt Mask Register
	 * Each bit in this register masks the corresponding cause bit for generating an Error
	 * signal. Its default value is determined by unit instantiation.
	 * (Error = Wire-OR of Cause & !Interrupt_Error_Mask)
	 * This register provides error handling configuration for error interrupts
	 */
	uint32_t int_error_msk_grp;
	/*
	 * [0x30] Interrupt Mask Register
	 * Each bit in this register masks the corresponding cause bit for generating an Abort
	 * signal. Its default value is determined by unit instantiation.
	 * (Abort = Wire-OR of Cause & !Interrupt_Abort_Mask)
	 * This register provides error handling configuration for error interrupts
	 */
	uint32_t int_abort_msk_grp;
	/*
	 * [0x34] Interrupt Mask Register
	 * Each bit in this register masks the corresponding cause bit for generating a Fatal
	 * signal. Its default value is determined by unit instantiation.
	 * (Fatal = Wire-OR of Cause & !Interrupt_Fatal_Mask)
	 * This register provides error handling configuration for error interrupts
	 */
	uint32_t int_fatal_msk_grp;
	/*
	 * [0x38] Interrupt Log Register
	 * Each bit in this register masks the corresponding cause bit for capturing the log
	 * registers. Its default value is determined by unit instantiation.
	 * (Log_capture = Wire-OR of Cause & !Interrupt_Log_Mask)
	 * This register provides error handling configuration for error interrupts.
	 */
	uint32_t int_log_msk_grp;
	/* [0x3c] */
	uint32_t rsrvd_5;
};

/**** int_cause_grp register ****/
/* Reset: 0x0         Access: RW */
#define IOFIC_GRP_CTRL_INT_CAUSE_GRP_VAL_MASK 0xFFFFFFFF
#define IOFIC_GRP_CTRL_INT_CAUSE_GRP_VAL_SHIFT 0

/**** int_cause_set_grp register ****/
/*
 * Interrupt Cause Set
 * If Auto-mask control bit =TRUE, automatically set to 1 after MSI-X message associated with the
 * associated interrupt bit is sent (AXI write acknowledge is received).
 * Reset: 0x0         Access: WO
 */
#define IOFIC_GRP_CTRL_INT_CAUSE_SET_GRP_INT_CS_SET_MASK 0xFFFFFFFF
#define IOFIC_GRP_CTRL_INT_CAUSE_SET_GRP_INT_CS_SET_SHIFT 0

/**** int_mask_grp register ****/
/*
 * Interrupt Mask
 * Reset: 0x0         Access: RW
 */
#define IOFIC_GRP_CTRL_INT_MASK_GRP_INT_MSK_MASK 0xFFFFFFFF
#define IOFIC_GRP_CTRL_INT_MASK_GRP_INT_MSK_SHIFT 0

/**** int_mask_clear_grp register ****/
/*
 * Interrupt Mask Clear
 * Reset: 0x0         Access: WO
 */
#define IOFIC_GRP_CTRL_INT_MASK_CLEAR_GRP_INT_MSK_CLR_MASK 0xFFFFFFFF
#define IOFIC_GRP_CTRL_INT_MASK_CLEAR_GRP_INT_MSK_CLR_SHIFT 0

/**** int_status_grp register ****/
/*
 * Interrupt Status
 * Reset: 0x0         Access: RO
 */
#define IOFIC_GRP_CTRL_INT_STATUS_GRP_INT_STS_MASK 0xFFFFFFFF
#define IOFIC_GRP_CTRL_INT_STATUS_GRP_INT_STS_SHIFT 0

/**** int_control_grp register ****/
/*
 * When Clear_on_Read =1, all bits of  Cause register are cleared on read.
 * Reset: 0x0         Access: RW
 */
#define IOFIC_GRP_CTRL_INT_CONTROL_GRP_CLEAR_ON_READ (1 << 0)
#define IOFIC_GRP_CTRL_INT_CONTROL_GRP_CLEAR_ON_READ_MASK 0x00000001
#define IOFIC_GRP_CTRL_INT_CONTROL_GRP_CLEAR_ON_READ_SHIFT 0
/*
 * (Must be set only when MSIX is enabled.)
 * When Auto-Mask =1 and an MSI-X ACK for this bit is received, its corresponding bit in the Mask
 * register is set, masking future interrupts.
 * Reset: 0x0         Access: RW
 */
#define IOFIC_GRP_CTRL_INT_CONTROL_GRP_AUTO_MASK (1 << 1)
#define IOFIC_GRP_CTRL_INT_CONTROL_GRP_AUTO_MASK_MASK 0x00000002
#define IOFIC_GRP_CTRL_INT_CONTROL_GRP_AUTO_MASK_SHIFT 1
/*
 * Auto_Clear (RW)
 * When Auto-Clear =1, the bits in the Interrupt Cause register are auto-cleared after MSI-X is
 * acknowledged. Must be used only if MSI-X is enabled.
 * Reset: 0x0         Access: RW
 */
#define IOFIC_GRP_CTRL_INT_CONTROL_GRP_AUTO_CLEAR (1 << 2)
#define IOFIC_GRP_CTRL_INT_CONTROL_GRP_AUTO_CLEAR_MASK 0x00000004
#define IOFIC_GRP_CTRL_INT_CONTROL_GRP_AUTO_CLEAR_SHIFT 2
/*
 * When Set_on_Posedge =1, the bits in the Interrupt Cause register are set on the posedge of the
 * interrupt source, i.e., when interrupt source =1 and Interrupt Status = 0.
 * When Set_on_Posedge =0, the bits in the Interrupt Cause register are set when interrupt source
 * =1.
 * Reset: 0x0         Access: RW
 */
#define IOFIC_GRP_CTRL_INT_CONTROL_GRP_SET_ON_POSEDGE (1 << 3)
#define IOFIC_GRP_CTRL_INT_CONTROL_GRP_SET_ON_POSEDGE_MASK 0x00000008
#define IOFIC_GRP_CTRL_INT_CONTROL_GRP_SET_ON_POSEDGE_SHIFT 3
/*
 * When Moderation_Reset =1, all Moderation timers associated with the interrupt cause bits are
 * cleared to 0, enabling immediate interrupt assertion if any unmasked cause bit is set to 1. This
 * bit is self-negated.
 * Reset: 0x0         Access: WO
 */
#define IOFIC_GRP_CTRL_INT_CONTROL_GRP_MOD_RST (1 << 4)
#define IOFIC_GRP_CTRL_INT_CONTROL_GRP_MOD_RST_MASK 0x00000010
#define IOFIC_GRP_CTRL_INT_CONTROL_GRP_MOD_RST_SHIFT 4
/*
 * When mask_msi_x =1, no MSI-X from this group is sent. This bit must be set to 1 when the
 * associated summary bit in this group is used to generate a single MSI-X for this group.
 * Reset: 0x0         Access: RW
 */
#define IOFIC_GRP_CTRL_INT_CONTROL_GRP_MASK_MSI_X (1 << 5)
#define IOFIC_GRP_CTRL_INT_CONTROL_GRP_MASK_MSI_X_MASK 0x00000020
#define IOFIC_GRP_CTRL_INT_CONTROL_GRP_MASK_MSI_X_SHIFT 5
/*
 * MSI-X AWID value. Same ID for all cause bits.
 * Reset: 0x0         Access: RW
 */
#define IOFIC_GRP_CTRL_INT_CONTROL_GRP_AWID_MASK 0x00000F00
#define IOFIC_GRP_CTRL_INT_CONTROL_GRP_AWID_SHIFT 8
/*
 * This value determines the interval between interrupts; writing ZERO disables Moderation.
 * Reset: 0x0         Access: RW
 */
#define IOFIC_GRP_CTRL_INT_CONTROL_GRP_MOD_INTV_MASK 0x00FF0000
#define IOFIC_GRP_CTRL_INT_CONTROL_GRP_MOD_INTV_SHIFT 16
/*
 * This value determines the Moderation_Timer_Clock speed.
 * 0- Moderation-timer is decremented every 1x256 SB clock cycles ~1uS.
 * 1- Moderation-timer is decremented every 2x256 SB clock cycles ~2uS.
 * N- Moderation-timer is decremented every Nx256 SB clock cycles ~(N+1) uS.
 * Reset: 0x0         Access: RW
 */
#define IOFIC_GRP_CTRL_INT_CONTROL_GRP_MOD_RES_MASK 0x0F000000
#define IOFIC_GRP_CTRL_INT_CONTROL_GRP_MOD_RES_SHIFT 24
/*
 * INTC revision
 * Reset: 0x0         Access: RO
 */
#define IOFIC_GRP_CTRL_INT_CONTROL_GRP_REV_ID_MASK 0x30000000
#define IOFIC_GRP_CTRL_INT_CONTROL_GRP_REV_ID_SHIFT 28

/**** int_error_msk_grp register ****/
/*
 * Interrupt Error Mask
 * Reset: 0xffffffff  Access: RW
 */
#define IOFIC_GRP_CTRL_INT_ERROR_MSK_GRP_INT_ERROR_MSK_MASK 0xFFFFFFFF
#define IOFIC_GRP_CTRL_INT_ERROR_MSK_GRP_INT_ERROR_MSK_SHIFT 0

/**** int_abort_msk_grp register ****/
/*
 * Interrupt Abort Mask
 * Reset: 0xffffffff  Access: RW
 */
#define IOFIC_GRP_CTRL_INT_ABORT_MSK_GRP_INT_ABORT_MSK_MASK 0xFFFFFFFF
#define IOFIC_GRP_CTRL_INT_ABORT_MSK_GRP_INT_ABORT_MSK_SHIFT 0

/**** int_fatal_msk_grp register ****/
/*
 * Interrupt Fatal Mask
 * Reset: 0xffffffff  Access: RW
 */
#define IOFIC_GRP_CTRL_INT_FATAL_MSK_GRP_INT_FATAL_MSK_MASK 0xFFFFFFFF
#define IOFIC_GRP_CTRL_INT_FATAL_MSK_GRP_INT_FATAL_MSK_SHIFT 0

/**** int_log_msk_grp register ****/
/*
 * Interrupt Log Mask
 * Reset: 0xffffffff  Access: RW
 */
#define IOFIC_GRP_CTRL_INT_LOG_MSK_GRP_INT_LOG_MSK_MASK 0xFFFFFFFF
#define IOFIC_GRP_CTRL_INT_LOG_MSK_GRP_INT_LOG_MSK_SHIFT 0

#ifdef __cplusplus
}
#endif

#endif

/** @} */
