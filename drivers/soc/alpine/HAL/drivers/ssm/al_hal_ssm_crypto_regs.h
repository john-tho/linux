/*
 * Copyright 2018, Amazon.com, Inc. or its affiliates. All Rights Reserved
 */

/**
 *  @{
 * @file   al_hal_ssm_crypto_regs.h
 *
 * @brief crypto_accelerator registers
 *
 * This file was auto-generated by RegGen v1.3.1
 *
 */

#ifndef __AL_HAL_CRYPTO_REGS_H__
#define __AL_HAL_CRYPTO_REGS_H__

#include "al_hal_plat_types.h"

#ifdef __cplusplus
extern "C" {
#endif

/**************************************************************************************************
 * al_crypto_accelerator_configuration
 *
 * Crypto Configuration
 **************************************************************************************************/
struct al_crypto_accelerator_configuration {
	/* [0x0] Unit Configuration register */
	uint32_t unit_conf;
	/*
	 * [0x4] Unit Debug Configuration register
	 * Number of cycles to wait before declaring timeout
	 * Reset: 0xffffffff  Access: RW
	 */
	uint32_t m2s_timeout;
	/*
	 * [0x8] Unit Debug Configuration register
	 * Number of cycles to wait before declaring a timeout
	 * Reset: 0xffffffff  Access: RW
	 */
	uint32_t s2m_timeout;
	/* [0xc] enable memories for APB access (production testing / accelerated boot) */
	uint32_t mem_test;
};

/**** unit_conf register ****/
/*
 * When this bit is set to 1, the Crypto engine accepts new commands, if possible before previous
 * command completion.
 * Reset: 0x1         Access: RW
 */
#define CRYPTO_CONFIGURATION_UNIT_CONF_MUL_CMD_EN (1 << 0)
#define CRYPTO_CONFIGURATION_UNIT_CONF_MUL_CMD_EN_MASK 0x00000001
#define CRYPTO_CONFIGURATION_UNIT_CONF_MUL_CMD_EN_SHIFT 0
/*
 * When this bit is set to 1, when an error occurs, the pipe will hold.
 * Reset: 0x0         Access: RW
 */
#define CRYPTO_CONFIGURATION_UNIT_CONF_HOLD_PIPE_WHEN_ERROR (1 << 1)
#define CRYPTO_CONFIGURATION_UNIT_CONF_HOLD_PIPE_WHEN_ERROR_MASK 0x00000002
#define CRYPTO_CONFIGURATION_UNIT_CONF_HOLD_PIPE_WHEN_ERROR_SHIFT 1
/*
 * Enable smart clk-gating of unused Crypto engines.
 * Bits 14:11 enabling/disabling of smart clk gating in COMP/AES/SHA/DES respectively, e.g., for
 * smart clk gating in AES & DES, but no clk gating in SHA, set this field to 'b0101.
 * Reset: 0xf         Access: RW
 */
#define CRYPTO_CONFIGURATION_UNIT_CONF_CLK_GATE_UNUSED_ENGINES_MASK 0x0000003C
#define CRYPTO_CONFIGURATION_UNIT_CONF_CLK_GATE_UNUSED_ENGINES_SHIFT 2
/*
 * [9:6] Disable clk to COMP/AES/SHA/DES core (respectively).
 * Reset: 0x0         Access: RW
 */
#define CRYPTO_CONFIGURATION_UNIT_CONF_CLK_SHUTDOWN_MASK 0x000003C0
#define CRYPTO_CONFIGURATION_UNIT_CONF_CLK_SHUTDOWN_SHIFT 6
/*
 * 0x0 - RR from VF #0 to VF #(N-1).
 * 0x1 - RR from VF #(N-1) to VF #0.
 * 0x2 - Strict Priority according to vf_arb_prio
 * Reset: 0x0         Access: RW
 */
#define CRYPTO_CONFIGURATION_UNIT_CONF_VF_ARB_MODE_MASK 0x00000C00
#define CRYPTO_CONFIGURATION_UNIT_CONF_VF_ARB_MODE_SHIFT 10
/*
 * Index of prioritized VF (RR will start from this VF).
 * Reset: 0x0         Access: RW
 */
#define CRYPTO_CONFIGURATION_UNIT_CONF_VF_ARB_PRIO_MASK 0x00007000
#define CRYPTO_CONFIGURATION_UNIT_CONF_VF_ARB_PRIO_SHIFT 12
/*
 * Enable key parity check for DES
 * Reset: 0x0         Access: RW
 */
#define CRYPTO_CONFIGURATION_UNIT_CONF_DES_KEY_PARITY_CHECK_EN (1 << 15)
#define CRYPTO_CONFIGURATION_UNIT_CONF_DES_KEY_PARITY_CHECK_EN_MASK 0x00008000
#define CRYPTO_CONFIGURATION_UNIT_CONF_DES_KEY_PARITY_CHECK_EN_SHIFT 15
/*
 * Enable DES EEE mode
 * Reset: 0x0         Access: RW
 */
#define CRYPTO_CONFIGURATION_UNIT_CONF_CHICKEN_DES_EEE_EN (1 << 16)
#define CRYPTO_CONFIGURATION_UNIT_CONF_CHICKEN_DES_EEE_EN_MASK 0x00010000
#define CRYPTO_CONFIGURATION_UNIT_CONF_CHICKEN_DES_EEE_EN_SHIFT 16
/*
 * Enable Auth to start together with Enc
 * Reset: 0x1         Access: RW
 */
#define CRYPTO_CONFIGURATION_UNIT_CONF_CHICKEN_AUTH_START_WITH_ENC_EN (1 << 17)
#define CRYPTO_CONFIGURATION_UNIT_CONF_CHICKEN_AUTH_START_WITH_ENC_EN_MASK 0x00020000
#define CRYPTO_CONFIGURATION_UNIT_CONF_CHICKEN_AUTH_START_WITH_ENC_EN_SHIFT 17
/*
 * Enable SHA-3 engine
 * Reset: 0x1         Access: RW
 */
#define CRYPTO_CONFIGURATION_UNIT_CONF_CHICKEN_SHA3_EN (1 << 18)
#define CRYPTO_CONFIGURATION_UNIT_CONF_CHICKEN_SHA3_EN_MASK 0x00040000
#define CRYPTO_CONFIGURATION_UNIT_CONF_CHICKEN_SHA3_EN_SHIFT 18
/*
 * Enable long SAs (useful for modes requiring HMAC/broken-pkt while using SHA-3 algorithm)
 * Reset: 0x1         Access: RW
 */
#define CRYPTO_CONFIGURATION_UNIT_CONF_CHICKEN_LONG_SA_EN (1 << 19)
#define CRYPTO_CONFIGURATION_UNIT_CONF_CHICKEN_LONG_SA_EN_MASK 0x00080000
#define CRYPTO_CONFIGURATION_UNIT_CONF_CHICKEN_LONG_SA_EN_SHIFT 19
/*
 * Disable HW padding of incoming pkts
 * Reset: 0x0         Access: RW
 */
#define CRYPTO_CONFIGURATION_UNIT_CONF_CHICKEN_SHA_PADDING_DISABLE (1 << 20)
#define CRYPTO_CONFIGURATION_UNIT_CONF_CHICKEN_SHA_PADDING_DISABLE_MASK 0x00100000
#define CRYPTO_CONFIGURATION_UNIT_CONF_CHICKEN_SHA_PADDING_DISABLE_SHIFT 20
/*
 * give each GDMA ability to access all SAD lines
 * Reset: 0x0         Access: RW
 */
#define CRYPTO_CONFIGURATION_UNIT_CONF_GDMA_FULL_SAD_ACCESS_EN (1 << 21)
#define CRYPTO_CONFIGURATION_UNIT_CONF_GDMA_FULL_SAD_ACCESS_EN_MASK 0x00200000
#define CRYPTO_CONFIGURATION_UNIT_CONF_GDMA_FULL_SAD_ACCESS_EN_SHIFT 21

/**** mem_test register ****/
/*
 * 0xA enables test mode
 * Reset: 0x0         Access: RW
 */
#define CRYPTO_CONFIGURATION_MEM_TEST_VAL_MASK 0x0000000F
#define CRYPTO_CONFIGURATION_MEM_TEST_VAL_SHIFT 0

/**************************************************************************************************
 * al_crypto_accelerator_debug
 *
 * Crypto configuration
 **************************************************************************************************/
struct al_crypto_accelerator_debug {
	/* [0x0] Unit Debug Configuration register */
	uint32_t unit_debug_conf;
	/* [0x4] */
	uint32_t rsrvd_0[3];
};

/**** unit_debug_conf register ****/
/*
 * When these bits are set to 0, reset the ack FIFOs.
 * Reset: 0xf         Access: RW
 */
#define CRYPTO_DEBUG_UNIT_DEBUG_CONF_FIFO_ENABLE_ACK_MASK 0x0000000F
#define CRYPTO_DEBUG_UNIT_DEBUG_CONF_FIFO_ENABLE_ACK_SHIFT 0
/*
 * When this bit is set to 0, reset the payload FIFO between the engines and the dispatcher.
 * Reset: 0x1         Access: RW
 */
#define CRYPTO_DEBUG_UNIT_DEBUG_CONF_FIFO_ENABLE_E2M_PYLD (1 << 4)
#define CRYPTO_DEBUG_UNIT_DEBUG_CONF_FIFO_ENABLE_E2M_PYLD_MASK 0x00000010
#define CRYPTO_DEBUG_UNIT_DEBUG_CONF_FIFO_ENABLE_E2M_PYLD_SHIFT 4
/*
 * When this bit is set to 0, reset the sign FIFO between the engines and the dispatcher.
 * Reset: 0x1         Access: RW
 */
#define CRYPTO_DEBUG_UNIT_DEBUG_CONF_FIFO_ENABLE_E2M_SIGN (1 << 5)
#define CRYPTO_DEBUG_UNIT_DEBUG_CONF_FIFO_ENABLE_E2M_SIGN_MASK 0x00000020
#define CRYPTO_DEBUG_UNIT_DEBUG_CONF_FIFO_ENABLE_E2M_SIGN_SHIFT 5
/*
 * When this bit is set to 0, reset the intr FIFO between the engines and the dispatcher.
 * Reset: 0x1         Access: RW
 */
#define CRYPTO_DEBUG_UNIT_DEBUG_CONF_FIFO_ENABLE_E2M_INTR (1 << 6)
#define CRYPTO_DEBUG_UNIT_DEBUG_CONF_FIFO_ENABLE_E2M_INTR_MASK 0x00000040
#define CRYPTO_DEBUG_UNIT_DEBUG_CONF_FIFO_ENABLE_E2M_INTR_SHIFT 6
/*
 * When this bit is set to 0, reset the data FIFO between the decoder and the engines.
 * Reset: 0x1         Access: RW
 */
#define CRYPTO_DEBUG_UNIT_DEBUG_CONF_FIFO_ENABLE_D2E_DATA (1 << 7)
#define CRYPTO_DEBUG_UNIT_DEBUG_CONF_FIFO_ENABLE_D2E_DATA_MASK 0x00000080
#define CRYPTO_DEBUG_UNIT_DEBUG_CONF_FIFO_ENABLE_D2E_DATA_SHIFT 7
/*
 * When this bit is set to 0, reset the control FIFO between the decoder and the engines.
 * Reset: 0x1         Access: RW
 */
#define CRYPTO_DEBUG_UNIT_DEBUG_CONF_FIFO_ENABLE_D2E_CTRL (1 << 8)
#define CRYPTO_DEBUG_UNIT_DEBUG_CONF_FIFO_ENABLE_D2E_CTRL_MASK 0x00000100
#define CRYPTO_DEBUG_UNIT_DEBUG_CONF_FIFO_ENABLE_D2E_CTRL_SHIFT 8
/*
 * When this bit is set to 0, reset the context FIFO between the decoder and the engines.
 * Reset: 0x1         Access: RW
 */
#define CRYPTO_DEBUG_UNIT_DEBUG_CONF_FIFO_ENABLE_D2E_CONTEXT (1 << 9)
#define CRYPTO_DEBUG_UNIT_DEBUG_CONF_FIFO_ENABLE_D2E_CONTEXT_MASK 0x00000200
#define CRYPTO_DEBUG_UNIT_DEBUG_CONF_FIFO_ENABLE_D2E_CONTEXT_SHIFT 9
/*
 * When this bit is set to 0, reset the SA bypass FIFO between the decoder and the dispatcher.
 * Reset: 0x1         Access: RW
 */
#define CRYPTO_DEBUG_UNIT_DEBUG_CONF_FIFO_ENABLE_D2M_SA_BYPASS (1 << 10)
#define CRYPTO_DEBUG_UNIT_DEBUG_CONF_FIFO_ENABLE_D2M_SA_BYPASS_MASK 0x00000400
#define CRYPTO_DEBUG_UNIT_DEBUG_CONF_FIFO_ENABLE_D2M_SA_BYPASS_SHIFT 10
/*
 * When this bit is set to 0, reset the IV bypass FIFO between the decoder and the dispatcher.
 * Reset: 0x1         Access: RW
 */
#define CRYPTO_DEBUG_UNIT_DEBUG_CONF_FIFO_ENABLE_D2M_IV_BYPASS (1 << 11)
#define CRYPTO_DEBUG_UNIT_DEBUG_CONF_FIFO_ENABLE_D2M_IV_BYPASS_MASK 0x00000800
#define CRYPTO_DEBUG_UNIT_DEBUG_CONF_FIFO_ENABLE_D2M_IV_BYPASS_SHIFT 11
/*
 * When this bit is set to 0, reset the ICV bypass FIFO between the decoder and the dispatcher.
 * Reset: 0x1         Access: RW
 */
#define CRYPTO_DEBUG_UNIT_DEBUG_CONF_FIFO_ENABLE_D2M_ICV_BYPASS (1 << 12)
#define CRYPTO_DEBUG_UNIT_DEBUG_CONF_FIFO_ENABLE_D2M_ICV_BYPASS_MASK 0x00001000
#define CRYPTO_DEBUG_UNIT_DEBUG_CONF_FIFO_ENABLE_D2M_ICV_BYPASS_SHIFT 12
/*
 * When this bit is set to 0, reset the aligner FIFO.
 * Reset: 0x1         Access: RW
 */
#define CRYPTO_DEBUG_UNIT_DEBUG_CONF_FIFO_ENABLE_ALIGNER_AXIS (1 << 13)
#define CRYPTO_DEBUG_UNIT_DEBUG_CONF_FIFO_ENABLE_ALIGNER_AXIS_MASK 0x00002000
#define CRYPTO_DEBUG_UNIT_DEBUG_CONF_FIFO_ENABLE_ALIGNER_AXIS_SHIFT 13
/*
 * When this bit is set to 0, reset the ingress FIFO.
 * Reset: 0x1         Access: RW
 */
#define CRYPTO_DEBUG_UNIT_DEBUG_CONF_FIFO_ENABLE_INGRESS (1 << 14)
#define CRYPTO_DEBUG_UNIT_DEBUG_CONF_FIFO_ENABLE_INGRESS_MASK 0x00004000
#define CRYPTO_DEBUG_UNIT_DEBUG_CONF_FIFO_ENABLE_INGRESS_SHIFT 14
/*
 * Clear the data_aligner (decode stage).
 * Reset: 0x0         Access: RW
 */
#define CRYPTO_DEBUG_UNIT_DEBUG_CONF_CLR_ALIGNER (1 << 15)
#define CRYPTO_DEBUG_UNIT_DEBUG_CONF_CLR_ALIGNER_MASK 0x00008000
#define CRYPTO_DEBUG_UNIT_DEBUG_CONF_CLR_ALIGNER_SHIFT 15
/*
 * Clear the data_splitter (dispatch stage).
 * Reset: 0x0         Access: RW
 */
#define CRYPTO_DEBUG_UNIT_DEBUG_CONF_CLR_SPLITTER (1 << 16)
#define CRYPTO_DEBUG_UNIT_DEBUG_CONF_CLR_SPLITTER_MASK 0x00010000
#define CRYPTO_DEBUG_UNIT_DEBUG_CONF_CLR_SPLITTER_SHIFT 16
/*
 * Don't perform memory init.
 * Reset: 0x0         Access: RW
 */
#define CRYPTO_DEBUG_UNIT_DEBUG_CONF_MEM_INIT_SKIP (1 << 17)
#define CRYPTO_DEBUG_UNIT_DEBUG_CONF_MEM_INIT_SKIP_MASK 0x00020000
#define CRYPTO_DEBUG_UNIT_DEBUG_CONF_MEM_INIT_SKIP_SHIFT 17

/**************************************************************************************************
 * al_crypto_accelerator_log
 *
 * ERROR LOG
 **************************************************************************************************/
struct al_crypto_accelerator_log {
	/*
	 * [0x0] Descriptor word 0
	 * When a fatal error occurs, this register reflects the descriptor of the command that
	 * caused the fatal error.
	 * Descriptor Word 0
	 * When a fatal error occurs, this register reflects the descriptor of the command that
	 * caused the fatal error
	 * Reset: 0x0         Access: RO
	 */
	uint32_t desc_word0;
	/*
	 * [0x4] Descriptor word 1
	 * When a fatal error occurs, this register reflects the descriptor of the command that
	 * caused the fatal error.
	 * Descriptor Word 1
	 * When a fatal error occurs, this register reflects the descriptor of the command that
	 * caused the fatal error.
	 * Reset: 0x0         Access: RO
	 */
	uint32_t desc_word1;
	/*
	 * [0x8] Transaction information of the command that triggered the error. When a fatal error
	 * occurs, this register reflects the transaction info of the command that caused the fatal
	 * error.
	 */
	uint32_t trans_info_1;
	/*
	 * [0xc] Transaction information of the command that triggered the error. When a fatal error
	 * occurs, this register reflects the transaction info of the command that caused the fatal
	 * error.
	 */
	uint32_t trans_info_2;
	/* [0x10] */
	uint32_t rsrvd_0[4];
};

/**** trans_info_1 register ****/
/*
 * Transaction length in bytes
 * Reset: 0x0         Access: RO
 */
#define CRYPTO_LOG_TRANS_INFO_1_TRANS_LEN_MASK 0x000FFFFF
#define CRYPTO_LOG_TRANS_INFO_1_TRANS_LEN_SHIFT 0
/*
 * Number of descriptors in the transaction
 * Reset: 0x0         Access: RO
 */
#define CRYPTO_LOG_TRANS_INFO_1_NUM_OF_DESC_MASK 0x00F00000
#define CRYPTO_LOG_TRANS_INFO_1_NUM_OF_DESC_SHIFT 20
/*
 * Reserved
 * Reset: 0x0         Access: RO
 */
#define CRYPTO_LOG_TRANS_INFO_1_RESERVED_MASK 0xFF000000
#define CRYPTO_LOG_TRANS_INFO_1_RESERVED_SHIFT 24

/**** trans_info_2 register ****/
/*
 * Queue Number of the transaction
 * Reset: 0x0         Access: RO
 */
#define CRYPTO_LOG_TRANS_INFO_2_Q_NUM_MASK 0x00000FFF
#define CRYPTO_LOG_TRANS_INFO_2_Q_NUM_SHIFT 0
/*
 * GDMA ID of the transaction
 * Reset: 0x0         Access: RO
 */
#define CRYPTO_LOG_TRANS_INFO_2_DMA_ID_MASK 0x0000F000
#define CRYPTO_LOG_TRANS_INFO_2_DMA_ID_SHIFT 12
/*
 * Internal Serial Number of the transaction
 * Reset: 0x0         Access: RO
 */
#define CRYPTO_LOG_TRANS_INFO_2_SERIAL_NUM_MASK 0x03FF0000
#define CRYPTO_LOG_TRANS_INFO_2_SERIAL_NUM_SHIFT 16
/*
 * Reserved
 * Reset: 0x0         Access: RO
 */
#define CRYPTO_LOG_TRANS_INFO_2_RESERVED_MASK 0xFC000000
#define CRYPTO_LOG_TRANS_INFO_2_RESERVED_SHIFT 26

/**************************************************************************************************
 * al_crypto_accelerator_crypto_perf_counter
 *
 * Performance Counters
 **************************************************************************************************/
struct al_crypto_accelerator_crypto_perf_counter {
	/*
	 * [0x0] The execution cycle counter measures the number of cycles that the CRYPTO
	 * accelerator is active (i.e., there is at least one valid command from the M2S or the pipe
	 * is not empty).
	 * CRYPTO_exec_cnt
	 * Reset: 0x0         Access: RW
	 */
	uint32_t exec_cnt;
	/*
	 * [0x4] M2S active cycles counter
	 * Measures the number of cycles M2S sends command(s) to CRYPTO engine.
	 * M2S_active_cnt
	 * Reset: 0x0         Access: RW
	 */
	uint32_t m2s_active_cnt;
	/*
	 * [0x8] M2S idle cycles counter
	 * Measures the number of idle cycles on M2S while the CRYPTO accelerator is waiting for
	 * data (the M2S_active_cnt is counting).
	 * M2S_Idle_cnt
	 * Reset: 0x0         Access: RW
	 */
	uint32_t m2s_idle_cnt;
	/*
	 * [0xc] M2S backpressure cycles counter
	 * Measures the number of cycles the Crypto engine cannot accept data from the M2S while the
	 * M2S is ready to transfer data.
	 * M2S_bp_cnt
	 * Reset: 0x0         Access: RW
	 */
	uint32_t m2s_backp_cnt;
	/*
	 * [0x10] S2M active cycles counter
	 * Measures the number of cycles the Crypto engine sends command(s) to S2M.  In cycles where
	 * more than one GDMA S2M is active, the counter is incremented by the number of the S2M
	 * interfaces that are active.
	 * S2M_active_cnt
	 * Reset: 0x0         Access: RW
	 */
	uint32_t s2m_active_cnt;
	/*
	 * [0x14] S2M idle cycles counter
	 * Measures the number of idle cycles on S2M while S2M is waiting for data (the
	 * S2M_active_cnt is counting).  In cycles where more than one GDMA is waiting for data from
	 * the CRYPTO, the counter is incremented by the number of S2M interfaces that are idle.
	 * S2M_Idle_cnt
	 * Reset: 0x0         Access: RW
	 */
	uint32_t s2m_idle_cnt;
	/*
	 * [0x18] S2M backpressure cycles counter: Measures the number of cycles where the Crypto
	 * had data to send to the S2M, but it was not sent due to backpressure. In cycles where
	 * more than one S2M performs backpressure to the CRYPTO, the counter is incremented by the
	 * number of S2M interfaces that perform backpressure.
	 * S2M_backp_cnt
	 * Reset: 0x0         Access: RW
	 */
	uint32_t s2m_backp_cnt;
	/*
	 * [0x1c] Crypto Command Done Counter
	 * Total number of CRYPTO commands executed
	 * CRYPTO_Command_dn_cnt
	 * Reset: 0x0         Access: RW
	 */
	uint32_t cmd_dn_cnt;
	/*
	 * [0x20] CRYPTO Source Blocks Counter
	 * Total number of Source Blocks read in CRYPTO commands
	 * CRYPTO_src_blocks_cnt
	 * Reset: 0x0         Access: RW
	 */
	uint32_t src_blocks_cnt;
	/*
	 * [0x24] CRYPTO Destination Blocks Counter
	 * Total number of Destination Blocks written in CRYPTO commands
	 * CRYPTO_dst_blocks_cnt
	 * Reset: 0x0         Access: RW
	 */
	uint32_t dst_blocks_cnt;
	/*
	 * [0x28] Recoverable Errors counter
	 * Total number of recoverable errors
	 * Recover_Errors_cnt
	 * Reset: 0x0         Access: RW
	 */
	uint32_t recover_err_cnt;
	/*
	 * [0x2c] Counts the number of data beats entering CRYPTO.
	 * CRYPTO_src_data_beats
	 * Reset: 0x0         Access: RW
	 */
	uint32_t src_data_beats;
	/*
	 * [0x30] Counts the number of the data beats exiting CRYPTO.
	 * CRYPTO_dst_data_beats
	 * Reset: 0x0         Access: RW
	 */
	uint32_t dst_data_beats;
	/* [0x34] */
	uint32_t rsrvd_0[7];
};

/**************************************************************************************************
 * al_crypto_accelerator_perfm_cnt_cntl
 *
 * Performance counter control
 **************************************************************************************************/
struct al_crypto_accelerator_perfm_cnt_cntl {
	/* [0x0] Performance counter control */
	uint32_t conf;
};

/**** conf register ****/
/*
 * Does not affect the recover_err_cnt
 * 0 - Clear performance counter
 * 1 - Stop performance counter
 * 2 - Active performance counter
 * Reset: 0x2         Access: RW
 */
#define CRYPTO_PERFM_CNT_CNTL_CONF_CONT_PERFORM_MASK 0x00000003
#define CRYPTO_PERFM_CNT_CNTL_CONF_CONT_PERFORM_SHIFT 0

/**************************************************************************************************
 * al_crypto_accelerator_crypto_status
 *
 * Crypto Pipe Status register
 **************************************************************************************************/
struct al_crypto_accelerator_crypto_status {
	/* [0x0] Crypto pipe status */
	uint32_t status;
};

/**** status register ****/
/*
 * Indicates when CRYPTO is empty
 * Reset: 0x1         Access: RO
 */
#define CRYPTO_CRYPTO_STATUS_STATUS_CRYPTO_EMPTY (1 << 0)
#define CRYPTO_CRYPTO_STATUS_STATUS_CRYPTO_EMPTY_MASK 0x00000001
#define CRYPTO_CRYPTO_STATUS_STATUS_CRYPTO_EMPTY_SHIFT 0
/*
 * Internal state of decoder
 * Reset: 0x0         Access: RO
 */
#define CRYPTO_CRYPTO_STATUS_STATUS_CRYPTO_DEC_STATE_MASK 0x0000003E
#define CRYPTO_CRYPTO_STATUS_STATUS_CRYPTO_DEC_STATE_SHIFT 1
/*
 * Internal state of dispatcher
 * Reset: 0x0         Access: RO
 */
#define CRYPTO_CRYPTO_STATUS_STATUS_CRYPTO_DISPATCHER_STATE_MASK 0x000003C0
#define CRYPTO_CRYPTO_STATUS_STATUS_CRYPTO_DISPATCHER_STATE_SHIFT 6
/*
 * Reserved
 * Reset: 0x0         Access: RO
 */
#define CRYPTO_CRYPTO_STATUS_STATUS_RESERVED_MASK 0xFFFFFC00
#define CRYPTO_CRYPTO_STATUS_STATUS_RESERVED_SHIFT 10

/**************************************************************************************************
 * al_crypto_accelerator_crypto_version
 *
 * Version of unit_crypto
 **************************************************************************************************/
struct al_crypto_accelerator_crypto_version {
	/* [0x0] Crypto Version */
	uint32_t revision;
	/* [0x4] Crypto Version */
	uint32_t date;
};

/**** revision register ****/
/*
 * 0x0 for M0, 0x1 for A0
 * Reset: 0x1         Access: RO
 */
#define CRYPTO_CRYPTO_VERSION_REVISION_REV_ID_MASK 0x0000FFFF
#define CRYPTO_CRYPTO_VERSION_REVISION_REV_ID_SHIFT 0
/*
 * Annapurna Labs PCI vendor ID
 * Reset: 0x1c36      Access: RO
 */
#define CRYPTO_CRYPTO_VERSION_REVISION_VENDOR_ID_MASK 0xFFFF0000
#define CRYPTO_CRYPTO_VERSION_REVISION_VENDOR_ID_SHIFT 16

/**** date register ****/
/*
 * Date of release
 * Reset: 0x1a        Access: RO
 */
#define CRYPTO_CRYPTO_VERSION_DATE_DATE_DAY_MASK 0x0000001F
#define CRYPTO_CRYPTO_VERSION_DATE_DATE_DAY_SHIFT 0
/*
 * Date of release
 * Reset: 0x0         Access: RO
 */
#define CRYPTO_CRYPTO_VERSION_DATE_RESERVED_7_5_MASK 0x000000E0
#define CRYPTO_CRYPTO_VERSION_DATE_RESERVED_7_5_SHIFT 5
/*
 * Month of release
 * Reset: 0x2         Access: RO
 */
#define CRYPTO_CRYPTO_VERSION_DATE_DATE_MONTH_MASK 0x00000F00
#define CRYPTO_CRYPTO_VERSION_DATE_DATE_MONTH_SHIFT 8
/*
 * Date of release
 * Reset: 0x0         Access: RO
 */
#define CRYPTO_CRYPTO_VERSION_DATE_RESERVED_15_12_MASK 0x0000F000
#define CRYPTO_CRYPTO_VERSION_DATE_RESERVED_15_12_SHIFT 12
/*
 * Month of release
 * Reset: 0xd         Access: RO
 */
#define CRYPTO_CRYPTO_VERSION_DATE_DATE_YEAR_MASK 0x00FF0000
#define CRYPTO_CRYPTO_VERSION_DATE_DATE_YEAR_SHIFT 16
/*
 * Date of release
 * Reset: 0x0         Access: RO
 */
#define CRYPTO_CRYPTO_VERSION_DATE_RESERVED_31_24_MASK 0xFF000000
#define CRYPTO_CRYPTO_VERSION_DATE_RESERVED_31_24_SHIFT 24

/**************************************************************************************************
 * al_crypto_accelerator_crypto_algorithms
 *
 * Algorithms supported by unit_crypto
 **************************************************************************************************/
struct al_crypto_accelerator_crypto_algorithms {
	/* [0x0] Crypto Encryption Algorithms */
	uint32_t encryption;
	/* [0x4] Crypto Compression Algorithms */
	uint32_t compression;
};

/**** encryption register ****/
/*
 * AES ECB
 * Reset: 0x1         Access: RO
 */
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_AES_ECB (1 << 0)
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_AES_ECB_MASK 0x00000001
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_AES_ECB_SHIFT 0
/*
 * AES CBC
 * Reset: 0x1         Access: RO
 */
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_AES_CBC (1 << 1)
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_AES_CBC_MASK 0x00000002
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_AES_CBC_SHIFT 1
/*
 * AES_CTR
 * Reset: 0x1         Access: RO
 */
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_AES_CTR (1 << 2)
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_AES_CTR_MASK 0x00000004
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_AES_CTR_SHIFT 2
/*
 * AES CFB
 * Reset: 0x0         Access: RO
 */
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_AES_CFB (1 << 3)
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_AES_CFB_MASK 0x00000008
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_AES_CFB_SHIFT 3
/*
 * AES OFB
 * Reset: 0x0         Access: RO
 */
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_AES_OFB (1 << 4)
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_AES_OFB_MASK 0x00000010
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_AES_OFB_SHIFT 4
/*
 * AES GCM
 * Reset: 0x1         Access: RO
 */
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_AES_GCM (1 << 5)
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_AES_GCM_MASK 0x00000020
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_AES_GCM_SHIFT 5
/*
 * AES CCM
 * Reset: 0x1         Access: RO
 */
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_AES_CCM (1 << 6)
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_AES_CCM_MASK 0x00000040
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_AES_CCM_SHIFT 6
/*
 * AES XTS
 * Reset: 0x1         Access: RO
 */
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_AES_XTS (1 << 7)
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_AES_XTS_MASK 0x00000080
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_AES_XTS_SHIFT 7
/*
 * SHA3_DEFAULT_PARAMS
 * Reset: 0x1         Access: RO
 */
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_SHA_3_DEFAULT (1 << 8)
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_SHA_3_DEFAULT_MASK 0x00000100
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_SHA_3_DEFAULT_SHIFT 8
/*
 * SHA3_224
 * Reset: 0x1         Access: RO
 */
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_SHA_3_224 (1 << 9)
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_SHA_3_224_MASK 0x00000200
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_SHA_3_224_SHIFT 9
/*
 * SHA3_256
 * Reset: 0x1         Access: RO
 */
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_SHA_3_256 (1 << 10)
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_SHA_3_256_MASK 0x00000400
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_SHA_3_256_SHIFT 10
/*
 * SHA3_384
 * Reset: 0x1         Access: RO
 */
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_SHA_3_384 (1 << 11)
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_SHA_3_384_MASK 0x00000800
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_SHA_3_384_SHIFT 11
/*
 * SHA3_512
 * Reset: 0x1         Access: RO
 */
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_SHA_3_512 (1 << 12)
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_SHA_3_512_MASK 0x00001000
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_SHA_3_512_SHIFT 12
/*
 * SHA-1
 * Reset: 0x1         Access: RO
 */
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_SHA_1 (1 << 13)
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_SHA_1_MASK 0x00002000
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_SHA_1_SHIFT 13
/*
 * SHA2_256
 * Reset: 0x1         Access: RO
 */
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_SHA_2_256 (1 << 14)
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_SHA_2_256_MASK 0x00004000
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_SHA_2_256_SHIFT 14
/*
 * SHA2_384
 * Reset: 0x1         Access: RO
 */
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_SHA_2_384 (1 << 15)
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_SHA_2_384_MASK 0x00008000
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_SHA_2_384_SHIFT 15
/*
 * SHA2_512
 * Reset: 0x1         Access: RO
 */
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_SHA_2_512 (1 << 16)
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_SHA_2_512_MASK 0x00010000
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_SHA_2_512_SHIFT 16
/*
 * MD-5
 * Reset: 0x1         Access: RO
 */
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_MD_5 (1 << 17)
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_MD_5_MASK 0x00020000
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_MD_5_SHIFT 17
/*
 * SHAKE_128
 * Reset: 0x1         Access: RO
 */
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_SHAKE_128 (1 << 18)
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_SHAKE_128_MASK 0x00040000
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_SHAKE_128_SHIFT 18
/*
 * SHAKE_256
 * Reset: 0x1         Access: RO
 */
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_SHAKE_256 (1 << 19)
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_SHAKE_256_MASK 0x00080000
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_SHAKE_256_SHIFT 19
/*
 * Reserved
 * Reset: 0x0         Access: RO
 */
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_RESERVED (1 << 20)
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_RESERVED_MASK 0x00100000
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_RESERVED_SHIFT 20
/*
 * AES XTS CipherText Stealing
 * Reset: 0x1         Access: RO
 */
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_AES_XTS_CTS (1 << 21)
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_AES_XTS_CTS_MASK 0x00200000
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_AES_XTS_CTS_SHIFT 21
/*
 * AES ECB CipherText Stealing
 * Reset: 0x1         Access: RO
 */
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_AES_ECB_CTS (1 << 22)
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_AES_ECB_CTS_MASK 0x00400000
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_AES_ECB_CTS_SHIFT 22
/*
 * AES CBC CipherText Stealing
 * Reset: 0x1         Access: RO
 */
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_AES_CBC_CTS (1 << 23)
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_AES_CBC_CTS_MASK 0x00800000
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_AES_CBC_CTS_SHIFT 23
/*
 * DES ECB
 * Reset: 0x1         Access: RO
 */
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_DES_ECB (1 << 24)
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_DES_ECB_MASK 0x01000000
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_DES_ECB_SHIFT 24
/*
 * DES CBC
 * Reset: 0x1         Access: RO
 */
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_DES_CBC (1 << 25)
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_DES_CBC_MASK 0x02000000
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_DES_CBC_SHIFT 25
/*
 * DES3 ECB
 * Reset: 0x1         Access: RO
 */
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_DES3_ECB (1 << 26)
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_DES3_ECB_MASK 0x04000000
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_DES3_ECB_SHIFT 26
/*
 * DES3 CBC
 * Reset: 0x1         Access: RO
 */
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_DES3_CBC (1 << 27)
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_DES3_CBC_MASK 0x08000000
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_DES3_CBC_SHIFT 27
/*
 * Reserved
 * Reset: 0x0         Access: RO
 */
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_RESERVED_31_28_MASK 0xF0000000
#define CRYPTO_CRYPTO_ALGORITHMS_ENCRYPTION_RESERVED_31_28_SHIFT 28

/**** compression register ****/
/*
 * LZ77 Compression
 * Reset: 0x1         Access: RO
 */
#define CRYPTO_CRYPTO_ALGORITHMS_COMPRESSION_LZ77_ENC (1 << 0)
#define CRYPTO_CRYPTO_ALGORITHMS_COMPRESSION_LZ77_ENC_MASK 0x00000001
#define CRYPTO_CRYPTO_ALGORITHMS_COMPRESSION_LZ77_ENC_SHIFT 0
/*
 * LZ77 Decompression
 * Reset: 0x1         Access: RO
 */
#define CRYPTO_CRYPTO_ALGORITHMS_COMPRESSION_LZ77_DEC (1 << 1)
#define CRYPTO_CRYPTO_ALGORITHMS_COMPRESSION_LZ77_DEC_MASK 0x00000002
#define CRYPTO_CRYPTO_ALGORITHMS_COMPRESSION_LZ77_DEC_SHIFT 1
/*
 * LZSS Compression
 * Reset: 0x1         Access: RO
 */
#define CRYPTO_CRYPTO_ALGORITHMS_COMPRESSION_LZSS_ENC (1 << 2)
#define CRYPTO_CRYPTO_ALGORITHMS_COMPRESSION_LZSS_ENC_MASK 0x00000004
#define CRYPTO_CRYPTO_ALGORITHMS_COMPRESSION_LZSS_ENC_SHIFT 2
/*
 * LZSS Decompression
 * Reset: 0x1         Access: RO
 */
#define CRYPTO_CRYPTO_ALGORITHMS_COMPRESSION_LZSS_DEC (1 << 3)
#define CRYPTO_CRYPTO_ALGORITHMS_COMPRESSION_LZSS_DEC_MASK 0x00000008
#define CRYPTO_CRYPTO_ALGORITHMS_COMPRESSION_LZSS_DEC_SHIFT 3
/*
 * LZ4 Compression
 * Reset: 0x1         Access: RO
 */
#define CRYPTO_CRYPTO_ALGORITHMS_COMPRESSION_LZ4_ENC (1 << 4)
#define CRYPTO_CRYPTO_ALGORITHMS_COMPRESSION_LZ4_ENC_MASK 0x00000010
#define CRYPTO_CRYPTO_ALGORITHMS_COMPRESSION_LZ4_ENC_SHIFT 4
/*
 * LZ4 Decompression
 * Reset: 0x1         Access: RO
 */
#define CRYPTO_CRYPTO_ALGORITHMS_COMPRESSION_LZ4_DEC (1 << 5)
#define CRYPTO_CRYPTO_ALGORITHMS_COMPRESSION_LZ4_DEC_MASK 0x00000020
#define CRYPTO_CRYPTO_ALGORITHMS_COMPRESSION_LZ4_DEC_SHIFT 5
/*
 * Huffman Static Compression
 * Reset: 0x0         Access: RO
 */
#define CRYPTO_CRYPTO_ALGORITHMS_COMPRESSION_HUFFMAN_STAT_ENC (1 << 6)
#define CRYPTO_CRYPTO_ALGORITHMS_COMPRESSION_HUFFMAN_STAT_ENC_MASK 0x00000040
#define CRYPTO_CRYPTO_ALGORITHMS_COMPRESSION_HUFFMAN_STAT_ENC_SHIFT 6
/*
 * Huffman Static Decompression
 * Reset: 0x0         Access: RO
 */
#define CRYPTO_CRYPTO_ALGORITHMS_COMPRESSION_HUFFMAN_STAT_DEC (1 << 7)
#define CRYPTO_CRYPTO_ALGORITHMS_COMPRESSION_HUFFMAN_STAT_DEC_MASK 0x00000080
#define CRYPTO_CRYPTO_ALGORITHMS_COMPRESSION_HUFFMAN_STAT_DEC_SHIFT 7
/*
 * Huffman Dynamic Compression
 * Reset: 0x0         Access: RO
 */
#define CRYPTO_CRYPTO_ALGORITHMS_COMPRESSION_HUFFMAN_DYN_ENC (1 << 8)
#define CRYPTO_CRYPTO_ALGORITHMS_COMPRESSION_HUFFMAN_DYN_ENC_MASK 0x00000100
#define CRYPTO_CRYPTO_ALGORITHMS_COMPRESSION_HUFFMAN_DYN_ENC_SHIFT 8
/*
 * Huffman Dynamic Decompression
 * Reset: 0x0         Access: RO
 */
#define CRYPTO_CRYPTO_ALGORITHMS_COMPRESSION_HUFFMAN_DYN_DEC (1 << 9)
#define CRYPTO_CRYPTO_ALGORITHMS_COMPRESSION_HUFFMAN_DYN_DEC_MASK 0x00000200
#define CRYPTO_CRYPTO_ALGORITHMS_COMPRESSION_HUFFMAN_DYN_DEC_SHIFT 9
/*
 * Deflate Static Compression
 * Reset: 0x1         Access: RO
 */
#define CRYPTO_CRYPTO_ALGORITHMS_COMPRESSION_DEFLATE_STAT_ENC (1 << 10)
#define CRYPTO_CRYPTO_ALGORITHMS_COMPRESSION_DEFLATE_STAT_ENC_MASK 0x00000400
#define CRYPTO_CRYPTO_ALGORITHMS_COMPRESSION_DEFLATE_STAT_ENC_SHIFT 10
/*
 * Deflate Static Decompression
 * Reset: 0x1         Access: RO
 */
#define CRYPTO_CRYPTO_ALGORITHMS_COMPRESSION_DEFLATE_STAT_DEC (1 << 11)
#define CRYPTO_CRYPTO_ALGORITHMS_COMPRESSION_DEFLATE_STAT_DEC_MASK 0x00000800
#define CRYPTO_CRYPTO_ALGORITHMS_COMPRESSION_DEFLATE_STAT_DEC_SHIFT 11
/*
 * Deflate Dynamic Compression
 * Reset: 0x0         Access: RO
 */
#define CRYPTO_CRYPTO_ALGORITHMS_COMPRESSION_DEFLATE_DYN_ENC (1 << 12)
#define CRYPTO_CRYPTO_ALGORITHMS_COMPRESSION_DEFLATE_DYN_ENC_MASK 0x00001000
#define CRYPTO_CRYPTO_ALGORITHMS_COMPRESSION_DEFLATE_DYN_ENC_SHIFT 12
/*
 * Deflate Dynamic Decompression
 * Reset: 0x1         Access: RO
 */
#define CRYPTO_CRYPTO_ALGORITHMS_COMPRESSION_DEFLATE_DYN_DEC (1 << 13)
#define CRYPTO_CRYPTO_ALGORITHMS_COMPRESSION_DEFLATE_DYN_DEC_MASK 0x00002000
#define CRYPTO_CRYPTO_ALGORITHMS_COMPRESSION_DEFLATE_DYN_DEC_SHIFT 13
/*
 * LZO Compression
 * Reset: 0x0         Access: RO
 */
#define CRYPTO_CRYPTO_ALGORITHMS_COMPRESSION_LZO_ENC (1 << 14)
#define CRYPTO_CRYPTO_ALGORITHMS_COMPRESSION_LZO_ENC_MASK 0x00004000
#define CRYPTO_CRYPTO_ALGORITHMS_COMPRESSION_LZO_ENC_SHIFT 14
/*
 * LZO Decompression
 * Reset: 0x0         Access: RO
 */
#define CRYPTO_CRYPTO_ALGORITHMS_COMPRESSION_LZO_DEC (1 << 15)
#define CRYPTO_CRYPTO_ALGORITHMS_COMPRESSION_LZO_DEC_MASK 0x00008000
#define CRYPTO_CRYPTO_ALGORITHMS_COMPRESSION_LZO_DEC_SHIFT 15
/*
 * Snappy Compression
 * Reset: 0x0         Access: RO
 */
#define CRYPTO_CRYPTO_ALGORITHMS_COMPRESSION_SNAPPY_ENC (1 << 16)
#define CRYPTO_CRYPTO_ALGORITHMS_COMPRESSION_SNAPPY_ENC_MASK 0x00010000
#define CRYPTO_CRYPTO_ALGORITHMS_COMPRESSION_SNAPPY_ENC_SHIFT 16
/*
 * Snappy Decompression
 * Reset: 0x0         Access: RO
 */
#define CRYPTO_CRYPTO_ALGORITHMS_COMPRESSION_SNAPPY_DEC (1 << 17)
#define CRYPTO_CRYPTO_ALGORITHMS_COMPRESSION_SNAPPY_DEC_MASK 0x00020000
#define CRYPTO_CRYPTO_ALGORITHMS_COMPRESSION_SNAPPY_DEC_SHIFT 17
/*
 * Reserved
 * Reset: 0x1         Access: RO
 */
#define CRYPTO_CRYPTO_ALGORITHMS_COMPRESSION_RESERVED_31_18_MASK 0xFFFC0000
#define CRYPTO_CRYPTO_ALGORITHMS_COMPRESSION_RESERVED_31_18_SHIFT 18

/**************************************************************************************************
 * al_crypto_accelerator_reserved
 *
 * reserved regs
 **************************************************************************************************/
struct al_crypto_accelerator_reserved {
	/*
	 * [0x0] Reserved
	 * Reset: 0x0         Access: RW
	 */
	uint32_t reserved_0;
	/*
	 * [0x4] Reserved
	 * Reset: 0x0         Access: RW
	 */
	uint32_t reserved_1;
	/*
	 * [0x8] Reserved
	 * Reset: 0x0         Access: RW
	 */
	uint32_t reserved_2;
	/*
	 * [0xc] Reserved
	 * Reset: 0x0         Access: RW
	 */
	uint32_t reserved_3;
};

/**************************************************************************************************
 * al_crypto_accelerator_sha3_round_consts
 *
 * sha3 consts
 **************************************************************************************************/
struct al_crypto_accelerator_sha3_round_consts {
	/*
	 * [0x0] round consts msbs
	 * Reset: 0x0         Access: RW
	 */
	uint32_t hi;
	/*
	 * [0x4] round consts lsbs
	 * Reset: 0x0         Access: RW
	 */
	uint32_t lo;
};

/**************************************************************************************************
 * al_crypto_accelerator_sha3_params
 *
 * sha3 implementation parameters
 **************************************************************************************************/
struct al_crypto_accelerator_sha3_params {
	/* [0x0] */
	uint32_t num_rounds;
	/*
	 * [0x4] sponge function bitrate. This value determines the security level and performance
	 * of the hash function (defined by standard).
	 */
	uint32_t bitrate_sha3_224;
	/*
	 * [0x8] sponge function bitrate. This value determines the security level and performance
	 * of the hash function (defined by standard).
	 */
	uint32_t bitrate_sha3_256;
	/*
	 * [0xc] sponge function bitrate. This value determines the security level and performance
	 * of the hash function (defined by standard).
	 */
	uint32_t bitrate_sha3_384;
	/*
	 * [0x10] sponge function bitrate. This value determines the security level and performance
	 * of the hash function (defined by standard).
	 */
	uint32_t bitrate_sha3_512;
	/*
	 * [0x14] sponge function bitrate. This value determines the security level and performance
	 * of the hash function (defined by standard).
	 */
	uint32_t bitrate_shake_128;
	/*
	 * [0x18] sponge function bitrate. This value determines the security level and performance
	 * of the hash function (defined by standard).
	 */
	uint32_t bitrate_shake_256;
	/*
	 * [0x1c] sponge function bitrate. This value determines the security level and performance
	 * of the hash function (defined by standard).
	 */
	uint32_t bitrate_default;
	/* [0x20] */
	uint32_t padding_sha3;
	/* [0x24] */
	uint32_t padding_shake;
	/* [0x28] */
	uint32_t endianity;
	/* [0x2c] */
	uint32_t rsrvd_0;
};

/**** num_rounds register ****/
/*
 * number of iterations in SHA3 calculation
 * Reset: 0x18        Access: RW
 */
#define CRYPTO_SHA3_PARAMS_NUM_ROUNDS_VAL_MASK 0x0000003F
#define CRYPTO_SHA3_PARAMS_NUM_ROUNDS_VAL_SHIFT 0

/**** bitrate_sha3_224 register ****/
/*
 * bitrate value in bytes. value must be 0-200.
 * change from default value with care (value is defined by standard)
 * Reset: 0x90        Access: RW
 */
#define CRYPTO_SHA3_PARAMS_BITRATE_SHA3_224_VAL_MASK 0x000000FF
#define CRYPTO_SHA3_PARAMS_BITRATE_SHA3_224_VAL_SHIFT 0

/**** bitrate_sha3_256 register ****/
/*
 * bitrate value in bytes. value must be 0-200.
 * change from default value with care (value is defined by standard)
 * Reset: 0x88        Access: RW
 */
#define CRYPTO_SHA3_PARAMS_BITRATE_SHA3_256_VAL_MASK 0x000000FF
#define CRYPTO_SHA3_PARAMS_BITRATE_SHA3_256_VAL_SHIFT 0

/**** bitrate_sha3_384 register ****/
/*
 * bitrate value in bytes. value must be 0-200.
 * change from default value with care (value is defined by standard)
 * Reset: 0x68        Access: RW
 */
#define CRYPTO_SHA3_PARAMS_BITRATE_SHA3_384_VAL_MASK 0x000000FF
#define CRYPTO_SHA3_PARAMS_BITRATE_SHA3_384_VAL_SHIFT 0

/**** bitrate_sha3_512 register ****/
/*
 * bitrate value in bytes. value must be 0-200.
 * change from default value with care (value is defined by standard)
 * Reset: 0x48        Access: RW
 */
#define CRYPTO_SHA3_PARAMS_BITRATE_SHA3_512_VAL_MASK 0x000000FF
#define CRYPTO_SHA3_PARAMS_BITRATE_SHA3_512_VAL_SHIFT 0

/**** bitrate_shake_128 register ****/
/*
 * bitrate value in bytes. value must be 0-200.
 * change from default value with care (value is defined by standard)
 * Reset: 0xa8        Access: RW
 */
#define CRYPTO_SHA3_PARAMS_BITRATE_SHAKE_128_VAL_MASK 0x000000FF
#define CRYPTO_SHA3_PARAMS_BITRATE_SHAKE_128_VAL_SHIFT 0

/**** bitrate_shake_256 register ****/
/*
 * bitrate value in bytes. value must be 0-200.
 * change from default value with care (value is defined by standard)
 * Reset: 0x88        Access: RW
 */
#define CRYPTO_SHA3_PARAMS_BITRATE_SHAKE_256_VAL_MASK 0x000000FF
#define CRYPTO_SHA3_PARAMS_BITRATE_SHAKE_256_VAL_SHIFT 0

/**** bitrate_default register ****/
/*
 * bitrate value in bytes. value must be 0-200.
 * change from default value with care (value is defined by standard)
 * Reset: 0x80        Access: RW
 */
#define CRYPTO_SHA3_PARAMS_BITRATE_DEFAULT_VAL_MASK 0x000000FF
#define CRYPTO_SHA3_PARAMS_BITRATE_DEFAULT_VAL_SHIFT 0

/**** padding_sha3 register ****/
/*
 * padding on first byte after payload
 * Reset: 0x6         Access: RW
 */
#define CRYPTO_SHA3_PARAMS_PADDING_SHA3_START_MASK 0x000000FF
#define CRYPTO_SHA3_PARAMS_PADDING_SHA3_START_SHIFT 0
/*
 * padding on bytes which are not first after payload, or last in word
 * Reset: 0x0         Access: RW
 */
#define CRYPTO_SHA3_PARAMS_PADDING_SHA3_MID_MASK 0x0000FF00
#define CRYPTO_SHA3_PARAMS_PADDING_SHA3_MID_SHIFT 8
/*
 * padding on last byte in word
 * Reset: 0x80        Access: RW
 */
#define CRYPTO_SHA3_PARAMS_PADDING_SHA3_END_MASK 0x00FF0000
#define CRYPTO_SHA3_PARAMS_PADDING_SHA3_END_SHIFT 16
/*
 * single byte padding value
 * Reset: 0x86        Access: RW
 */
#define CRYPTO_SHA3_PARAMS_PADDING_SHA3_START_END_MASK 0xFF000000
#define CRYPTO_SHA3_PARAMS_PADDING_SHA3_START_END_SHIFT 24

/**** padding_shake register ****/
/*
 * padding on first byte after payload
 * Reset: 0x1f        Access: RW
 */
#define CRYPTO_SHA3_PARAMS_PADDING_SHAKE_START_MASK 0x000000FF
#define CRYPTO_SHA3_PARAMS_PADDING_SHAKE_START_SHIFT 0
/*
 * padding on bytes which are not first after payload, or last in word
 * Reset: 0x0         Access: RW
 */
#define CRYPTO_SHA3_PARAMS_PADDING_SHAKE_MID_MASK 0x0000FF00
#define CRYPTO_SHA3_PARAMS_PADDING_SHAKE_MID_SHIFT 8
/*
 * padding on last byte in word
 * Reset: 0x80        Access: RW
 */
#define CRYPTO_SHA3_PARAMS_PADDING_SHAKE_END_MASK 0x00FF0000
#define CRYPTO_SHA3_PARAMS_PADDING_SHAKE_END_SHIFT 16
/*
 * single byte padding value
 * Reset: 0x9f        Access: RW
 */
#define CRYPTO_SHA3_PARAMS_PADDING_SHAKE_START_END_MASK 0xFF000000
#define CRYPTO_SHA3_PARAMS_PADDING_SHAKE_START_END_SHIFT 24

/**** endianity register ****/
/*
 * when asserted, sha3 performs bit-swap for every byte on the input data
 * Reset: 0x0         Access: RW
 */
#define CRYPTO_SHA3_PARAMS_ENDIANITY_BIT_SWAP_IN (1 << 0)
#define CRYPTO_SHA3_PARAMS_ENDIANITY_BIT_SWAP_IN_MASK 0x00000001
#define CRYPTO_SHA3_PARAMS_ENDIANITY_BIT_SWAP_IN_SHIFT 0
/*
 * when asserted, sha3 performs bit-swap for every byte on the output data
 * Reset: 0x0         Access: RW
 */
#define CRYPTO_SHA3_PARAMS_ENDIANITY_BIT_SWAP_OUT (1 << 1)
#define CRYPTO_SHA3_PARAMS_ENDIANITY_BIT_SWAP_OUT_MASK 0x00000002
#define CRYPTO_SHA3_PARAMS_ENDIANITY_BIT_SWAP_OUT_SHIFT 1
/*
 * take digests from state's msbs
 * Reset: 0x1         Access: RW
 */
#define CRYPTO_SHA3_PARAMS_ENDIANITY_DIGEST_FROM_MSBS (1 << 2)
#define CRYPTO_SHA3_PARAMS_ENDIANITY_DIGEST_FROM_MSBS_MASK 0x00000004
#define CRYPTO_SHA3_PARAMS_ENDIANITY_DIGEST_FROM_MSBS_SHIFT 2

/**************************************************************************************************
 * al_crypto_accelerator_sha3_debug
 *
 * sha3 implementation parameters
 **************************************************************************************************/
struct al_crypto_accelerator_sha3_debug {
	/* [0x0] */
	uint32_t fsm_state;
	/* [0x4] */
	uint32_t rsrvd_0[3];
};

/**** fsm_state register ****/
/*
 * current state of preprocessor block (in charge of padding and serial->parallel abosrption
 * Reset: 0x0         Access: RO
 */
#define CRYPTO_SHA3_DEBUG_FSM_STATE_PREPROC_MASK 0x0000000F
#define CRYPTO_SHA3_DEBUG_FSM_STATE_PREPROC_SHIFT 0
/*
 * current state of sha3 engine
 * Reset: 0x0         Access: RO
 */
#define CRYPTO_SHA3_DEBUG_FSM_STATE_ENGINE_MASK 0x000000F0
#define CRYPTO_SHA3_DEBUG_FSM_STATE_ENGINE_SHIFT 4
/*
 * current state of sha3 engine
 * Reset: 0x0         Access: RO
 */
#define CRYPTO_SHA3_DEBUG_FSM_STATE_PERM_MASK 0x00000F00
#define CRYPTO_SHA3_DEBUG_FSM_STATE_PERM_SHIFT 8
/*
 * current round counter value
 * Reset: 0x0         Access: RO
 */
#define CRYPTO_SHA3_DEBUG_FSM_STATE_ROUND_CNTR_MASK 0x0003F000
#define CRYPTO_SHA3_DEBUG_FSM_STATE_ROUND_CNTR_SHIFT 12

/**************************************************************************************************
 * al_crypto_accelerator_xts_conf
 *
 * xts configuration
 **************************************************************************************************/
struct al_crypto_accelerator_xts_conf {
	/*
	 * [0x0] lba increment factor, for multiple concatenated blocks in a single pkt (lsbs)
	 * Reset: 0x1         Access: RW
	 */
	uint32_t lba_inc_0;
	/*
	 * [0x4] lba increment factor, for multiple concatenated blocks in a single pkt
	 * Reset: 0x0         Access: RW
	 */
	uint32_t lba_inc_1;
	/*
	 * [0x8] lba increment factor, for multiple concatenated blocks in a single pkt
	 * Reset: 0x0         Access: RW
	 */
	uint32_t lba_inc_2;
	/*
	 * [0xc] lba increment factor, for multiple concatenated blocks in a single pkt (msbs)
	 * Reset: 0x0         Access: RW
	 */
	uint32_t lba_inc_3;
	/*
	 * [0x10] lba alpha constant, for multiple concatenated blocks in a single pkt (lsbs)
	 * Reset: 0x2         Access: RW
	 */
	uint32_t alpha_0;
	/*
	 * [0x14] lba alpha constant, for multiple concatenated blocks in a single pkt
	 * Reset: 0x0         Access: RW
	 */
	uint32_t alpha_1;
	/*
	 * [0x18] lba alpha constant, for multiple concatenated blocks in a single pkt
	 * Reset: 0x0         Access: RW
	 */
	uint32_t alpha_2;
	/*
	 * [0x1c] lba alpha constant, for multiple concatenated blocks in a single pkt (msbs)
	 * Reset: 0x0         Access: RW
	 */
	uint32_t alpha_3;
	/* [0x20] endianity flexibility support */
	uint32_t tweak_calc_swap;
	/* [0x24] */
	uint32_t rsrvd_0[7];
};

/**** tweak_calc_swap register ****/
/* Reset: 0x0         Access: RW */
#define CRYPTO_XTS_CONF_TWEAK_CALC_SWAP_PRE_INC_BITS (1 << 0)
#define CRYPTO_XTS_CONF_TWEAK_CALC_SWAP_PRE_INC_BITS_MASK 0x00000001
#define CRYPTO_XTS_CONF_TWEAK_CALC_SWAP_PRE_INC_BITS_SHIFT 0
/* Reset: 0x0         Access: RW */
#define CRYPTO_XTS_CONF_TWEAK_CALC_SWAP_PRE_INC_BYTES (1 << 1)
#define CRYPTO_XTS_CONF_TWEAK_CALC_SWAP_PRE_INC_BYTES_MASK 0x00000002
#define CRYPTO_XTS_CONF_TWEAK_CALC_SWAP_PRE_INC_BYTES_SHIFT 1
/* Reset: 0x0         Access: RW */
#define CRYPTO_XTS_CONF_TWEAK_CALC_SWAP_PRE_INC_WORDS (1 << 2)
#define CRYPTO_XTS_CONF_TWEAK_CALC_SWAP_PRE_INC_WORDS_MASK 0x00000004
#define CRYPTO_XTS_CONF_TWEAK_CALC_SWAP_PRE_INC_WORDS_SHIFT 2
/* Reset: 0x0         Access: RW */
#define CRYPTO_XTS_CONF_TWEAK_CALC_SWAP_POST_INC_BITS (1 << 3)
#define CRYPTO_XTS_CONF_TWEAK_CALC_SWAP_POST_INC_BITS_MASK 0x00000008
#define CRYPTO_XTS_CONF_TWEAK_CALC_SWAP_POST_INC_BITS_SHIFT 3
/* Reset: 0x1         Access: RW */
#define CRYPTO_XTS_CONF_TWEAK_CALC_SWAP_POST_INC_BYTES (1 << 4)
#define CRYPTO_XTS_CONF_TWEAK_CALC_SWAP_POST_INC_BYTES_MASK 0x00000010
#define CRYPTO_XTS_CONF_TWEAK_CALC_SWAP_POST_INC_BYTES_SHIFT 4
/* Reset: 0x0         Access: RW */
#define CRYPTO_XTS_CONF_TWEAK_CALC_SWAP_POST_INC_WORDS (1 << 5)
#define CRYPTO_XTS_CONF_TWEAK_CALC_SWAP_POST_INC_WORDS_MASK 0x00000020
#define CRYPTO_XTS_CONF_TWEAK_CALC_SWAP_POST_INC_WORDS_SHIFT 5
/* Reset: 0x0         Access: RW */
#define CRYPTO_XTS_CONF_TWEAK_CALC_SWAP_RESERVED_31_6_MASK 0xFFFFFFC0
#define CRYPTO_XTS_CONF_TWEAK_CALC_SWAP_RESERVED_31_6_SHIFT 6

/**************************************************************************************************
 * al_crypto_accelerator_gmac_conf
 *
 * gmac configuration
 **************************************************************************************************/
struct al_crypto_accelerator_gmac_conf {
	/* [0x0] FSM status */
	uint32_t fsm_status;
	/* [0x4] gmac override configuration */
	uint32_t override;
	/* [0x8] endianity flexibility support */
	uint32_t endianity_swap;
	/* [0xc] data mask polarity */
	uint32_t data_mask_polarity;
};

/**** fsm_status register ****/
/* Reset: 0x0         Access: RO */
#define CRYPTO_GMAC_CONF_FSM_STATUS_FSM_STATE_MASK 0x00000007
#define CRYPTO_GMAC_CONF_FSM_STATUS_FSM_STATE_SHIFT 0
/* Reset: 0x0         Access: RO */
#define CRYPTO_GMAC_CONF_FSM_STATUS_RESERVED_31_3_MASK 0xFFFFFFF8
#define CRYPTO_GMAC_CONF_FSM_STATUS_RESERVED_31_3_SHIFT 3

/**** override register ****/
/*
 * Chicken bit that disables parallel operation of gmac. Allows more reliable work with high latency
 * of minimum 16 cycles per packet
 * Reset: 0x0         Access: RW
 */
#define CRYPTO_GMAC_CONF_OVERRIDE_DO_AUTH_SERIAL (1 << 0)
#define CRYPTO_GMAC_CONF_OVERRIDE_DO_AUTH_SERIAL_MASK 0x00000001
#define CRYPTO_GMAC_CONF_OVERRIDE_DO_AUTH_SERIAL_SHIFT 0
/*
 * Override profile table to enforce gmac calculation
 * Reset: 0x0         Access: RW
 */
#define CRYPTO_GMAC_CONF_OVERRIDE_AUTH_OVERRIDE_EN (1 << 1)
#define CRYPTO_GMAC_CONF_OVERRIDE_AUTH_OVERRIDE_EN_MASK 0x00000002
#define CRYPTO_GMAC_CONF_OVERRIDE_AUTH_OVERRIDE_EN_SHIFT 1
/*
 * Override profile table to disable gmac calculation
 * Reset: 0x0         Access: RW
 */
#define CRYPTO_GMAC_CONF_OVERRIDE_AUTH_OVERRIDE_DIS (1 << 2)
#define CRYPTO_GMAC_CONF_OVERRIDE_AUTH_OVERRIDE_DIS_MASK 0x00000004
#define CRYPTO_GMAC_CONF_OVERRIDE_AUTH_OVERRIDE_DIS_SHIFT 2
/*
 * Override profile table to determine gmac operation direction (generation or validation)
 * Reset: 0x0         Access: RW
 */
#define CRYPTO_GMAC_CONF_OVERRIDE_VAL_GEN_N_OVERRID_EN (1 << 3)
#define CRYPTO_GMAC_CONF_OVERRIDE_VAL_GEN_N_OVERRID_EN_MASK 0x00000008
#define CRYPTO_GMAC_CONF_OVERRIDE_VAL_GEN_N_OVERRID_EN_SHIFT 3
/*
 * 0 - Signature generation. 1 - Signature validation. Only relevant if override bit is enabled
 * Reset: 0x0         Access: RW
 */
#define CRYPTO_GMAC_CONF_OVERRIDE_VAL_GEN_N (1 << 4)
#define CRYPTO_GMAC_CONF_OVERRIDE_VAL_GEN_N_MASK 0x00000010
#define CRYPTO_GMAC_CONF_OVERRIDE_VAL_GEN_N_SHIFT 4
/*
 * Override profile table to determine gmac authentication mode
 * Reset: 0x0         Access: RW
 */
#define CRYPTO_GMAC_CONF_OVERRIDE_AUTH_MODE_OVERRIDE (1 << 5)
#define CRYPTO_GMAC_CONF_OVERRIDE_AUTH_MODE_OVERRIDE_MASK 0x00000020
#define CRYPTO_GMAC_CONF_OVERRIDE_AUTH_MODE_OVERRIDE_SHIFT 5
/*
 * 0 - GMAC. 1:3 - Reserved. Only relevant if override bit is enabled
 * Reset: 0x0         Access: RW
 */
#define CRYPTO_GMAC_CONF_OVERRIDE_AUTH_MODE_MASK 0x000000C0
#define CRYPTO_GMAC_CONF_OVERRIDE_AUTH_MODE_SHIFT 6
/*
 * Override profile table to determine aes key type
 * Reset: 0x0         Access: RW
 */
#define CRYPTO_GMAC_CONF_OVERRIDE_KEY_TYPE_OVERRIDE (1 << 8)
#define CRYPTO_GMAC_CONF_OVERRIDE_KEY_TYPE_OVERRIDE_MASK 0x00000100
#define CRYPTO_GMAC_CONF_OVERRIDE_KEY_TYPE_OVERRIDE_SHIFT 8
/*
 * 0 - 128-bit key. 1 -192-bit key. 2 - 256-bit key. 3 - Reserved. Only relevant if override bit is
 * enabled
 * Reset: 0x0         Access: RW
 */
#define CRYPTO_GMAC_CONF_OVERRIDE_KEY_TYPE_MASK 0x00000600
#define CRYPTO_GMAC_CONF_OVERRIDE_KEY_TYPE_SHIFT 9
/*
 * Override profile table to determine signature size
 * Reset: 0x0         Access: RW
 */
#define CRYPTO_GMAC_CONF_OVERRIDE_SIGN_SIZE_OVERRIDE (1 << 11)
#define CRYPTO_GMAC_CONF_OVERRIDE_SIGN_SIZE_OVERRIDE_MASK 0x00000800
#define CRYPTO_GMAC_CONF_OVERRIDE_SIGN_SIZE_OVERRIDE_SHIFT 11
/*
 * Sign size is 4*(N+1) bytes. Only lower 2 bits are used.
 * Reset: 0x0         Access: RW
 */
#define CRYPTO_GMAC_CONF_OVERRIDE_SIGN_SIZE_MASK 0x0000F000
#define CRYPTO_GMAC_CONF_OVERRIDE_SIGN_SIZE_SHIFT 12
/*
 * Override profile table to determine signature digest polarity
 * Reset: 0x0         Access: RW
 */
#define CRYPTO_GMAC_CONF_OVERRIDE_DIGEST_FROM_MSB_OVERRIDE (1 << 16)
#define CRYPTO_GMAC_CONF_OVERRIDE_DIGEST_FROM_MSB_OVERRIDE_MASK 0x00010000
#define CRYPTO_GMAC_CONF_OVERRIDE_DIGEST_FROM_MSB_OVERRIDE_SHIFT 16
/*
 * 0 - Digest from LSB. 1 - Digest from MSB. Only relevant if overrid bit is enabled
 * Reset: 0x0         Access: RW
 */
#define CRYPTO_GMAC_CONF_OVERRIDE_DIGEST_FROM_MSB (1 << 17)
#define CRYPTO_GMAC_CONF_OVERRIDE_DIGEST_FROM_MSB_MASK 0x00020000
#define CRYPTO_GMAC_CONF_OVERRIDE_DIGEST_FROM_MSB_SHIFT 17
/* Reset: 0x0         Access: RW */
#define CRYPTO_GMAC_CONF_OVERRIDE_RESERVED_31_18_MASK 0xFFFC0000
#define CRYPTO_GMAC_CONF_OVERRIDE_RESERVED_31_18_SHIFT 18

/**** endianity_swap register ****/
/*
 * bit[0] - bit swap bit[1] - byte swap bit[2] - word swap bit[3] - aes beat swap (128 bit)
 * Reset: 0x0         Access: RW
 */
#define CRYPTO_GMAC_CONF_ENDIANITY_SWAP_INGRESS_MASK 0x0000000F
#define CRYPTO_GMAC_CONF_ENDIANITY_SWAP_INGRESS_SHIFT 0
/*
 * bit[0] - bit swap bit[1] - byte swap bit[2] - word swap bit[3] - aes beat swap (128 bit)
 * Reset: 0x0         Access: RW
 */
#define CRYPTO_GMAC_CONF_ENDIANITY_SWAP_EGRESS_MASK 0x000000F0
#define CRYPTO_GMAC_CONF_ENDIANITY_SWAP_EGRESS_SHIFT 4
/*
 * bit[0] - bit swap bit[1] - byte swap bit[2] - word swap bit[3] - aes beat swap (128 bit)
 * Reset: 0x0         Access: RW
 */
#define CRYPTO_GMAC_CONF_ENDIANITY_SWAP_AES_KEY_MASK 0x00000F00
#define CRYPTO_GMAC_CONF_ENDIANITY_SWAP_AES_KEY_SHIFT 8
/*
 * bit[0] - bit swap bit[1] - byte swap bit[2] - word swap
 * Reset: 0x0         Access: RW
 */
#define CRYPTO_GMAC_CONF_ENDIANITY_SWAP_H_SUBKEY_MASK 0x00007000
#define CRYPTO_GMAC_CONF_ENDIANITY_SWAP_H_SUBKEY_SHIFT 12
/* Reset: 0x0         Access: RW */
#define CRYPTO_GMAC_CONF_ENDIANITY_SWAP_RESERVED_15_15 (1 << 15)
#define CRYPTO_GMAC_CONF_ENDIANITY_SWAP_RESERVED_15_15_MASK 0x00008000
#define CRYPTO_GMAC_CONF_ENDIANITY_SWAP_RESERVED_15_15_SHIFT 15
/*
 * bit[0] - bit swap bit[1] - byte swap bit[2] - word swap
 * Reset: 0x0         Access: RW
 */
#define CRYPTO_GMAC_CONF_ENDIANITY_SWAP_J0_MASK 0x00070000
#define CRYPTO_GMAC_CONF_ENDIANITY_SWAP_J0_SHIFT 16
/* Reset: 0x0         Access: RW */
#define CRYPTO_GMAC_CONF_ENDIANITY_SWAP_RESERVED_19_19 (1 << 19)
#define CRYPTO_GMAC_CONF_ENDIANITY_SWAP_RESERVED_19_19_MASK 0x00080000
#define CRYPTO_GMAC_CONF_ENDIANITY_SWAP_RESERVED_19_19_SHIFT 19
/*
 * bit[0] - bit swap bit[1] - byte swap bit[2] - word swap
 * Reset: 0x0         Access: RW
 */
#define CRYPTO_GMAC_CONF_ENDIANITY_SWAP_SIGN_IN_MASK 0x00700000
#define CRYPTO_GMAC_CONF_ENDIANITY_SWAP_SIGN_IN_SHIFT 20
/* Reset: 0x0         Access: RW */
#define CRYPTO_GMAC_CONF_ENDIANITY_SWAP_RESERVED_23_23 (1 << 23)
#define CRYPTO_GMAC_CONF_ENDIANITY_SWAP_RESERVED_23_23_MASK 0x00800000
#define CRYPTO_GMAC_CONF_ENDIANITY_SWAP_RESERVED_23_23_SHIFT 23
/*
 * bit[0] - bit swap bit[1] - byte swap bit[2] - word swap
 * Reset: 0x0         Access: RW
 */
#define CRYPTO_GMAC_CONF_ENDIANITY_SWAP_SIGN_OUT_MASK 0x07000000
#define CRYPTO_GMAC_CONF_ENDIANITY_SWAP_SIGN_OUT_SHIFT 24
/* Reset: 0x0         Access: RW */
#define CRYPTO_GMAC_CONF_ENDIANITY_SWAP_RESERVED_31_27_MASK 0xF8000000
#define CRYPTO_GMAC_CONF_ENDIANITY_SWAP_RESERVED_31_27_SHIFT 27

/**** data_mask_polarity register ****/
/*
 * 0 - Mask to zero. 1 - Mask to one.
 * Reset: 0x1         Access: RW
 */
#define CRYPTO_GMAC_CONF_DATA_MASK_POLARITY_POL_ID_0 (1 << 0)
#define CRYPTO_GMAC_CONF_DATA_MASK_POLARITY_POL_ID_0_MASK 0x00000001
#define CRYPTO_GMAC_CONF_DATA_MASK_POLARITY_POL_ID_0_SHIFT 0
/*
 * 0 - Mask to zero. 1 - Mask to one.
 * Reset: 0x1         Access: RW
 */
#define CRYPTO_GMAC_CONF_DATA_MASK_POLARITY_POL_ID_1 (1 << 1)
#define CRYPTO_GMAC_CONF_DATA_MASK_POLARITY_POL_ID_1_MASK 0x00000002
#define CRYPTO_GMAC_CONF_DATA_MASK_POLARITY_POL_ID_1_SHIFT 1
/*
 * 0 - Mask to zero. 1 - Mask to one.
 * Reset: 0x1         Access: RW
 */
#define CRYPTO_GMAC_CONF_DATA_MASK_POLARITY_POL_ID_2 (1 << 2)
#define CRYPTO_GMAC_CONF_DATA_MASK_POLARITY_POL_ID_2_MASK 0x00000004
#define CRYPTO_GMAC_CONF_DATA_MASK_POLARITY_POL_ID_2_SHIFT 2
/*
 * 0 - Mask to zero. 1 - Mask to one.
 * Reset: 0x1         Access: RW
 */
#define CRYPTO_GMAC_CONF_DATA_MASK_POLARITY_POL_ID_3 (1 << 3)
#define CRYPTO_GMAC_CONF_DATA_MASK_POLARITY_POL_ID_3_MASK 0x00000008
#define CRYPTO_GMAC_CONF_DATA_MASK_POLARITY_POL_ID_3_SHIFT 3
/* Reset: 0x0         Access: RW */
#define CRYPTO_GMAC_CONF_DATA_MASK_POLARITY_RESERVED_31_4_MASK 0xFFFFFFF0
#define CRYPTO_GMAC_CONF_DATA_MASK_POLARITY_RESERVED_31_4_SHIFT 4

/**************************************************************************************************
 * al_crypto_accelerator_gmac_data_mask
 *
 * mask patterns
 **************************************************************************************************/
struct al_crypto_accelerator_gmac_data_mask {
	/*
	 * [0x0] mask pattern id 0
	 * Reset: 0x0         Access: RW
	 */
	uint32_t id_0;
	/*
	 * [0x4] mask pattern id 1
	 * Reset: 0x0         Access: RW
	 */
	uint32_t id_1;
	/*
	 * [0x8] mask pattern id 2
	 * Reset: 0x0         Access: RW
	 */
	uint32_t id_2;
	/*
	 * [0xc] mask pattern id 3
	 * Reset: 0x0         Access: RW
	 */
	uint32_t id_3;
};

/**************************************************************************************************
 * al_crypto_accelerator_gmac_perf_counters
 **************************************************************************************************/
struct al_crypto_accelerator_gmac_perf_counters {
	/* [0x0] */
	uint32_t configuration;
	/*
	 * [0x4] Value of performance counter
	 * Reset: 0x0         Access: RW
	 */
	uint32_t counter;
};

/**** configuration register ****/
/*
 * Enable performance counter
 * Reset: 0x1         Access: RW
 */
#define CRYPTO_GMAC_PERF_COUNTERS_CONFIGURATION_ENABLE (1 << 0)
#define CRYPTO_GMAC_PERF_COUNTERS_CONFIGURATION_ENABLE_MASK 0x00000001
#define CRYPTO_GMAC_PERF_COUNTERS_CONFIGURATION_ENABLE_SHIFT 0
/*
 * Reset performance counter
 * Reset: 0x0         Access: RW
 */
#define CRYPTO_GMAC_PERF_COUNTERS_CONFIGURATION_RESET (1 << 1)
#define CRYPTO_GMAC_PERF_COUNTERS_CONFIGURATION_RESET_MASK 0x00000002
#define CRYPTO_GMAC_PERF_COUNTERS_CONFIGURATION_RESET_SHIFT 1
/*
 * Clear on read performance counter
 * Reset: 0x1         Access: RW
 */
#define CRYPTO_GMAC_PERF_COUNTERS_CONFIGURATION_CLEAR_ON_READ (1 << 2)
#define CRYPTO_GMAC_PERF_COUNTERS_CONFIGURATION_CLEAR_ON_READ_MASK 0x00000004
#define CRYPTO_GMAC_PERF_COUNTERS_CONFIGURATION_CLEAR_ON_READ_SHIFT 2
/* Reset: 0x0         Access: RW */
#define CRYPTO_GMAC_PERF_COUNTERS_CONFIGURATION_RESERVED_31_3_MASK 0xFFFFFFF8
#define CRYPTO_GMAC_PERF_COUNTERS_CONFIGURATION_RESERVED_31_3_SHIFT 3

/**************************************************************************************************
 * al_crypto_accelerator_comp_to_enc_sub_block_size
 *
 * A padding scheme for encryption packets that were compressed into less than 16B
 **************************************************************************************************/
struct al_crypto_accelerator_comp_to_enc_sub_block_size {
	/*
	 * [0x0]
	 * Reset: 0x3020100   Access: RW
	 */
	uint32_t pad_0;
	/*
	 * [0x4]
	 * Reset: 0x7060504   Access: RW
	 */
	uint32_t pad_1;
	/*
	 * [0x8]
	 * Reset: 0xb0a0908   Access: RW
	 */
	uint32_t pad_2;
	/*
	 * [0xc]
	 * Reset: 0xf0e0d0c   Access: RW
	 */
	uint32_t pad_3;
};

/**************************************************************************************************
 * al_crypto_accelerator_inline_crc_cfg
 *
 * Inline CRC Engine Configurations
 **************************************************************************************************/
struct al_crypto_accelerator_inline_crc_cfg {
	/*
	 * [0x0] reserved register for ECOs, with default value 0
	 * Reset: 0x0         Access: RW
	 */
	uint32_t icrc_reserved_0;
	/*
	 * [0x4] reserved register for ECOs, with default value 1
	 * Reset: 0xffffffff  Access: RW
	 */
	uint32_t icrc_reserved_1;
	/* [0x8] */
	uint32_t icrc_profile_table_idx;
	/* [0xc] */
	uint32_t rsrvd_0[13];
};

/**** icrc_profile_table_idx register ****/
/*
 * enable statically overriding the profile index
 * Reset: 0x0         Access: RW
 */
#define CRYPTO_INLINE_CRC_CFG_ICRC_PROFILE_TABLE_IDX_OVERRIDE_EN (1 << 0)
#define CRYPTO_INLINE_CRC_CFG_ICRC_PROFILE_TABLE_IDX_OVERRIDE_EN_MASK 0x00000001
#define CRYPTO_INLINE_CRC_CFG_ICRC_PROFILE_TABLE_IDX_OVERRIDE_EN_SHIFT 0
/*
 * profile index (only relevant if override_en=1)
 * Reset: 0x0         Access: RW
 */
#define CRYPTO_INLINE_CRC_CFG_ICRC_PROFILE_TABLE_IDX_OVERRIDE_VAL_MASK 0x000000F0
#define CRYPTO_INLINE_CRC_CFG_ICRC_PROFILE_TABLE_IDX_OVERRIDE_VAL_SHIFT 4

/**************************************************************************************************
 * al_crypto_accelerator_inline_crc_start_mask
 *
 * Inline CRC Engine Header Mask
 **************************************************************************************************/
struct al_crypto_accelerator_inline_crc_start_mask {
	/*
	 * [0x0] mask lsbs
	 * Reset: 0x0         Access: RW
	 */
	uint32_t c_mask_0;
	/*
	 * [0x4]
	 * Reset: 0x0         Access: RW
	 */
	uint32_t c_mask_1;
	/*
	 * [0x8]
	 * Reset: 0x0         Access: RW
	 */
	uint32_t c_mask_2;
	/*
	 * [0xc]
	 * Reset: 0x0         Access: RW
	 */
	uint32_t c_mask_3;
};

/**************************************************************************************************
 * al_crypto_accelerator_crc_profile_table
 *
 * CRC Engine Profile Table Configuration
 **************************************************************************************************/
struct al_crypto_accelerator_crc_profile_table {
	/* [0x0] profile table address */
	uint32_t crc_addr;
	/* [0x4] profile table data to read/write */
	uint32_t crc_data;
	/* [0x8] */
	uint32_t rsrvd_0[6];
};

/**** crc_addr register ****/
/*
 * profile table address
 * Reset: 0x0         Access: RW
 */
#define CRYPTO_CRC_PROFILE_TABLE_CRC_ADDR_VAL_MASK 0x0000000F
#define CRYPTO_CRC_PROFILE_TABLE_CRC_ADDR_VAL_SHIFT 0

/**** crc_data register ****/
/*
 * byte swap on ingress data
 * Reset: 0x0         Access: RW
 */
#define CRYPTO_CRC_PROFILE_TABLE_CRC_DATA_INGRESS_BYTE_SWAP (1 << 0)
#define CRYPTO_CRC_PROFILE_TABLE_CRC_DATA_INGRESS_BYTE_SWAP_MASK 0x00000001
#define CRYPTO_CRC_PROFILE_TABLE_CRC_DATA_INGRESS_BYTE_SWAP_SHIFT 0
/*
 * bit swap on ingress data
 * Reset: 0x0         Access: RW
 */
#define CRYPTO_CRC_PROFILE_TABLE_CRC_DATA_INGRESS_BIT_SWAP (1 << 1)
#define CRYPTO_CRC_PROFILE_TABLE_CRC_DATA_INGRESS_BIT_SWAP_MASK 0x00000002
#define CRYPTO_CRC_PROFILE_TABLE_CRC_DATA_INGRESS_BIT_SWAP_SHIFT 1
/*
 * byte swap on result
 * Reset: 0x0         Access: RW
 */
#define CRYPTO_CRC_PROFILE_TABLE_CRC_DATA_RES_BYTE_SWAP (1 << 2)
#define CRYPTO_CRC_PROFILE_TABLE_CRC_DATA_RES_BYTE_SWAP_MASK 0x00000004
#define CRYPTO_CRC_PROFILE_TABLE_CRC_DATA_RES_BYTE_SWAP_SHIFT 2
/*
 * bit swap on result
 * Reset: 0x0         Access: RW
 */
#define CRYPTO_CRC_PROFILE_TABLE_CRC_DATA_RES_BIT_SWAP (1 << 3)
#define CRYPTO_CRC_PROFILE_TABLE_CRC_DATA_RES_BIT_SWAP_MASK 0x00000008
#define CRYPTO_CRC_PROFILE_TABLE_CRC_DATA_RES_BIT_SWAP_SHIFT 3
/*
 * perform one's completement on the result
 * Reset: 0x0         Access: RW
 */
#define CRYPTO_CRC_PROFILE_TABLE_CRC_DATA_RES_ONE_COMPLETEMENT (1 << 4)
#define CRYPTO_CRC_PROFILE_TABLE_CRC_DATA_RES_ONE_COMPLETEMENT_MASK 0x00000010
#define CRYPTO_CRC_PROFILE_TABLE_CRC_DATA_RES_ONE_COMPLETEMENT_SHIFT 4
/*
 * byte swap on iv
 * Reset: 0x0         Access: RW
 */
#define CRYPTO_CRC_PROFILE_TABLE_CRC_DATA_IV_BYTE_SWAP (1 << 5)
#define CRYPTO_CRC_PROFILE_TABLE_CRC_DATA_IV_BYTE_SWAP_MASK 0x00000020
#define CRYPTO_CRC_PROFILE_TABLE_CRC_DATA_IV_BYTE_SWAP_SHIFT 5
/*
 * bit swap on iv
 * Reset: 0x0         Access: RW
 */
#define CRYPTO_CRC_PROFILE_TABLE_CRC_DATA_IV_BIT_SWAP (1 << 6)
#define CRYPTO_CRC_PROFILE_TABLE_CRC_DATA_IV_BIT_SWAP_MASK 0x00000040
#define CRYPTO_CRC_PROFILE_TABLE_CRC_DATA_IV_BIT_SWAP_SHIFT 6
/*
 * perform one's completement on the iv
 * Reset: 0x0         Access: RW
 */
#define CRYPTO_CRC_PROFILE_TABLE_CRC_DATA_IV_ONE_COMPLETEMENT (1 << 7)
#define CRYPTO_CRC_PROFILE_TABLE_CRC_DATA_IV_ONE_COMPLETEMENT_MASK 0x00000080
#define CRYPTO_CRC_PROFILE_TABLE_CRC_DATA_IV_ONE_COMPLETEMENT_SHIFT 7
/*
 * index to crc header mask
 * Reset: 0x0         Access: RW
 */
#define CRYPTO_CRC_PROFILE_TABLE_CRC_DATA_START_MASK_IDX_MASK 0x00030000
#define CRYPTO_CRC_PROFILE_TABLE_CRC_DATA_START_MASK_IDX_SHIFT 16

/**************************************************************************************************
 * crypto_regs
 **************************************************************************************************/
struct crypto_regs {
	/* [0x0] Interrupt Controller */
	uint32_t int_ctrl_mem[64];
	/* [0x100] */
	uint32_t rsrvd_0[128];
	/* [0x300] Crypto Configuration */
	struct al_crypto_accelerator_configuration configuration;
	/* [0x310] Crypto configuration */
	struct al_crypto_accelerator_debug debug;
	/* [0x320] ERROR LOG */
	struct al_crypto_accelerator_log log;
	/* [0x340] Performance Counters */
	struct al_crypto_accelerator_crypto_perf_counter crypto_perf_counter;
	/* [0x390] Performance counter control */
	struct al_crypto_accelerator_perfm_cnt_cntl perfm_cnt_cntl;
	/* [0x394] Crypto Pipe Status register */
	struct al_crypto_accelerator_crypto_status crypto_status;
	/* [0x398] Version of unit_crypto */
	struct al_crypto_accelerator_crypto_version crypto_version;
	/* [0x3a0] Algorithms supported by unit_crypto */
	struct al_crypto_accelerator_crypto_algorithms crypto_algorithms;
	/* [0x3a8] */
	uint32_t rsrvd_1[18];
	/* [0x3f0] reserved regs */
	struct al_crypto_accelerator_reserved reserved;
	/* [0x400] sha3 consts */
	struct al_crypto_accelerator_sha3_round_consts sha3_round_consts[64];
	/* [0x600] sha3 implementation parameters */
	struct al_crypto_accelerator_sha3_params sha3_params;
	/* [0x630] sha3 implementation parameters */
	struct al_crypto_accelerator_sha3_debug sha3_debug;
	/* [0x640] xts configuration */
	struct al_crypto_accelerator_xts_conf xts_conf;
	/* [0x680] gmac configuration */
	struct al_crypto_accelerator_gmac_conf gmac_conf;
	/* [0x690] mask patterns */
	struct al_crypto_accelerator_gmac_data_mask gmac_data_mask[16];
	/* [0x790] */
	struct al_crypto_accelerator_gmac_perf_counters gmac_perf_counters;
	/* [0x798] */
	uint32_t rsrvd_2[98];
	/*
	 * [0x920] A padding scheme for encryption packets that were compressed into less than 16B
	 */
	struct al_crypto_accelerator_comp_to_enc_sub_block_size comp_to_enc_sub_block_size;
	/* [0x930] */
	uint32_t rsrvd_3[436];
	/* [0x1000] Inline CRC Engine Configurations */
	struct al_crypto_accelerator_inline_crc_cfg inline_crc_cfg;
	/* [0x1040] Inline CRC Engine Header Mask */
	struct al_crypto_accelerator_inline_crc_start_mask inline_crc_start_mask[4];
	/* [0x1080] CRC Engine Profile Table Configuration */
	struct al_crypto_accelerator_crc_profile_table crc_profile_table;
	/* [0x10a0] */
	uint32_t rsrvd_4[15320];
};

#ifdef __cplusplus
}
#endif

#endif

/** @} */
