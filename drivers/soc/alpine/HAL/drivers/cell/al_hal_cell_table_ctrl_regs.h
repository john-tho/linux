/*
 * Copyright 2019, Amazon.com, Inc. or its affiliates. All Rights Reserved
 */

/**
 *  @{
 * @file   al_hal_cell_table_ctrl_regs.h
 *
 * @brief cell_table_ctrl registers
 *
 * This file was auto-generated by RegGen v1.3.13
 *
 * Hash Key is: 19fc1bed41950d65b8a0561f5057bad7
 *
 * JSON: AP_TABLE_CTRL.json
 *
 */

#ifndef __AL_HAL_CELL_TABLE_CTRL_REGS_H__
#define __AL_HAL_CELL_TABLE_CTRL_REGS_H__

#include "al_hal_common.h"

#ifdef __cplusplus
extern "C" {
#endif

/**************************************************************************************************
 * al_cell_table_ctrl_regs
 **************************************************************************************************/
struct al_cell_table_ctrl_regs {
	/* [0x0] Table depth - Number of entries */
	uint32_t tbl_param0;
	/* [0x4] Table width (in DWORDS) */
	uint32_t tbl_param1;
	/* [0x8] Table rd/wr address */
	uint32_t tbl_addr;
	/* [0xc] Indirection for line rd/wr offset */
	uint32_t tbl_idx;
	/* [0x10] Data latch reg (offset selected by tbl_idx) */
	uint32_t tbl_data;
	/* [0x14] Table action command. Write to trigger rd/wr */
	uint32_t tbl_cmd;
	/* [0x18] Per agent */
	uint32_t tbl_cpu_ctrl;
	/* [0x1c] Single instance */
	uint32_t table_global_ctrl;
	/* [0x20] Table access status (for non blocking mode) - Per agent */
	uint32_t table_access_status;
	/* [0x24] Protected table base address - per agent */
	uint32_t table_base_offset;
	/* [0x28] Protected table size - per agent */
	uint32_t table_size;
	/*
	 * [0x2c] Number of iterations to perform the next write. Must only be used in non blocking
	 * mode, and with address increment enabled. Reading the register produces the number of
	 * iterations left
	 */
	uint32_t write_repeat;
	/* [0x30] */
	uint32_t hw_access_dbg;
	/* [0x34] */
	uint32_t rsrvd_0[19];
};

/**** tbl_param0 register ****/
/*
 * Table depth
 * Reset: 0x0         Access: RO
 */
#define CELL_TABLE_CTRL_TBL_PARAM0_TABLE_DEPTH_MASK 0xFFFFFFFF
#define CELL_TABLE_CTRL_TBL_PARAM0_TABLE_DEPTH_SHIFT 0

/**** tbl_param1 register ****/
/*
 * Table width
 * Reset: 0x0         Access: RO
 */
#define CELL_TABLE_CTRL_TBL_PARAM1_TABLE_WIDTH_MASK 0xFFFFFFFF
#define CELL_TABLE_CTRL_TBL_PARAM1_TABLE_WIDTH_SHIFT 0

/**** tbl_addr register ****/
/*
 * Indirection register for table address
 * Reset: 0x0         Access: RW
 */
#define CELL_TABLE_CTRL_TBL_ADDR_TABLE_ADDRESS_MASK 0xFFFFFFFF
#define CELL_TABLE_CTRL_TBL_ADDR_TABLE_ADDRESS_SHIFT 0

/**** tbl_idx register ****/
/*
 * Indirection for line rd/wr offset
 * Reset: 0x0         Access: RW
 */
#define CELL_TABLE_CTRL_TBL_IDX_LINE_OFFSET_MASK 0xFFFFFFFF
#define CELL_TABLE_CTRL_TBL_IDX_LINE_OFFSET_SHIFT 0

/**** tbl_data register ****/
/*
 * Data latch reg (offset selected by tbl_idx)
 * Reset: 0x0         Access: RW
 */
#define CELL_TABLE_CTRL_TBL_DATA_DATA_REG_MASK 0xFFFFFFFF
#define CELL_TABLE_CTRL_TBL_DATA_DATA_REG_SHIFT 0

/**** tbl_cmd register ****/
/*
 * Trigger for writing line to table (if selected at agent ctrl reg)
 * Reset: 0x0         Access: WO
 */
#define CELL_TABLE_CTRL_TBL_CMD_WR_TRG   (1 << 0)
#define CELL_TABLE_CTRL_TBL_CMD_WR_TRG_MASK 0x00000001
#define CELL_TABLE_CTRL_TBL_CMD_WR_TRG_SHIFT 0
/*
 * Trigger for reading line from table (if selected at agent ctrl reg)
 * Reset: 0x0         Access: WO
 */
#define CELL_TABLE_CTRL_TBL_CMD_RD_TRG   (1 << 1)
#define CELL_TABLE_CTRL_TBL_CMD_RD_TRG_MASK 0x00000002
#define CELL_TABLE_CTRL_TBL_CMD_RD_TRG_SHIFT 1

/**** tbl_cpu_ctrl register ****/
/*
 * Enable for index reg auto increment
 * Reset: 0x1         Access: RW
 */
#define CELL_TABLE_CTRL_TBL_CPU_CTRL_IDX_AUTO_INC (1 << 0)
#define CELL_TABLE_CTRL_TBL_CPU_CTRL_IDX_AUTO_INC_MASK 0x00000001
#define CELL_TABLE_CTRL_TBL_CPU_CTRL_IDX_AUTO_INC_SHIFT 0
/*
 * Enable for address reg auto increment
 * Reset: 0x1         Access: RW
 */
#define CELL_TABLE_CTRL_TBL_CPU_CTRL_ADDR_AUTO_INC (1 << 1)
#define CELL_TABLE_CTRL_TBL_CPU_CTRL_ADDR_AUTO_INC_MASK 0x00000002
#define CELL_TABLE_CTRL_TBL_CPU_CTRL_ADDR_AUTO_INC_SHIFT 1
/*
 * 1: Trigger on cmd reg write.
 * 0: Trigger on last idx write.
 *
 * Must be 1 if in non-blocking mode
 * Reset: 0x0         Access: RW
 */
#define CELL_TABLE_CTRL_TBL_CPU_CTRL_WR_TRG_SEL (1 << 2)
#define CELL_TABLE_CTRL_TBL_CPU_CTRL_WR_TRG_SEL_MASK 0x00000004
#define CELL_TABLE_CTRL_TBL_CPU_CTRL_WR_TRG_SEL_SHIFT 2
/*
 * 1: Trigger on cmd reg write.
 * 0: Trigger on first idx read.
 *
 * Must be 1 if in non-blocking mode
 * Reset: 0x0         Access: RW
 */
#define CELL_TABLE_CTRL_TBL_CPU_CTRL_RD_TRG_SEL (1 << 3)
#define CELL_TABLE_CTRL_TBL_CPU_CTRL_RD_TRG_SEL_MASK 0x00000008
#define CELL_TABLE_CTRL_TBL_CPU_CTRL_RD_TRG_SEL_SHIFT 3
/*
 * 1: Enable clear of all fields same as read line full of zeros.
 *  0: Disable
 * Reset: 0x0         Access: RW
 */
#define CELL_TABLE_CTRL_TBL_CPU_CTRL_CLR_LINE (1 << 4)
#define CELL_TABLE_CTRL_TBL_CPU_CTRL_CLR_LINE_MASK 0x00000010
#define CELL_TABLE_CTRL_TBL_CPU_CTRL_CLR_LINE_SHIFT 4

/**** table_global_ctrl register ****/
/*
 * 0: Non-blocking access.
 * 1: Blocking access.
 *
 * If 0, rd_trg_sel and wr_trg_sel must be equal 1
 * Reset: 0x1         Access: RW
 */
#define CELL_TABLE_CTRL_TABLE_GLOBAL_CTRL_BLOCKING_SEL (1 << 0)
#define CELL_TABLE_CTRL_TABLE_GLOBAL_CTRL_BLOCKING_SEL_MASK 0x00000001
#define CELL_TABLE_CTRL_TABLE_GLOBAL_CTRL_BLOCKING_SEL_SHIFT 0
/*
 * Override HW tables accesses to address 0
 * Reset: 0x0         Access: RW
 */
#define CELL_TABLE_CTRL_TABLE_GLOBAL_CTRL_OVERRIDE_HW_ADDR (1 << 1)
#define CELL_TABLE_CTRL_TABLE_GLOBAL_CTRL_OVERRIDE_HW_ADDR_MASK 0x00000002
#define CELL_TABLE_CTRL_TABLE_GLOBAL_CTRL_OVERRIDE_HW_ADDR_SHIFT 1
/*
 * Timeout for table access in cycles. 0 = infinite
 * Reset: 0x0         Access: RW
 */
#define CELL_TABLE_CTRL_TABLE_GLOBAL_CTRL_TIMEOUT_MASK 0x07FF0000
#define CELL_TABLE_CTRL_TABLE_GLOBAL_CTRL_TIMEOUT_SHIFT 16

/**** table_access_status register ****/
/*
 * In non blocking mode - table write complete
 * Reset: 0x0         Access: RO
 */
#define CELL_TABLE_CTRL_TABLE_ACCESS_STATUS_LAST_WR_CMPL (1 << 0)
#define CELL_TABLE_CTRL_TABLE_ACCESS_STATUS_LAST_WR_CMPL_MASK 0x00000001
#define CELL_TABLE_CTRL_TABLE_ACCESS_STATUS_LAST_WR_CMPL_SHIFT 0
/*
 * In non blocking mode - table read complete
 * Reset: 0x0         Access: RO
 */
#define CELL_TABLE_CTRL_TABLE_ACCESS_STATUS_LAST_RD_CMPL (1 << 1)
#define CELL_TABLE_CTRL_TABLE_ACCESS_STATUS_LAST_RD_CMPL_MASK 0x00000002
#define CELL_TABLE_CTRL_TABLE_ACCESS_STATUS_LAST_RD_CMPL_SHIFT 1
/*
 * table access timeout, cleared by read
 * Reset: 0x0         Access: RO, RtoClr
 */
#define CELL_TABLE_CTRL_TABLE_ACCESS_STATUS_ACCESS_TIMEOUT (1 << 2)
#define CELL_TABLE_CTRL_TABLE_ACCESS_STATUS_ACCESS_TIMEOUT_MASK 0x00000004
#define CELL_TABLE_CTRL_TABLE_ACCESS_STATUS_ACCESS_TIMEOUT_SHIFT 2

/**** table_base_offset register ****/
/*
 * Per agent - base of allowed access area
 * Reset: 0x0         Access: RO
 */
#define CELL_TABLE_CTRL_TABLE_BASE_OFFSET_DATA_MASK 0xFFFFFFFF
#define CELL_TABLE_CTRL_TABLE_BASE_OFFSET_DATA_SHIFT 0

/**** table_size register ****/
/*
 * Per agent - size of allowed access area
 * Reset: 0x0         Access: RO
 */
#define CELL_TABLE_CTRL_TABLE_SIZE_DATA_MASK 0xFFFFFFFF
#define CELL_TABLE_CTRL_TABLE_SIZE_DATA_SHIFT 0

/**** write_repeat register ****/
/* Reset: 0x0         Access: RW */
#define CELL_TABLE_CTRL_WRITE_REPEAT_CNT_MASK 0xFFFFFFFF
#define CELL_TABLE_CTRL_WRITE_REPEAT_CNT_SHIFT 0

/**** hw_access_dbg register ****/
/*
 * Stores the address last read by the HW
 * Reset: 0x0         Access: RO
 */
#define CELL_TABLE_CTRL_HW_ACCESS_DBG_LAST_HW_RD_ADDR_MASK 0x7FFFFFFF
#define CELL_TABLE_CTRL_HW_ACCESS_DBG_LAST_HW_RD_ADDR_SHIFT 0
/*
 * Valid for last HW read address. Cleared by read
 * Reset: 0x0         Access: RO, RtoClr
 */
#define CELL_TABLE_CTRL_HW_ACCESS_DBG_LAST_HW_RD_ADDR_VLD (1 << 31)
#define CELL_TABLE_CTRL_HW_ACCESS_DBG_LAST_HW_RD_ADDR_VLD_MASK 0x80000000
#define CELL_TABLE_CTRL_HW_ACCESS_DBG_LAST_HW_RD_ADDR_VLD_SHIFT 31

#ifdef __cplusplus
}
#endif

#endif

/** @} */
