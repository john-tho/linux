/*
 * Copyright 2018, Amazon.com, Inc. or its affiliates. All Rights Reserved
 */

/**
 *  @{
 * @file   al_hal_cell_alu_regs.h
 *
 * @brief cell_alu registers
 *
 * This file was auto-generated by RegGen v1.2.3
 *
 */

#ifndef __AL_HAL_CELL_ALU_REGS_H__
#define __AL_HAL_CELL_ALU_REGS_H__

#include "al_hal_plat_types.h"

#ifdef __cplusplus
extern "C" {
#endif

/**************************************************************************************************
 * al_cell_alu_regs
 *
 * AP_ALU configurations
 **************************************************************************************************/
struct al_cell_alu_regs {
	/*
	 * [0x0] opsel vector
	 *
	 * opsel - opsel reg. chooses the operand from the inputs for 1st level operations.
	 * for example - if num_of_ops=2 (2 levels of ALU) then I'll have 4 operands to select for
	 * 1st level ALUs (2 ALU * 2 inputs per ALU),
	 */
	uint32_t opsel[4];
	/*
	 * [0x10] ALU opcodes vector
	 *
	 * opcode - ALU opcode per ALU. for example - if num_of_ops=2 (2 levels of ALU) then there
	 * are 3 ALU (2 in 1st level, 1 in 2nd level).  each selected opcode is assigned to ALU.
	 * Opcodes:
	 * [5]   - ~b Bitwise-inverter on input b
	 * [4]   - ~a Bitwise-inverter on input a
	 * [3:0] -
	 * 0000 = Keep (a)
	 * 0001 = Arithmetic Add (a+b)
	 * 0010 = Arithmetic Subtract (a-b)
	 * 0011 = Bitwise And (a & b)
	 * 0100 = Bitwise Or (a | b)
	 * 0101 = Shift Right (a >> b)
	 * 0110 = Shift Left (a << b)
	 * 0111 = Bitwise Xor (a ^ b)
	 * 1000 = mask_lsb (a[b-1:  0]=0)
	 * 1001 = mask_msb (a[N-1:N-b]=0)
	 */
	uint32_t opcode[3];
	/* [0x1c] */
	uint32_t rsrvd_0;
};

/**** opsel register ****/
/*
 * opsel value
 * Reset: 0x0         Access: RW
 */
#define CELL_ALU_OPSEL_VAL_MASK          0x0000001F
#define CELL_ALU_OPSEL_VAL_SHIFT         0

/**** opcode register ****/
/* Reset: 0x0         Access: RW */
#define CELL_ALU_OPCODE_VAL_MASK         0x0000003F
#define CELL_ALU_OPCODE_VAL_SHIFT        0

#ifdef __cplusplus
}
#endif

#endif

/** @} */
