/*
 * Copyright 2019, Amazon.com, Inc. or its affiliates. All Rights Reserved
 */

/**
 *  @{
 * @file   al_hal_pmdt_pmu_regs.h
 *
 * @brief pmdt_pmu registers
 *
 * This file was auto-generated by RegGen v1.3.9
 *
 * Hash Key is: 7ed0d13fad46d68bdfad1073711f798f
 *
 * JSON: al_pmdt_pmu_regs.json
 *
 */

#ifndef __AL_HAL_PMDT_PMU_REGS_H__
#define __AL_HAL_PMDT_PMU_REGS_H__

#include "al_hal_common.h"

#include "al_hal_pmu_macro_mem_ctrl_regs.h"

#ifdef __cplusplus
extern "C" {
#endif

/**************************************************************************************************
 * al_pmdt_pmu_pmu_cfg
 *
 * General Configuration - Shared PMU setup and status
 **************************************************************************************************/
struct al_pmdt_pmu_pmu_cfg {
	/* [0x0] Misc setups */
	uint32_t general;
	/*
	 * [0x4] Window  size
	 * Window size
	 * Reset: 0x0         Access: RW
	 */
	uint32_t window;
	/*
	 * [0x8] Current timestamp low
	 * Low 32 bits
	 * Reset: 0x0         Access: RO
	 */
	uint32_t tstamp_low;
	/*
	 * [0xc] Current timestamp high
	 * High 32 bits
	 * Reset: 0x0         Access: RO
	 */
	uint32_t tstamp_high;
	/*
	 * [0x10] Current window count low
	 * Low 32 bits
	 * Reset: 0x0         Access: RO
	 */
	uint32_t window_low;
	/*
	 * [0x14] Current window count high
	 * High 32 bits
	 * Reset: 0x0         Access: RO
	 */
	uint32_t window_high;
	/* [0x18] Logged Report Trigger information */
	uint32_t report_status;
	/*
	 * [0x1c] Logged violation count
	 * Number of violations accumulated for the logged event so far.
	 * Reset: 0x0         Access: RO
	 */
	uint32_t report_viol_cnt;
	/*
	 * [0x20] The report logged timestamp low
	 * Low 32 bits
	 * Reset: 0x0         Access: RO
	 */
	uint32_t report_tstamp_low;
	/*
	 * [0x24] The report logged timestamp high
	 * High 32 bits
	 * Reset: 0x0         Access: RO
	 */
	uint32_t report_tstamp_high;
	/*
	 * [0x28] The report logged window count low
	 * Low 32 bits
	 * Reset: 0x0         Access: RO
	 */
	uint32_t report_window_low;
	/*
	 * [0x2c] The report logged window count high
	 * High 32 bits
	 * Reset: 0x0         Access: RO
	 */
	uint32_t report_window_high;
	/*
	 * [0x30] Delay enable
	 * Max value for delaying the enable start from the time it is asserted by software or by
	 * CCTM.
	 * Reset: 0x0         Access: RW
	 */
	uint32_t delayed_enable;
	/*
	 * [0x34] Delay pause
	 * Once paused from upstream CCTM, delays pause assertion by this number of clock cycles.
	 * Reset: 0x0         Access: RW
	 */
	uint32_t delayed_pause;
	/* [0x38] */
	uint32_t rsrvd_0;
	/* [0x3c] Clear instruction */
	uint32_t pmu_status;
};

/**** general register ****/
/*
 * Enable the local PMU module.
 * Reset: 0x0         Access: RW
 */
#define PMDT_PMU_PMU_CFG_GENERAL_PMU_ENABLE (1 << 0)
#define PMDT_PMU_PMU_CFG_GENERAL_PMU_ENABLE_MASK 0x00000001
#define PMDT_PMU_PMU_CFG_GENERAL_PMU_ENABLE_SHIFT 0
/*
 * Enable windows framing. Otherwise accumulates with an infinite window frame.
 * Reset: 0x0         Access: RW
 */
#define PMDT_PMU_PMU_CFG_GENERAL_WINDOWS_EN (1 << 1)
#define PMDT_PMU_PMU_CFG_GENERAL_WINDOWS_EN_MASK 0x00000002
#define PMDT_PMU_PMU_CFG_GENERAL_WINDOWS_EN_SHIFT 1
/*
 * Saturate enable. If set, saturates the window counter. Otherwise wraps around.
 * Reset: 0x0         Access: RW
 */
#define PMDT_PMU_PMU_CFG_GENERAL_SATURATE_EN (1 << 2)
#define PMDT_PMU_PMU_CFG_GENERAL_SATURATE_EN_MASK 0x00000004
#define PMDT_PMU_PMU_CFG_GENERAL_SATURATE_EN_SHIFT 2
/*
 * If set, enables external increment value per event. Otherwise increments by one.
 * Reset: 0x0         Access: RW
 */
#define PMDT_PMU_PMU_CFG_GENERAL_INC_VAL_EN (1 << 3)
#define PMDT_PMU_PMU_CFG_GENERAL_INC_VAL_EN_MASK 0x00000008
#define PMDT_PMU_PMU_CFG_GENERAL_INC_VAL_EN_SHIFT 3
/*
 * Reset-deassertion pause extend. Power of two of the value.
 * Reset: 0x0         Access: RW
 */
#define PMDT_PMU_PMU_CFG_GENERAL_PAUSE_EXTEND_MASK 0x000000F0
#define PMDT_PMU_PMU_CFG_GENERAL_PAUSE_EXTEND_SHIFT 4
/*
 * Enable overflow interrupt
 * Reset: 0x0         Access: RW
 */
#define PMDT_PMU_PMU_CFG_GENERAL_OVF_INTR_EN (1 << 8)
#define PMDT_PMU_PMU_CFG_GENERAL_OVF_INTR_EN_MASK 0x00000100
#define PMDT_PMU_PMU_CFG_GENERAL_OVF_INTR_EN_SHIFT 8
/*
 * Enable underflow interrupt
 * Reset: 0x0         Access: RW
 */
#define PMDT_PMU_PMU_CFG_GENERAL_UNF_INTR_EN (1 << 9)
#define PMDT_PMU_PMU_CFG_GENERAL_UNF_INTR_EN_MASK 0x00000200
#define PMDT_PMU_PMU_CFG_GENERAL_UNF_INTR_EN_SHIFT 9
/*
 * Enable overflow triggering
 * Reset: 0x0         Access: RW
 */
#define PMDT_PMU_PMU_CFG_GENERAL_OVF_TRIG_EN (1 << 10)
#define PMDT_PMU_PMU_CFG_GENERAL_OVF_TRIG_EN_MASK 0x00000400
#define PMDT_PMU_PMU_CFG_GENERAL_OVF_TRIG_EN_SHIFT 10
/*
 * Enable underflow triggering+I16
 * Reset: 0x0         Access: RW
 */
#define PMDT_PMU_PMU_CFG_GENERAL_UNF_TRIG_EN (1 << 11)
#define PMDT_PMU_PMU_CFG_GENERAL_UNF_TRIG_EN_MASK 0x00000800
#define PMDT_PMU_PMU_CFG_GENERAL_UNF_TRIG_EN_SHIFT 11
/*
 * Use Pulse triggers, otherwise Level triggers. For better integration leave as zero (level
 * triggers).
 * Reset: 0x0         Access: RW
 */
#define PMDT_PMU_PMU_CFG_GENERAL_PULSE_TRIG (1 << 12)
#define PMDT_PMU_PMU_CFG_GENERAL_PULSE_TRIG_MASK 0x00001000
#define PMDT_PMU_PMU_CFG_GENERAL_PULSE_TRIG_SHIFT 12
/*
 * Enable routing to GPIO from this PMU
 * Reset: 0x0         Access: RW
 */
#define PMDT_PMU_PMU_CFG_GENERAL_GPIO_EN (1 << 13)
#define PMDT_PMU_PMU_CFG_GENERAL_GPIO_EN_MASK 0x00002000
#define PMDT_PMU_PMU_CFG_GENERAL_GPIO_EN_SHIFT 13
/*
 * Start tracking at window position (otherwise start immediately once enabled).
 * Reset: 0x0         Access: RW
 */
#define PMDT_PMU_PMU_CFG_GENERAL_START_BOUNDARY (1 << 14)
#define PMDT_PMU_PMU_CFG_GENERAL_START_BOUNDARY_MASK 0x00004000
#define PMDT_PMU_PMU_CFG_GENERAL_START_BOUNDARY_SHIFT 14
/*
 * Detach CCTM enable from having an effect locally. If set, use only local enable located at bit[0]
 * of this register.
 * Reset: 0x0         Access: RW
 */
#define PMDT_PMU_PMU_CFG_GENERAL_ENABLE_OVERRIDE (1 << 15)
#define PMDT_PMU_PMU_CFG_GENERAL_ENABLE_OVERRIDE_MASK 0x00008000
#define PMDT_PMU_PMU_CFG_GENERAL_ENABLE_OVERRIDE_SHIFT 15
/*
 * Base timescale for the frame windows clocking
 * Reset: 0x0         Access: RW
 */
#define PMDT_PMU_PMU_CFG_GENERAL_TIMER_RATIO_MASK 0x0FFF0000
#define PMDT_PMU_PMU_CFG_GENERAL_TIMER_RATIO_SHIFT 16
/*
 * Error indications from monitors also cause a trigger.
 * Reset: 0x0         Access: RW
 */
#define PMDT_PMU_PMU_CFG_GENERAL_ERROR_TRIG_EN (1 << 28)
#define PMDT_PMU_PMU_CFG_GENERAL_ERROR_TRIG_EN_MASK 0x10000000
#define PMDT_PMU_PMU_CFG_GENERAL_ERROR_TRIG_EN_SHIFT 28
/*
 * Error indications from monitors also cause a GPIO.
 * Reset: 0x0         Access: RW
 */
#define PMDT_PMU_PMU_CFG_GENERAL_ERROR_GPIO_EN (1 << 29)
#define PMDT_PMU_PMU_CFG_GENERAL_ERROR_GPIO_EN_MASK 0x20000000
#define PMDT_PMU_PMU_CFG_GENERAL_ERROR_GPIO_EN_SHIFT 29
/*
 * SW clear parallel to HW central clear
 * Reset: 0x0         Access: WO
 */
#define PMDT_PMU_PMU_CFG_GENERAL_CLEAR   (1 << 31)
#define PMDT_PMU_PMU_CFG_GENERAL_CLEAR_MASK 0x80000000
#define PMDT_PMU_PMU_CFG_GENERAL_CLEAR_SHIFT 31

/**** report_status register ****/
/*
 * The trigger represents this event counter number.
 * Reset: 0x0         Access: RO
 */
#define PMDT_PMU_PMU_CFG_REPORT_STATUS_EVENT_NUM_MASK 0x0000003F
#define PMDT_PMU_PMU_CFG_REPORT_STATUS_EVENT_NUM_SHIFT 0
/*
 * The trigger log reported an underflow.
 * Reset: 0x0         Access: RO
 */
#define PMDT_PMU_PMU_CFG_REPORT_STATUS_UNF (1 << 28)
#define PMDT_PMU_PMU_CFG_REPORT_STATUS_UNF_MASK 0x10000000
#define PMDT_PMU_PMU_CFG_REPORT_STATUS_UNF_SHIFT 28
/*
 * The trigger log reported an overflow.
 * Reset: 0x0         Access: RO
 */
#define PMDT_PMU_PMU_CFG_REPORT_STATUS_OVF (1 << 29)
#define PMDT_PMU_PMU_CFG_REPORT_STATUS_OVF_MASK 0x20000000
#define PMDT_PMU_PMU_CFG_REPORT_STATUS_OVF_SHIFT 29
/*
 * Logged information is valid.
 * Reset: 0x0         Access: RO
 */
#define PMDT_PMU_PMU_CFG_REPORT_STATUS_VALID (1 << 31)
#define PMDT_PMU_PMU_CFG_REPORT_STATUS_VALID_MASK 0x80000000
#define PMDT_PMU_PMU_CFG_REPORT_STATUS_VALID_SHIFT 31

/**** pmu_status register ****/
/*
 * Number of implemented counters
 * Reset: 0x0         Access: RO
 */
#define PMDT_PMU_PMU_CFG_PMU_STATUS_EVENTS_IMPL_MASK 0x0000003F
#define PMDT_PMU_PMU_CFG_PMU_STATUS_EVENTS_IMPL_SHIFT 0
/*
 * Number of active tracked events
 * Reset: 0x0         Access: RO
 */
#define PMDT_PMU_PMU_CFG_PMU_STATUS_EVENT_SUM_MASK 0x00003F00
#define PMDT_PMU_PMU_CFG_PMU_STATUS_EVENT_SUM_SHIFT 8
/*
 * The event number field is valid.
 * Reset: 0x0         Access: RO
 */
#define PMDT_PMU_PMU_CFG_PMU_STATUS_EVENTS_VALID (1 << 16)
#define PMDT_PMU_PMU_CFG_PMU_STATUS_EVENTS_VALID_MASK 0x00010000
#define PMDT_PMU_PMU_CFG_PMU_STATUS_EVENTS_VALID_SHIFT 16
/*
 * In the case of a combined PMU complex, the number of tracked event channels per AXI monitor.
 * Otherwise reserved
 * Reset: 0x0         Access: RO
 */
#define PMDT_PMU_PMU_CFG_PMU_STATUS_TRC_NUM_MASK 0x000E0000
#define PMDT_PMU_PMU_CFG_PMU_STATUS_TRC_NUM_SHIFT 17
/*
 * In the case of a combined PMU complex, the number of tracked event channels per AXI monitor.
 * Otherwise reserved
 * Reset: 0x0         Access: RO
 */
#define PMDT_PMU_PMU_CFG_PMU_STATUS_TRK_NUM_MASK 0x00F00000
#define PMDT_PMU_PMU_CFG_PMU_STATUS_TRK_NUM_SHIFT 20
/*
 * In the case of a combined PMU complex, the number of AXI monitors attached. Otherwise reserved
 * Reset: 0x0         Access: RO
 */
#define PMDT_PMU_PMU_CFG_PMU_STATUS_MON_NUM_MASK 0x03000000
#define PMDT_PMU_PMU_CFG_PMU_STATUS_MON_NUM_SHIFT 24
/*
 * In the case of a combined PMU complex, the number of ELA tracers attached. Otherwise reserved
 * Reset: 0x0         Access: RO
 */
#define PMDT_PMU_PMU_CFG_PMU_STATUS_ELA_NUM_MASK 0x0C000000
#define PMDT_PMU_PMU_CFG_PMU_STATUS_ELA_NUM_SHIFT 26
/*
 * PMU revision
 * Reset: 0x0         Access: RO
 */
#define PMDT_PMU_PMU_CFG_PMU_STATUS_REVISION_MASK 0xF0000000
#define PMDT_PMU_PMU_CFG_PMU_STATUS_REVISION_SHIFT 28

/**************************************************************************************************
 * al_pmdt_pmu_events
 *
 * Per Bit (Event) setup and statuses
 **************************************************************************************************/
struct al_pmdt_pmu_events {
	/*
	 * [0x0] Event counters enable
	 * Enables the event counters
	 * Reset: 0x0         Access: RW
	 */
	uint32_t event_cnt;
	/*
	 * [0x4] Window usage
	 * Per event ignore window frame and assume accumulation forever (until cleared)
	 * Reset: 0x0         Access: RW
	 */
	uint32_t window_disable;
	/*
	 * [0x8] GPIO selection
	 * Selection of incoming events to be routed out to GPIO
	 * Reset: 0xffffffff  Access: RW
	 */
	uint32_t gpio;
	/*
	 * [0xc] Pause instruction
	 * Reflects incoming upstream pause command to the associated group, otherwise, ignore.
	 * Reset: 0xffffffff  Access: RW
	 */
	uint32_t pause_group;
	/*
	 * [0x10] Clear instruction
	 * Reflects incoming upstream clear command to the associated group, otherwise, ignore.
	 * Reset: 0xffffffff  Access: RW
	 */
	uint32_t clear_group;
	/*
	 * [0x14] SW Events Set Assist register
	 * SW set of the local triggers (Pulse)
	 * Reset: 0x0         Access: WO
	 */
	uint32_t sw_set_trig;
	/*
	 * [0x18] Cross Pause
	 * Accumulative local pause image
	 * Reset: 0x0         Access: RO
	 */
	uint32_t cross_freeze;
	/*
	 * [0x1c] Violation image
	 * Current violation image of the local events
	 * Reset: 0x0         Access: RO
	 */
	uint32_t local_viol;
};

/**************************************************************************************************
 * al_pmdt_pmu_specials
 *
 * None
 **************************************************************************************************/
struct al_pmdt_pmu_specials {
	/* [0x0] Trace Vector assembly */
	uint32_t trace_select;
	/* [0x4] Platform revision */
	uint32_t ver;
	/*
	 * [0x8] Timestamp Offset Low
	 * Timestamp Offset Low
	 * Reset: 0x0         Access: RW
	 */
	uint32_t tstamp_offset_low;
	/*
	 * [0xc] Timestamp Offset High
	 * Timestamp Offset High
	 * Reset: 0x0         Access: RW
	 */
	uint32_t tstamp_offset_high;
	/* [0x10] pmu-complex security configuration */
	uint32_t sec_only;
	/* [0x14] */
	uint32_t rsrvd_0[3];
};

/**** trace_select register ****/
/*
 * Select event counter to be traced once per window.
 * Reset: 0x0         Access: RW
 */
#define PMDT_PMU_SPECIALS_TRACE_SELECT_SEL_MASK 0x000000FF
#define PMDT_PMU_SPECIALS_TRACE_SELECT_SEL_SHIFT 0
/*
 * Auxiliary controls to be used outside of the PMU, but they use the local powered up domain
 * configuration infrastructure.
 * Reset: 0x0         Access: RW
 */
#define PMDT_PMU_SPECIALS_TRACE_SELECT_AUXILIARY_MASK 0x00FF0000
#define PMDT_PMU_SPECIALS_TRACE_SELECT_AUXILIARY_SHIFT 16
/*
 * Enable routing to Trace Buffer (ELA)
 * Reset: 0x0         Access: RW
 */
#define PMDT_PMU_SPECIALS_TRACE_SELECT_TRACE_EN (1 << 31)
#define PMDT_PMU_SPECIALS_TRACE_SELECT_TRACE_EN_MASK 0x80000000
#define PMDT_PMU_SPECIALS_TRACE_SELECT_TRACE_EN_SHIFT 31

/**** ver register ****/
/*
 * Revision number (Minor)
 * Reset: 0x0         Access: RO
 */
#define PMDT_PMU_SPECIALS_VER_DEVICE_REV_ID_MASK 0x0000FFFF
#define PMDT_PMU_SPECIALS_VER_DEVICE_REV_ID_SHIFT 0
/*
 * Revision number (Major)
 * Reset: 0x5         Access: RO
 */
#define PMDT_PMU_SPECIALS_VER_DEVICE_ID_MASK 0xFFFF0000
#define PMDT_PMU_SPECIALS_VER_DEVICE_ID_SHIFT 16

/**** sec_only register ****/
/*
 * pmu security configuration
 * Reset: 0x1         Access: RW
 */
#define PMDT_PMU_SPECIALS_SEC_ONLY_PMU   (1 << 0)
#define PMDT_PMU_SPECIALS_SEC_ONLY_PMU_MASK 0x00000001
#define PMDT_PMU_SPECIALS_SEC_ONLY_PMU_SHIFT 0
/*
 * ela security configuration
 * Reset: 0xff        Access: RW
 */
#define PMDT_PMU_SPECIALS_SEC_ONLY_ELA_MASK 0x000001FE
#define PMDT_PMU_SPECIALS_SEC_ONLY_ELA_SHIFT 1
/*
 * axi monitor security configuration
 * Reset: 0xff        Access: RW
 */
#define PMDT_PMU_SPECIALS_SEC_ONLY_AXI_MON_MASK 0x0001FE00
#define PMDT_PMU_SPECIALS_SEC_ONLY_AXI_MON_SHIFT 9

/**************************************************************************************************
 * al_pmdt_pmu_eco
 **************************************************************************************************/
struct al_pmdt_pmu_eco {
	/*
	 * [0x0] ECO Register
	 * Reset: 0x0         Access: RW
	 */
	uint32_t eco0;
	/*
	 * [0x4] ECO Register
	 * Reset: 0xffffffff  Access: RW
	 */
	uint32_t eco1;
	/*
	 * [0x8] ECO Register
	 * Reset: 0x0         Access: RW
	 */
	uint32_t eco2;
	/*
	 * [0xc] ECO Register
	 * Reset: 0xffffffff  Access: RW
	 */
	uint32_t eco3;
};

/**************************************************************************************************
 * al_pmdt_pmu_cross_matrix
 *
 * Cross Reference between events
 **************************************************************************************************/
struct al_pmdt_pmu_cross_matrix {
	/* [0x0] Trigger associated with this counter */
	uint32_t event_map;
	/*
	 * [0x4] Local pause cross relation
	 * Local pause refection by other event triggers
	 * Reset: 0x0         Access: RW
	 */
	uint32_t cross_trig;
	/* [0x8] */
	uint32_t rsrvd_0[2];
	/*
	 * [0x10] Threshold Registers
	 * Event threshold low - low 32 bits
	 * Reset: 0x0         Access: RW
	 */
	uint32_t threshold_low_lo;
	/*
	 * [0x14] Threshold Registers
	 * Event threshold low - high 32 bits
	 * Reset: 0x0         Access: RW
	 */
	uint32_t threshold_low_hi;
	/*
	 * [0x18] Threshold Registers
	 * Event threshold high - low 32 bits
	 * Reset: 0x0         Access: RW
	 */
	uint32_t threshold_high_lo;
	/*
	 * [0x1c] Threshold Registers
	 * Event threshold high - high 32 bits
	 * Reset: 0x0         Access: RW
	 */
	uint32_t threshold_high_hi;
	/* [0x20] Event Status */
	uint32_t event_status;
	/*
	 * [0x24] Current Event Violations
	 * Accumulative violation count
	 * Reset: 0x0         Access: RO
	 */
	uint32_t violation_count;
	/* [0x28] */
	uint32_t rsrvd_1[2];
	/*
	 * [0x30] Current Event count registers
	 * Low 32 bits
	 * Reset: 0x0         Access: RO
	 */
	uint32_t current_cnt_lo;
	/*
	 * [0x34] Current Event count registers
	 * High 32 bits
	 * Reset: 0x0         Access: RO
	 */
	uint32_t current_cnt_hi;
	/*
	 * [0x38] Last window frame Event count snapshot
	 * Low 32 bits
	 * Reset: 0x0         Access: RO
	 */
	uint32_t previous_cnt_lo;
	/*
	 * [0x3c] Last window frame Event count snapshot
	 * High 32 bits
	 * Reset: 0x0         Access: RO
	 */
	uint32_t previous_cnt_hi;
};

/**** event_map register ****/
/*
 * The trigger number associated with this specific event counter.
 * This configuration chooses the trigger from either external triggers, internal triggers or
 * rerouted triggers, as selected by the event_map->trig_type field.
 * Reset: 0x0         Access: RW
 */
#define PMDT_PMU_CROSS_MATRIX_EVENT_MAP_TRIG_NUM_MASK 0x00007FFF
#define PMDT_PMU_CROSS_MATRIX_EVENT_MAP_TRIG_NUM_SHIFT 0
#define PMDT_PMU_CROSS_MATRIX_EVENT_MAP_ALPINE_V3_TRIG_NUM_MASK 0x0000007F
#define PMDT_PMU_CROSS_MATRIX_EVENT_MAP_ALPINE_V3_TRIG_NUM_SHIFT 0
/*
 * Choose between internal/external/rerouted trigger
 * Reset: 0x0         Access: RW
 */
#define PMDT_PMU_CROSS_MATRIX_EVENT_MAP_TRIG_TYPE_MASK 0xC0000000
#define PMDT_PMU_CROSS_MATRIX_EVENT_MAP_TRIG_TYPE_SHIFT 30
#define PMDT_PMU_CROSS_MATRIX_EVENT_MAP_TRIG_TYPE_INT_TRIG 0
#define PMDT_PMU_CROSS_MATRIX_EVENT_MAP_TRIG_TYPE_EXT_TRIG 1
#define PMDT_PMU_CROSS_MATRIX_EVENT_MAP_TRIG_TYPE_REROUTE_TRIG 2
#define PMDT_PMU_CROSS_MATRIX_EVENT_MAP_ALPINE_V3_TRIG_REROUTE (1 << 7)

/**** event_status register ****/
/*
 * 00 = disabled
 * 01 = active
 * 11 = paused
 * Reset: 0x0         Access: RO
 */
#define PMDT_PMU_CROSS_MATRIX_EVENT_STATUS_STATUS_MASK 0x00000003
#define PMDT_PMU_CROSS_MATRIX_EVENT_STATUS_STATUS_SHIFT 0
/*
 * Event mapped trigger pointer
 * Reset: 0x0         Access: RO
 */
#define PMDT_PMU_CROSS_MATRIX_EVENT_STATUS_TRIG_NUM_MASK 0x01FFFC00
#define PMDT_PMU_CROSS_MATRIX_EVENT_STATUS_TRIG_NUM_SHIFT 10
#define PMDT_PMU_CROSS_MATRIX_EVENT_STATUS_ALPINE_V3_TRIG_NUM_MASK 0x00ff0000
#define PMDT_PMU_CROSS_MATRIX_EVENT_STATUS_ALPINE_V3_TRIG_NUM_SHIFT 16
/*
 * Trigger type for this counter (internal/external/rerouted)
 * Reset: 0x0         Access: RO
 */
#define PMDT_PMU_CROSS_MATRIX_EVENT_STATUS_TRIG_TYPE_MASK 0x06000000
#define PMDT_PMU_CROSS_MATRIX_EVENT_STATUS_TRIG_TYPE_SHIFT 25
#define PMDT_PMU_CROSS_MATRIX_EVENT_STATUS_TRIG_TYPE_INT_TRIG 0
#define PMDT_PMU_CROSS_MATRIX_EVENT_STATUS_TRIG_TYPE_EXT_TRIG 1
#define PMDT_PMU_CROSS_MATRIX_EVENT_STATUS_TRIG_TYPE_REROUTE_TRIG 2
/*
 * Local event local and global enabled
 * Reset: 0x0         Access: RO
 */
#define PMDT_PMU_CROSS_MATRIX_EVENT_STATUS_VALID (1 << 27)
#define PMDT_PMU_CROSS_MATRIX_EVENT_STATUS_VALID_MASK 0x08000000
#define PMDT_PMU_CROSS_MATRIX_EVENT_STATUS_VALID_SHIFT 27
/*
 * Paused for any reason
 * Reset: 0x0         Access: RO
 */
#define PMDT_PMU_CROSS_MATRIX_EVENT_STATUS_PAUSED (1 << 28)
#define PMDT_PMU_CROSS_MATRIX_EVENT_STATUS_PAUSED_MASK 0x10000000
#define PMDT_PMU_CROSS_MATRIX_EVENT_STATUS_PAUSED_SHIFT 28
/*
 * Underflow violation
 * Reset: 0x0         Access: RO
 */
#define PMDT_PMU_CROSS_MATRIX_EVENT_STATUS_UNF (1 << 29)
#define PMDT_PMU_CROSS_MATRIX_EVENT_STATUS_UNF_MASK 0x20000000
#define PMDT_PMU_CROSS_MATRIX_EVENT_STATUS_UNF_SHIFT 29
/*
 * oOverflow violation
 * Reset: 0x0         Access: RO
 */
#define PMDT_PMU_CROSS_MATRIX_EVENT_STATUS_OVF (1 << 30)
#define PMDT_PMU_CROSS_MATRIX_EVENT_STATUS_OVF_MASK 0x40000000
#define PMDT_PMU_CROSS_MATRIX_EVENT_STATUS_OVF_SHIFT 30
/*
 * Any violation
 * Reset: 0x0         Access: RO
 */
#define PMDT_PMU_CROSS_MATRIX_EVENT_STATUS_VIOL (1 << 31)
#define PMDT_PMU_CROSS_MATRIX_EVENT_STATUS_VIOL_MASK 0x80000000
#define PMDT_PMU_CROSS_MATRIX_EVENT_STATUS_VIOL_SHIFT 31

/**************************************************************************************************
 * al_pmdt_pmu_regs
 **************************************************************************************************/
struct al_pmdt_pmu_regs {
	/* [0x0] General Configuration - Shared PMU setup and status */
	struct al_pmdt_pmu_pmu_cfg pmu_cfg;
	/* [0x40] Per Bit (Event) setup and statuses */
	struct al_pmdt_pmu_events events;
	/* [0x60] None */
	struct al_pmdt_pmu_specials specials;
	/*
	 * [0x80] Local interrupt controller. Group A presents the events violations, while Group B
	 * presents errors assembled from the local complex.
	 */
	uint32_t interrupt_ctl[32];
	/* [0x100] */
	uint32_t rsrvd_0[64];
	/* [0x200] */
	struct al_pmdt_pmu_eco eco;
	/* [0x210] */
	uint32_t rsrvd_1[124];
	/* [0x400] pmu macro memory controller */
	struct al_pmu_macro_mem_ctrl_regs mem_ctrl;
	/* [0x800] Cross Reference between events */
	struct al_pmdt_pmu_cross_matrix cross_matrix[32];
};

/* Asserts */
al_static_assert(sizeof(struct al_pmu_macro_mem_ctrl_regs) == 1024,
	"Expected other registers struct size!");

#ifdef __cplusplus
}
#endif

#endif

/** @} */
