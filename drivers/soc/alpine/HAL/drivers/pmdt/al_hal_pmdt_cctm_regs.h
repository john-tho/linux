/*
 * Copyright 2018, Amazon.com, Inc. or its affiliates. All Rights Reserved
 */

/**
 *  @{
 * @file   al_hal_pmdt_cctm_regs.h
 *
 * @brief pmdt_cctm registers
 *
 * This file was auto-generated by RegGen v1.3.8
 *
 * Hash Key is: e3d8d6771675d459ec09afd722a23cc8
 *
 * JSON: al_pmdt_cctm_regs.json
 *
 */

#ifndef __AL_HAL_PMDT_CCTM_REGS_H__
#define __AL_HAL_PMDT_CCTM_REGS_H__

#include "al_hal_common.h"

#ifdef __cplusplus
extern "C" {
#endif

/**************************************************************************************************
 * al_pmdt_cctm_cctm_cfg
 *
 * General Configuration
 **************************************************************************************************/
struct al_pmdt_cctm_cctm_cfg {
	/* [0x0] Status Register */
	uint32_t status;
	/*
	 * [0x4] Pause delay configuration
	 * Pause start delay from pause trigger assert
	 * Reset: 0x0         Access: RW
	 */
	uint32_t cfg_pause_delay;
	/* [0x8] Pause delay configuration */
	uint32_t cfg_pause_ctrl;
	/*
	 * [0xc]
	 * Reset: 0x0         Access: RW
	 */
	uint32_t sec_ovrd;
	/*
	 * [0x10] Active image at the time
	 * Active incoming triggers image
	 * Reset: 0x0         Access: RO
	 */
	uint32_t triggers_0;
	/*
	 * [0x14] Active image at the time
	 * Active incoming triggers image
	 * Reset: 0x0         Access: RO
	 */
	uint32_t triggers_1;
	/*
	 * [0x18] Active image at the time
	 * Active incoming triggers image
	 * Reset: 0x0         Access: RO
	 */
	uint32_t triggers_2;
	/*
	 * [0x1c] Active image at the time
	 * Active incoming triggers image
	 * Reset: 0x0         Access: RO
	 */
	uint32_t triggers_3;
	/*
	 * [0x20] Active image at the time
	 * Active incoming GPIO triggers image
	 * Reset: 0x0         Access: RO
	 */
	uint32_t gpio_0;
	/*
	 * [0x24] Active image at the time
	 * Active incoming GPIO triggers image
	 * Reset: 0x0         Access: RO
	 */
	uint32_t gpio_1;
	/*
	 * [0x28] Active image at the time
	 * Active incoming GPIO triggers image
	 * Reset: 0x0         Access: RO
	 */
	uint32_t gpio_2;
	/*
	 * [0x2c] Active image at the time
	 * Active incoming GPIO triggers image
	 * Reset: 0x0         Access: RO
	 */
	uint32_t gpio_3;
	/*
	 * [0x30] Inferred Pause at the time
	 * Active pause instructions downstream
	 * Reset: 0x0         Access: RO
	 */
	uint32_t pause_0;
	/*
	 * [0x34] Inferred Pause at the time
	 * Active pause instructions downstream
	 * Reset: 0x0         Access: RO
	 */
	uint32_t pause_1;
	/*
	 * [0x38] Inferred Pause at the time
	 * Active pause instructions downstream
	 * Reset: 0x0         Access: RO
	 */
	uint32_t pause_2;
	/*
	 * [0x3c] Inferred Pause at the time
	 * Active pause instructions downstream
	 * Reset: 0x0         Access: RO
	 */
	uint32_t pause_3;
	/*
	 * [0x40] Downstream sources enable
	 * Events enable
	 * Reset: 0x0         Access: RW
	 */
	uint32_t event_en_0;
	/*
	 * [0x44] Downstream sources enable
	 * Events enable
	 * Reset: 0x0         Access: RW
	 */
	uint32_t event_en_1;
	/*
	 * [0x48] Downstream sources enable
	 * Events enable
	 * Reset: 0x0         Access: RW
	 */
	uint32_t event_en_2;
	/*
	 * [0x4c] Downstream sources enable
	 * Events enable
	 * Reset: 0x0         Access: RW
	 */
	uint32_t event_en_3;
	/*
	 * [0x50] GPIO selection
	 * Selection of incoming GPIO to be routed out
	 * Reset: 0x0         Access: RW
	 */
	uint32_t gpio_en_0;
	/*
	 * [0x54] GPIO selection
	 * Selection of incoming GPIO to be routed out
	 * Reset: 0x0         Access: RW
	 */
	uint32_t gpio_en_1;
	/*
	 * [0x58] GPIO selection
	 * Selection of incoming GPIO to be routed out
	 * Reset: 0x0         Access: RW
	 */
	uint32_t gpio_en_2;
	/*
	 * [0x5c] GPIO selection
	 * Selection of incoming GPIO to be routed out
	 * Reset: 0x0         Access: RW
	 */
	uint32_t gpio_en_3;
	/*
	 * [0x60] Pause instruction
	 * SW forced pause downstream
	 * Reset: 0x0         Access: RW, PulseOnW
	 */
	uint32_t pause_en_0;
	/*
	 * [0x64] Pause instruction
	 * SW forced pause downstream
	 * Reset: 0x0         Access: RW, PulseOnW
	 */
	uint32_t pause_en_1;
	/*
	 * [0x68] Pause instruction
	 * SW forced pause downstream
	 * Reset: 0x0         Access: RW, PulseOnW
	 */
	uint32_t pause_en_2;
	/*
	 * [0x6c] Pause instruction
	 * SW forced pause downstream
	 * Reset: 0x0         Access: RW, PulseOnW
	 */
	uint32_t pause_en_3;
	/*
	 * [0x70] Clear instruction
	 * Clear downstream sources.
	 * Reset: 0x0         Access: WO, PulseOnW
	 */
	uint32_t clear_en_0;
	/*
	 * [0x74] Clear instruction
	 * Clear downstream sources.
	 * Reset: 0x0         Access: WO, PulseOnW
	 */
	uint32_t clear_en_1;
	/*
	 * [0x78] Clear instruction
	 * Clear downstream sources.
	 * Reset: 0x0         Access: WO, PulseOnW
	 */
	uint32_t clear_en_2;
	/*
	 * [0x7c] Clear instruction
	 * Clear downstream sources.
	 * Reset: 0x0         Access: WO, PulseOnW
	 */
	uint32_t clear_en_3;
	/*
	 * [0x80] SW Set command
	 * Local trigger set by SW.
	 * Reset: 0x0         Access: RW
	 */
	uint32_t sw_set_0;
	/*
	 * [0x84] SW Set command
	 * Local trigger set by SW.
	 * Reset: 0x0         Access: RW
	 */
	uint32_t sw_set_1;
	/*
	 * [0x88] SW Set command
	 * Local trigger set by SW.
	 * Reset: 0x0         Access: RW
	 */
	uint32_t sw_set_2;
	/*
	 * [0x8c] SW Set command
	 * Local trigger set by SW.
	 * Reset: 0x0         Access: RW
	 */
	uint32_t sw_set_3;
	/* [0x90] Misc setups */
	uint32_t tstamp_ctl0;
	/* [0x94] Misc setups */
	uint32_t tstamp_ctl1;
	/*
	 * [0x98] Tstamp0
	 * Timestamp low 32 bits
	 * Reset: 0x0         Access: RO
	 */
	uint32_t tstamp_low;
	/*
	 * [0x9c] Tstamp1
	 * Timestamp high 32 bits
	 * Reset: 0x0         Access: RO
	 */
	uint32_t tstamp_high;
	/*
	 * [0xa0] Tstamp offset low
	 * Timestamp offset low 32 bits
	 * Reset: 0x0         Access: RW
	 */
	uint32_t tstamp_offset_low;
	/*
	 * [0xa4] Tstamp offset high
	 * Timestamp offset high 32 bits
	 * Reset: 0x0         Access: RW
	 */
	uint32_t tstamp_offset_high;
	/*
	 * [0xa8] Used to allow near-simultaneous start of all PMUs under distributed CCTMs system
	 */
	uint32_t en_unmask;
	/* [0xac] */
	uint32_t rsrvd_0[25];
	/*
	 * [0x110] Active image at the time
	 * Active incoming triggers image
	 * Reset: 0x0         Access: RO
	 */
	uint32_t triggers_4;
	/*
	 * [0x114] Active image at the time
	 * Active incoming triggers image
	 * Reset: 0x0         Access: RO
	 */
	uint32_t triggers_5;
	/* [0x118] */
	uint32_t rsrvd_1[2];
	/*
	 * [0x120] Active image at the time
	 * Active incoming GPIO triggers image
	 * Reset: 0x0         Access: RO
	 */
	uint32_t gpio_4;
	/*
	 * [0x124] Active image at the time
	 * Active incoming GPIO triggers image
	 * Reset: 0x0         Access: RO
	 */
	uint32_t gpio_5;
	/* [0x128] */
	uint32_t rsrvd_2[2];
	/*
	 * [0x130] Inferred Pause at the time
	 * Active pause instructions downstream
	 * Reset: 0x0         Access: RO
	 */
	uint32_t pause_4;
	/*
	 * [0x134] Inferred Pause at the time
	 * Active pause instructions downstream
	 * Reset: 0x0         Access: RO
	 */
	uint32_t pause_5;
	/* [0x138] */
	uint32_t rsrvd_3[2];
	/*
	 * [0x140] Downstream sources enable
	 * Events enable
	 * Reset: 0x0         Access: RW
	 */
	uint32_t event_en_4;
	/*
	 * [0x144] Downstream sources enable
	 * Events enable
	 * Reset: 0x0         Access: RW
	 */
	uint32_t event_en_5;
	/* [0x148] */
	uint32_t rsrvd_4[2];
	/*
	 * [0x150] GPIO selection
	 * Selection of incoming GPIO to be routed out
	 * Reset: 0x0         Access: RW
	 */
	uint32_t gpio_en_4;
	/*
	 * [0x154] GPIO selection
	 * Selection of incoming GPIO to be routed out
	 * Reset: 0x0         Access: RW
	 */
	uint32_t gpio_en_5;
	/* [0x158] */
	uint32_t rsrvd_5[2];
	/*
	 * [0x160] Pause instruction
	 * SW forced pause downstream
	 * Reset: 0x0         Access: RW, PulseOnW
	 */
	uint32_t pause_en_4;
	/*
	 * [0x164] Pause instruction
	 * SW forced pause downstream
	 * Reset: 0x0         Access: RW, PulseOnW
	 */
	uint32_t pause_en_5;
	/* [0x168] */
	uint32_t rsrvd_6[2];
	/*
	 * [0x170] Clear instruction
	 * Clear downstream sources.
	 * Reset: 0x0         Access: WO, PulseOnW
	 */
	uint32_t clear_en_4;
	/*
	 * [0x174] Clear instruction
	 * Clear downstream sources.
	 * Reset: 0x0         Access: WO, PulseOnW
	 */
	uint32_t clear_en_5;
	/* [0x178] */
	uint32_t rsrvd_7[2];
	/*
	 * [0x180] SW Set command
	 * Local trigger set by SW.
	 * Reset: 0x0         Access: RW
	 */
	uint32_t sw_set_4;
	/*
	 * [0x184] SW Set command
	 * Local trigger set by SW.
	 * Reset: 0x0         Access: RW
	 */
	uint32_t sw_set_5;
	/* [0x188] */
	uint32_t rsrvd_8[30];
};

/**** status register ****/
/*
 * Number of implemented counters
 * Reset: 0x0         Access: RO
 */
#define PMDT_CCTM_CCTM_CFG_STATUS_EVENTS_IMPL_MASK 0x000000FF
#define PMDT_CCTM_CCTM_CFG_STATUS_EVENTS_IMPL_SHIFT 0
/*
 * Number of Active tracked events
 * Reset: 0x0         Access: RO
 */
#define PMDT_CCTM_CCTM_CFG_STATUS_EVENT_SUM_MASK 0x0000FF00
#define PMDT_CCTM_CCTM_CFG_STATUS_EVENT_SUM_SHIFT 8
/*
 * The event number field is valid.
 * Reset: 0x0         Access: RO
 */
#define PMDT_CCTM_CCTM_CFG_STATUS_EVENTS_VALID (1 << 16)
#define PMDT_CCTM_CCTM_CFG_STATUS_EVENTS_VALID_MASK 0x00010000
#define PMDT_CCTM_CCTM_CFG_STATUS_EVENTS_VALID_SHIFT 16
/*
 * PMU/CCTM revision
 * Reset: 0x0         Access: RO
 */
#define PMDT_CCTM_CCTM_CFG_STATUS_REVISION_MASK 0xFF000000
#define PMDT_CCTM_CCTM_CFG_STATUS_REVISION_SHIFT 24

/**** cfg_pause_ctrl register ****/
/*
 * Enable pause start delay from software pause assert.
 * Reset: 0x0         Access: RW
 */
#define PMDT_CCTM_CCTM_CFG_CFG_PAUSE_CTRL_SW_SET_DELAY (1 << 0)
#define PMDT_CCTM_CCTM_CFG_CFG_PAUSE_CTRL_SW_SET_DELAY_MASK 0x00000001
#define PMDT_CCTM_CCTM_CFG_CFG_PAUSE_CTRL_SW_SET_DELAY_SHIFT 0
/*
 * Enable pause start delay from pause inferred trigger assert.
 * Reset: 0x0         Access: RW
 */
#define PMDT_CCTM_CCTM_CFG_CFG_PAUSE_CTRL_INFER_DELAY (1 << 1)
#define PMDT_CCTM_CCTM_CFG_CFG_PAUSE_CTRL_INFER_DELAY_MASK 0x00000002
#define PMDT_CCTM_CCTM_CFG_CFG_PAUSE_CTRL_INFER_DELAY_SHIFT 1
/*
 * Reset-deassertion pause extend. Power of two of the value.
 * Reset: 0x0         Access: RW
 */
#define PMDT_CCTM_CCTM_CFG_CFG_PAUSE_CTRL_PAUSE_EXTEND_MASK 0xF0000000
#define PMDT_CCTM_CCTM_CFG_CFG_PAUSE_CTRL_PAUSE_EXTEND_SHIFT 28

/**** tstamp_ctl0 register ****/
/*
 * Timestamp window ratio vs. local clock
 * Reset: 0x1f4       Access: RW
 */
#define PMDT_CCTM_CCTM_CFG_TSTAMP_CTL0_TSTAMP_RATIO_MASK 0x0FFFFFFF
#define PMDT_CCTM_CCTM_CFG_TSTAMP_CTL0_TSTAMP_RATIO_SHIFT 0
/*
 * Sets timestamp mode for this CCTM instance.
 * The default behavior is 'master', in which this CCTM triggers TS inc/clr according to internal
 * timer and tstamp_ctrl1 configurations. In this mode the external TS inc/clr inputs are ignored.
 * In 'slave' behavior, internal timer is disabled,
 *  and downstream inc/clr triggers are propagated according to external triggers.
 * Reset: 0x0         Access: RW
 */
#define PMDT_CCTM_CCTM_CFG_TSTAMP_CTL0_TSTAMP_MODE (1 << 31)
#define PMDT_CCTM_CCTM_CFG_TSTAMP_CTL0_TSTAMP_MODE_MASK 0x80000000
#define PMDT_CCTM_CCTM_CFG_TSTAMP_CTL0_TSTAMP_MODE_SHIFT 31
#define PMDT_CCTM_CCTM_CFG_TSTAMP_CTL0_TSTAMP_MODE_MASTER 0
#define PMDT_CCTM_CCTM_CFG_TSTAMP_CTL0_TSTAMP_MODE_SLAVE 1

/**** tstamp_ctl1 register ****/
/*
 * Time Stamp Clear trigger.
 * When this CCTM is a 'slave' (tstamp_mode=1), this bit is ignored.
 * Reset: 0x0         Access: WO, PulseOnW
 */
#define PMDT_CCTM_CCTM_CFG_TSTAMP_CTL1_TSTAMP_CLEAR (1 << 0)
#define PMDT_CCTM_CCTM_CFG_TSTAMP_CTL1_TSTAMP_CLEAR_MASK 0x00000001
#define PMDT_CCTM_CCTM_CFG_TSTAMP_CTL1_TSTAMP_CLEAR_SHIFT 0
/*
 * Timestamp counter pause.
 * When this CCTM is a 'slave' (tstamp_mode=1), this bit is ignored.
 * Reset: 0x0         Access: RW
 */
#define PMDT_CCTM_CCTM_CFG_TSTAMP_CTL1_TSTAMP_PAUSE (1 << 30)
#define PMDT_CCTM_CCTM_CFG_TSTAMP_CTL1_TSTAMP_PAUSE_MASK 0x40000000
#define PMDT_CCTM_CCTM_CFG_TSTAMP_CTL1_TSTAMP_PAUSE_SHIFT 30
/*
 * Timestamp counter enable.
 * When this CCTM is a 'master' in multiple-CCTMs system, tstamp_en should be set to 1 only after
 * all 'slave' CCTMs were set to 'slave' mode using tstamp_ctl0.tstamp_mode register.
 * When this CCTM is a 'slave' (tstamp_mode=1), this bit is ignored.
 * Reset: 0x0         Access: RW
 */
#define PMDT_CCTM_CCTM_CFG_TSTAMP_CTL1_TSTAMP_EN (1 << 31)
#define PMDT_CCTM_CCTM_CFG_TSTAMP_CTL1_TSTAMP_EN_MASK 0x80000000
#define PMDT_CCTM_CCTM_CFG_TSTAMP_CTL1_TSTAMP_EN_SHIFT 31

/**** en_unmask register ****/
/* Reset: 0x0         Access: RW */
#define PMDT_CCTM_CCTM_CFG_EN_UNMASK_VAL (1 << 0)
#define PMDT_CCTM_CCTM_CFG_EN_UNMASK_VAL_MASK 0x00000001
#define PMDT_CCTM_CCTM_CFG_EN_UNMASK_VAL_SHIFT 0

/**************************************************************************************************
 * al_pmdt_cctm_eco
 **************************************************************************************************/
struct al_pmdt_cctm_eco {
	/*
	 * [0x0] ECO Register
	 * Reset: 0x0         Access: RW
	 */
	uint32_t eco0;
	/*
	 * [0x4] ECO Register
	 * Reset: 0xffffffff  Access: RW
	 */
	uint32_t eco1;
	/*
	 * [0x8] ECO Register
	 * Reset: 0x0         Access: RW
	 */
	uint32_t eco2;
	/*
	 * [0xc] ECO Register
	 * Reset: 0xffffffff  Access: RW
	 */
	uint32_t eco3;
};

/**************************************************************************************************
 * al_pmdt_cctm_cross_matrix
 *
 * Cross Reference between events
 **************************************************************************************************/
struct al_pmdt_cctm_cross_matrix {
	/*
	 * [0x0] Pause reflected by other sources
	 * Event pause dependency on other triggers. [31:0]
	 * Reset: 0x0         Access: RW
	 */
	uint32_t infer_pause_0;
	/*
	 * [0x4] Pause reflected by other sources
	 * Event pause dependency on other triggers. [63:32]
	 * Reset: 0x0         Access: RW
	 */
	uint32_t infer_pause_1;
	/*
	 * [0x8] Pause reflected by other sources
	 * Event pause dependency on other triggers. [95:64]
	 * Reset: 0x0         Access: RW
	 */
	uint32_t infer_pause_2;
	/*
	 * [0xc] Pause reflected by other sources
	 * Event pause dependency on other triggers. [127:96]
	 * Reset: 0x0         Access: RW
	 */
	uint32_t infer_pause_3;
	/*
	 * [0x10] Pause reflected by other sources
	 * Event pause dependency on other triggers. [159:128]
	 * Reset: 0x0         Access: RW
	 */
	uint32_t infer_pause_4;
	/*
	 * [0x14] Pause reflected by other sources
	 * Event pause dependency on other triggers. [191:160]
	 * Reset: 0x0         Access: RW
	 */
	uint32_t infer_pause_5;
};

/**************************************************************************************************
 * al_pmdt_cctm_regs
 **************************************************************************************************/
struct al_pmdt_cctm_regs {
	/* [0x0] Global Interrupt Controller */
	uint32_t interrupt_ctl0[64];
	/* [0x100] General Configuration */
	struct al_pmdt_cctm_cctm_cfg cctm_cfg;
	/* [0x300] */
	struct al_pmdt_cctm_eco eco;
	/* [0x310] */
	uint32_t rsrvd_0[60];
	/* [0x400] Global Interrupt Controller */
	uint32_t interrupt_ctl1[64];
	/* [0x500] */
	uint32_t rsrvd_1[192];
	/* [0x800] Cross Reference between events */
	struct al_pmdt_cctm_cross_matrix cross_matrix[192];
	/* [0x1a00] */
	uint32_t rsrvd_2[384];
};

#ifdef __cplusplus
}
#endif

#endif

/** @} */
